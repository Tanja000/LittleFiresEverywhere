import {
  Browser_default,
  Point,
  TRANSFORM,
  TRANSITION,
  TRANSITION_END,
  addClass,
  bind,
  cancelAnimFrame,
  create,
  create2,
  disableClickPropagation,
  extend,
  falseFn,
  formatNum,
  get,
  getMousePosition,
  getPosition,
  getStyle,
  indexOf,
  isArray,
  isExternalTarget,
  off,
  on,
  preventDefault,
  preventOutline,
  remove,
  removeClass,
  requestAnimFrame,
  setOptions,
  setPosition,
  setTransform,
  splitWords,
  stamp,
  stop,
  toPoint,
  wrapNum
} from "./chunk-ZIY7C4EG.js";
import "./chunk-J43GMYXM.js";

// ../node_modules/leaflet/src/core/Class.js
function Class() {
}
Class.extend = function(props) {
  var NewClass = function() {
    setOptions(this);
    if (this.initialize) {
      this.initialize.apply(this, arguments);
    }
    this.callInitHooks();
  };
  var parentProto = NewClass.__super__ = this.prototype;
  var proto = create(parentProto);
  proto.constructor = NewClass;
  NewClass.prototype = proto;
  for (var i in this) {
    if (Object.prototype.hasOwnProperty.call(this, i) && i !== "prototype" && i !== "__super__") {
      NewClass[i] = this[i];
    }
  }
  if (props.statics) {
    extend(NewClass, props.statics);
  }
  if (props.includes) {
    checkDeprecatedMixinEvents(props.includes);
    extend.apply(null, [proto].concat(props.includes));
  }
  extend(proto, props);
  delete proto.statics;
  delete proto.includes;
  if (proto.options) {
    proto.options = parentProto.options ? create(parentProto.options) : {};
    extend(proto.options, props.options);
  }
  proto._initHooks = [];
  proto.callInitHooks = function() {
    if (this._initHooksCalled) {
      return;
    }
    if (parentProto.callInitHooks) {
      parentProto.callInitHooks.call(this);
    }
    this._initHooksCalled = true;
    for (var i2 = 0, len = proto._initHooks.length; i2 < len; i2++) {
      proto._initHooks[i2].call(this);
    }
  };
  return NewClass;
};
Class.include = function(props) {
  var parentOptions = this.prototype.options;
  extend(this.prototype, props);
  if (props.options) {
    this.prototype.options = parentOptions;
    this.mergeOptions(props.options);
  }
  return this;
};
Class.mergeOptions = function(options) {
  extend(this.prototype.options, options);
  return this;
};
Class.addInitHook = function(fn) {
  var args = Array.prototype.slice.call(arguments, 1);
  var init = typeof fn === "function" ? fn : function() {
    this[fn].apply(this, args);
  };
  this.prototype._initHooks = this.prototype._initHooks || [];
  this.prototype._initHooks.push(init);
  return this;
};
function checkDeprecatedMixinEvents(includes) {
  if (typeof L === "undefined" || !L || !L.Mixin) {
    return;
  }
  includes = isArray(includes) ? includes : [includes];
  for (var i = 0; i < includes.length; i++) {
    if (includes[i] === L.Mixin.Events) {
      console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.", new Error().stack);
    }
  }
}

// ../node_modules/leaflet/src/core/Events.js
var Events = {
  on: function(types, fn, context) {
    if (typeof types === "object") {
      for (var type in types) {
        this._on(type, types[type], fn);
      }
    } else {
      types = splitWords(types);
      for (var i = 0, len = types.length; i < len; i++) {
        this._on(types[i], fn, context);
      }
    }
    return this;
  },
  off: function(types, fn, context) {
    if (!arguments.length) {
      delete this._events;
    } else if (typeof types === "object") {
      for (var type in types) {
        this._off(type, types[type], fn);
      }
    } else {
      types = splitWords(types);
      var removeAll = arguments.length === 1;
      for (var i = 0, len = types.length; i < len; i++) {
        if (removeAll) {
          this._off(types[i]);
        } else {
          this._off(types[i], fn, context);
        }
      }
    }
    return this;
  },
  _on: function(type, fn, context, _once) {
    if (typeof fn !== "function") {
      console.warn("wrong listener type: " + typeof fn);
      return;
    }
    if (this._listens(type, fn, context) !== false) {
      return;
    }
    if (context === this) {
      context = void 0;
    }
    var newListener = { fn, ctx: context };
    if (_once) {
      newListener.once = true;
    }
    this._events = this._events || {};
    this._events[type] = this._events[type] || [];
    this._events[type].push(newListener);
  },
  _off: function(type, fn, context) {
    var listeners, i, len;
    if (!this._events) {
      return;
    }
    listeners = this._events[type];
    if (!listeners) {
      return;
    }
    if (arguments.length === 1) {
      if (this._firingCount) {
        for (i = 0, len = listeners.length; i < len; i++) {
          listeners[i].fn = falseFn;
        }
      }
      delete this._events[type];
      return;
    }
    if (typeof fn !== "function") {
      console.warn("wrong listener type: " + typeof fn);
      return;
    }
    var index = this._listens(type, fn, context);
    if (index !== false) {
      var listener = listeners[index];
      if (this._firingCount) {
        listener.fn = falseFn;
        this._events[type] = listeners = listeners.slice();
      }
      listeners.splice(index, 1);
    }
  },
  fire: function(type, data, propagate) {
    if (!this.listens(type, propagate)) {
      return this;
    }
    var event = extend({}, data, {
      type,
      target: this,
      sourceTarget: data && data.sourceTarget || this
    });
    if (this._events) {
      var listeners = this._events[type];
      if (listeners) {
        this._firingCount = this._firingCount + 1 || 1;
        for (var i = 0, len = listeners.length; i < len; i++) {
          var l = listeners[i];
          var fn = l.fn;
          if (l.once) {
            this.off(type, fn, l.ctx);
          }
          fn.call(l.ctx || this, event);
        }
        this._firingCount--;
      }
    }
    if (propagate) {
      this._propagateEvent(event);
    }
    return this;
  },
  listens: function(type, fn, context, propagate) {
    if (typeof type !== "string") {
      console.warn('"string" type argument expected');
    }
    var _fn = fn;
    if (typeof fn !== "function") {
      propagate = !!fn;
      _fn = void 0;
      context = void 0;
    }
    var listeners = this._events && this._events[type];
    if (listeners && listeners.length) {
      if (this._listens(type, _fn, context) !== false) {
        return true;
      }
    }
    if (propagate) {
      for (var id in this._eventParents) {
        if (this._eventParents[id].listens(type, fn, context, propagate)) {
          return true;
        }
      }
    }
    return false;
  },
  _listens: function(type, fn, context) {
    if (!this._events) {
      return false;
    }
    var listeners = this._events[type] || [];
    if (!fn) {
      return !!listeners.length;
    }
    if (context === this) {
      context = void 0;
    }
    for (var i = 0, len = listeners.length; i < len; i++) {
      if (listeners[i].fn === fn && listeners[i].ctx === context) {
        return i;
      }
    }
    return false;
  },
  once: function(types, fn, context) {
    if (typeof types === "object") {
      for (var type in types) {
        this._on(type, types[type], fn, true);
      }
    } else {
      types = splitWords(types);
      for (var i = 0, len = types.length; i < len; i++) {
        this._on(types[i], fn, context, true);
      }
    }
    return this;
  },
  addEventParent: function(obj) {
    this._eventParents = this._eventParents || {};
    this._eventParents[stamp(obj)] = obj;
    return this;
  },
  removeEventParent: function(obj) {
    if (this._eventParents) {
      delete this._eventParents[stamp(obj)];
    }
    return this;
  },
  _propagateEvent: function(e) {
    for (var id in this._eventParents) {
      this._eventParents[id].fire(e.type, extend({
        layer: e.target,
        propagatedFrom: e.target
      }, e), true);
    }
  }
};
Events.addEventListener = Events.on;
Events.removeEventListener = Events.clearAllEventListeners = Events.off;
Events.addOneTimeEventListener = Events.once;
Events.fireEvent = Events.fire;
Events.hasEventListeners = Events.listens;
var Evented = Class.extend(Events);

// ../node_modules/leaflet/src/geometry/Bounds.js
function Bounds(a, b) {
  if (!a) {
    return;
  }
  var points = b ? [a, b] : a;
  for (var i = 0, len = points.length; i < len; i++) {
    this.extend(points[i]);
  }
}
Bounds.prototype = {
  extend: function(obj) {
    var min2, max2;
    if (!obj) {
      return this;
    }
    if (obj instanceof Point || typeof obj[0] === "number" || "x" in obj) {
      min2 = max2 = toPoint(obj);
    } else {
      obj = toBounds(obj);
      min2 = obj.min;
      max2 = obj.max;
      if (!min2 || !max2) {
        return this;
      }
    }
    if (!this.min && !this.max) {
      this.min = min2.clone();
      this.max = max2.clone();
    } else {
      this.min.x = Math.min(min2.x, this.min.x);
      this.max.x = Math.max(max2.x, this.max.x);
      this.min.y = Math.min(min2.y, this.min.y);
      this.max.y = Math.max(max2.y, this.max.y);
    }
    return this;
  },
  getCenter: function(round) {
    return toPoint(
      (this.min.x + this.max.x) / 2,
      (this.min.y + this.max.y) / 2,
      round
    );
  },
  getBottomLeft: function() {
    return toPoint(this.min.x, this.max.y);
  },
  getTopRight: function() {
    return toPoint(this.max.x, this.min.y);
  },
  getTopLeft: function() {
    return this.min;
  },
  getBottomRight: function() {
    return this.max;
  },
  getSize: function() {
    return this.max.subtract(this.min);
  },
  contains: function(obj) {
    var min, max;
    if (typeof obj[0] === "number" || obj instanceof Point) {
      obj = toPoint(obj);
    } else {
      obj = toBounds(obj);
    }
    if (obj instanceof Bounds) {
      min = obj.min;
      max = obj.max;
    } else {
      min = max = obj;
    }
    return min.x >= this.min.x && max.x <= this.max.x && min.y >= this.min.y && max.y <= this.max.y;
  },
  intersects: function(bounds) {
    bounds = toBounds(bounds);
    var min = this.min, max = this.max, min2 = bounds.min, max2 = bounds.max, xIntersects = max2.x >= min.x && min2.x <= max.x, yIntersects = max2.y >= min.y && min2.y <= max.y;
    return xIntersects && yIntersects;
  },
  overlaps: function(bounds) {
    bounds = toBounds(bounds);
    var min = this.min, max = this.max, min2 = bounds.min, max2 = bounds.max, xOverlaps = max2.x > min.x && min2.x < max.x, yOverlaps = max2.y > min.y && min2.y < max.y;
    return xOverlaps && yOverlaps;
  },
  isValid: function() {
    return !!(this.min && this.max);
  },
  pad: function(bufferRatio) {
    var min = this.min, max = this.max, heightBuffer = Math.abs(min.x - max.x) * bufferRatio, widthBuffer = Math.abs(min.y - max.y) * bufferRatio;
    return toBounds(
      toPoint(min.x - heightBuffer, min.y - widthBuffer),
      toPoint(max.x + heightBuffer, max.y + widthBuffer)
    );
  },
  equals: function(bounds) {
    if (!bounds) {
      return false;
    }
    bounds = toBounds(bounds);
    return this.min.equals(bounds.getTopLeft()) && this.max.equals(bounds.getBottomRight());
  }
};
function toBounds(a, b) {
  if (!a || a instanceof Bounds) {
    return a;
  }
  return new Bounds(a, b);
}

// ../node_modules/leaflet/src/geo/LatLngBounds.js
function LatLngBounds(corner1, corner2) {
  if (!corner1) {
    return;
  }
  var latlngs = corner2 ? [corner1, corner2] : corner1;
  for (var i = 0, len = latlngs.length; i < len; i++) {
    this.extend(latlngs[i]);
  }
}
LatLngBounds.prototype = {
  extend: function(obj) {
    var sw = this._southWest, ne = this._northEast, sw2, ne2;
    if (obj instanceof LatLng) {
      sw2 = obj;
      ne2 = obj;
    } else if (obj instanceof LatLngBounds) {
      sw2 = obj._southWest;
      ne2 = obj._northEast;
      if (!sw2 || !ne2) {
        return this;
      }
    } else {
      return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;
    }
    if (!sw && !ne) {
      this._southWest = new LatLng(sw2.lat, sw2.lng);
      this._northEast = new LatLng(ne2.lat, ne2.lng);
    } else {
      sw.lat = Math.min(sw2.lat, sw.lat);
      sw.lng = Math.min(sw2.lng, sw.lng);
      ne.lat = Math.max(ne2.lat, ne.lat);
      ne.lng = Math.max(ne2.lng, ne.lng);
    }
    return this;
  },
  pad: function(bufferRatio) {
    var sw = this._southWest, ne = this._northEast, heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio, widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;
    return new LatLngBounds(
      new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),
      new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer)
    );
  },
  getCenter: function() {
    return new LatLng(
      (this._southWest.lat + this._northEast.lat) / 2,
      (this._southWest.lng + this._northEast.lng) / 2
    );
  },
  getSouthWest: function() {
    return this._southWest;
  },
  getNorthEast: function() {
    return this._northEast;
  },
  getNorthWest: function() {
    return new LatLng(this.getNorth(), this.getWest());
  },
  getSouthEast: function() {
    return new LatLng(this.getSouth(), this.getEast());
  },
  getWest: function() {
    return this._southWest.lng;
  },
  getSouth: function() {
    return this._southWest.lat;
  },
  getEast: function() {
    return this._northEast.lng;
  },
  getNorth: function() {
    return this._northEast.lat;
  },
  contains: function(obj) {
    if (typeof obj[0] === "number" || obj instanceof LatLng || "lat" in obj) {
      obj = toLatLng(obj);
    } else {
      obj = toLatLngBounds(obj);
    }
    var sw = this._southWest, ne = this._northEast, sw2, ne2;
    if (obj instanceof LatLngBounds) {
      sw2 = obj.getSouthWest();
      ne2 = obj.getNorthEast();
    } else {
      sw2 = ne2 = obj;
    }
    return sw2.lat >= sw.lat && ne2.lat <= ne.lat && sw2.lng >= sw.lng && ne2.lng <= ne.lng;
  },
  intersects: function(bounds) {
    bounds = toLatLngBounds(bounds);
    var sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat, lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;
    return latIntersects && lngIntersects;
  },
  overlaps: function(bounds) {
    bounds = toLatLngBounds(bounds);
    var sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), latOverlaps = ne2.lat > sw.lat && sw2.lat < ne.lat, lngOverlaps = ne2.lng > sw.lng && sw2.lng < ne.lng;
    return latOverlaps && lngOverlaps;
  },
  toBBoxString: function() {
    return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(",");
  },
  equals: function(bounds, maxMargin) {
    if (!bounds) {
      return false;
    }
    bounds = toLatLngBounds(bounds);
    return this._southWest.equals(bounds.getSouthWest(), maxMargin) && this._northEast.equals(bounds.getNorthEast(), maxMargin);
  },
  isValid: function() {
    return !!(this._southWest && this._northEast);
  }
};
function toLatLngBounds(a, b) {
  if (a instanceof LatLngBounds) {
    return a;
  }
  return new LatLngBounds(a, b);
}

// ../node_modules/leaflet/src/geo/LatLng.js
function LatLng(lat, lng, alt) {
  if (isNaN(lat) || isNaN(lng)) {
    throw new Error("Invalid LatLng object: (" + lat + ", " + lng + ")");
  }
  this.lat = +lat;
  this.lng = +lng;
  if (alt !== void 0) {
    this.alt = +alt;
  }
}
LatLng.prototype = {
  equals: function(obj, maxMargin) {
    if (!obj) {
      return false;
    }
    obj = toLatLng(obj);
    var margin = Math.max(
      Math.abs(this.lat - obj.lat),
      Math.abs(this.lng - obj.lng)
    );
    return margin <= (maxMargin === void 0 ? 1e-9 : maxMargin);
  },
  toString: function(precision) {
    return "LatLng(" + formatNum(this.lat, precision) + ", " + formatNum(this.lng, precision) + ")";
  },
  distanceTo: function(other) {
    return Earth.distance(this, toLatLng(other));
  },
  wrap: function() {
    return Earth.wrapLatLng(this);
  },
  toBounds: function(sizeInMeters) {
    var latAccuracy = 180 * sizeInMeters / 40075017, lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * this.lat);
    return toLatLngBounds(
      [this.lat - latAccuracy, this.lng - lngAccuracy],
      [this.lat + latAccuracy, this.lng + lngAccuracy]
    );
  },
  clone: function() {
    return new LatLng(this.lat, this.lng, this.alt);
  }
};
function toLatLng(a, b, c) {
  if (a instanceof LatLng) {
    return a;
  }
  if (isArray(a) && typeof a[0] !== "object") {
    if (a.length === 3) {
      return new LatLng(a[0], a[1], a[2]);
    }
    if (a.length === 2) {
      return new LatLng(a[0], a[1]);
    }
    return null;
  }
  if (a === void 0 || a === null) {
    return a;
  }
  if (typeof a === "object" && "lat" in a) {
    return new LatLng(a.lat, "lng" in a ? a.lng : a.lon, a.alt);
  }
  if (b === void 0) {
    return null;
  }
  return new LatLng(a, b, c);
}

// ../node_modules/leaflet/src/geo/crs/CRS.js
var CRS = {
  latLngToPoint: function(latlng, zoom2) {
    var projectedPoint = this.projection.project(latlng), scale = this.scale(zoom2);
    return this.transformation._transform(projectedPoint, scale);
  },
  pointToLatLng: function(point, zoom2) {
    var scale = this.scale(zoom2), untransformedPoint = this.transformation.untransform(point, scale);
    return this.projection.unproject(untransformedPoint);
  },
  project: function(latlng) {
    return this.projection.project(latlng);
  },
  unproject: function(point) {
    return this.projection.unproject(point);
  },
  scale: function(zoom2) {
    return 256 * Math.pow(2, zoom2);
  },
  zoom: function(scale) {
    return Math.log(scale / 256) / Math.LN2;
  },
  getProjectedBounds: function(zoom2) {
    if (this.infinite) {
      return null;
    }
    var b = this.projection.bounds, s = this.scale(zoom2), min = this.transformation.transform(b.min, s), max = this.transformation.transform(b.max, s);
    return new Bounds(min, max);
  },
  infinite: false,
  wrapLatLng: function(latlng) {
    var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng, lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat, alt = latlng.alt;
    return new LatLng(lat, lng, alt);
  },
  wrapLatLngBounds: function(bounds) {
    var center = bounds.getCenter(), newCenter = this.wrapLatLng(center), latShift = center.lat - newCenter.lat, lngShift = center.lng - newCenter.lng;
    if (latShift === 0 && lngShift === 0) {
      return bounds;
    }
    var sw = bounds.getSouthWest(), ne = bounds.getNorthEast(), newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift), newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);
    return new LatLngBounds(newSw, newNe);
  }
};

// ../node_modules/leaflet/src/geo/crs/CRS.Earth.js
var Earth = extend({}, CRS, {
  wrapLng: [-180, 180],
  R: 6371e3,
  distance: function(latlng1, latlng2) {
    var rad = Math.PI / 180, lat1 = latlng1.lat * rad, lat2 = latlng2.lat * rad, sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2), sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2), a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon, c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return this.R * c;
  }
});

// ../node_modules/leaflet/src/geo/projection/Projection.SphericalMercator.js
var earthRadius = 6378137;
var SphericalMercator = {
  R: earthRadius,
  MAX_LATITUDE: 85.0511287798,
  project: function(latlng) {
    var d = Math.PI / 180, max = this.MAX_LATITUDE, lat = Math.max(Math.min(max, latlng.lat), -max), sin = Math.sin(lat * d);
    return new Point(
      this.R * latlng.lng * d,
      this.R * Math.log((1 + sin) / (1 - sin)) / 2
    );
  },
  unproject: function(point) {
    var d = 180 / Math.PI;
    return new LatLng(
      (2 * Math.atan(Math.exp(point.y / this.R)) - Math.PI / 2) * d,
      point.x * d / this.R
    );
  },
  bounds: function() {
    var d = earthRadius * Math.PI;
    return new Bounds([-d, -d], [d, d]);
  }()
};

// ../node_modules/leaflet/src/geometry/Transformation.js
function Transformation(a, b, c, d) {
  if (isArray(a)) {
    this._a = a[0];
    this._b = a[1];
    this._c = a[2];
    this._d = a[3];
    return;
  }
  this._a = a;
  this._b = b;
  this._c = c;
  this._d = d;
}
Transformation.prototype = {
  transform: function(point, scale) {
    return this._transform(point.clone(), scale);
  },
  _transform: function(point, scale) {
    scale = scale || 1;
    point.x = scale * (this._a * point.x + this._b);
    point.y = scale * (this._c * point.y + this._d);
    return point;
  },
  untransform: function(point, scale) {
    scale = scale || 1;
    return new Point(
      (point.x / scale - this._b) / this._a,
      (point.y / scale - this._d) / this._c
    );
  }
};
function toTransformation(a, b, c, d) {
  return new Transformation(a, b, c, d);
}

// ../node_modules/leaflet/src/geo/crs/CRS.EPSG3857.js
var EPSG3857 = extend({}, Earth, {
  code: "EPSG:3857",
  projection: SphericalMercator,
  transformation: function() {
    var scale = 0.5 / (Math.PI * SphericalMercator.R);
    return toTransformation(scale, 0.5, -scale, 0.5);
  }()
});
var EPSG900913 = extend({}, EPSG3857, {
  code: "EPSG:900913"
});

// ../node_modules/leaflet/src/dom/PosAnimation.js
var PosAnimation = Evented.extend({
  run: function(el, newPos, duration, easeLinearity) {
    this.stop();
    this._el = el;
    this._inProgress = true;
    this._duration = duration || 0.25;
    this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);
    this._startPos = getPosition(el);
    this._offset = newPos.subtract(this._startPos);
    this._startTime = +new Date();
    this.fire("start");
    this._animate();
  },
  stop: function() {
    if (!this._inProgress) {
      return;
    }
    this._step(true);
    this._complete();
  },
  _animate: function() {
    this._animId = requestAnimFrame(this._animate, this);
    this._step();
  },
  _step: function(round) {
    var elapsed = +new Date() - this._startTime, duration = this._duration * 1e3;
    if (elapsed < duration) {
      this._runFrame(this._easeOut(elapsed / duration), round);
    } else {
      this._runFrame(1);
      this._complete();
    }
  },
  _runFrame: function(progress, round) {
    var pos = this._startPos.add(this._offset.multiplyBy(progress));
    if (round) {
      pos._round();
    }
    setPosition(this._el, pos);
    this.fire("step");
  },
  _complete: function() {
    cancelAnimFrame(this._animId);
    this._inProgress = false;
    this.fire("end");
  },
  _easeOut: function(t) {
    return 1 - Math.pow(1 - t, this._easeOutPower);
  }
});

// ../node_modules/leaflet/src/map/Map.js
var Map = Evented.extend({
  options: {
    crs: EPSG3857,
    center: void 0,
    zoom: void 0,
    minZoom: void 0,
    maxZoom: void 0,
    layers: [],
    maxBounds: void 0,
    renderer: void 0,
    zoomAnimation: true,
    zoomAnimationThreshold: 4,
    fadeAnimation: true,
    markerZoomAnimation: true,
    transform3DLimit: 8388608,
    zoomSnap: 1,
    zoomDelta: 1,
    trackResize: true
  },
  initialize: function(id, options) {
    options = setOptions(this, options);
    this._handlers = [];
    this._layers = {};
    this._zoomBoundLayers = {};
    this._sizeChanged = true;
    this._initContainer(id);
    this._initLayout();
    this._onResize = bind(this._onResize, this);
    this._initEvents();
    if (options.maxBounds) {
      this.setMaxBounds(options.maxBounds);
    }
    if (options.zoom !== void 0) {
      this._zoom = this._limitZoom(options.zoom);
    }
    if (options.center && options.zoom !== void 0) {
      this.setView(toLatLng(options.center), options.zoom, { reset: true });
    }
    this.callInitHooks();
    this._zoomAnimated = TRANSITION && Browser_default.any3d && !Browser_default.mobileOpera && this.options.zoomAnimation;
    if (this._zoomAnimated) {
      this._createAnimProxy();
      on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);
    }
    this._addLayers(this.options.layers);
  },
  setView: function(center, zoom2, options) {
    zoom2 = zoom2 === void 0 ? this._zoom : this._limitZoom(zoom2);
    center = this._limitCenter(toLatLng(center), zoom2, this.options.maxBounds);
    options = options || {};
    this._stop();
    if (this._loaded && !options.reset && options !== true) {
      if (options.animate !== void 0) {
        options.zoom = extend({ animate: options.animate }, options.zoom);
        options.pan = extend({ animate: options.animate, duration: options.duration }, options.pan);
      }
      var moved = this._zoom !== zoom2 ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom2, options.zoom) : this._tryAnimatedPan(center, options.pan);
      if (moved) {
        clearTimeout(this._sizeTimer);
        return this;
      }
    }
    this._resetView(center, zoom2, options.pan && options.pan.noMoveStart);
    return this;
  },
  setZoom: function(zoom2, options) {
    if (!this._loaded) {
      this._zoom = zoom2;
      return this;
    }
    return this.setView(this.getCenter(), zoom2, { zoom: options });
  },
  zoomIn: function(delta, options) {
    delta = delta || (Browser_default.any3d ? this.options.zoomDelta : 1);
    return this.setZoom(this._zoom + delta, options);
  },
  zoomOut: function(delta, options) {
    delta = delta || (Browser_default.any3d ? this.options.zoomDelta : 1);
    return this.setZoom(this._zoom - delta, options);
  },
  setZoomAround: function(latlng, zoom2, options) {
    var scale = this.getZoomScale(zoom2), viewHalf = this.getSize().divideBy(2), containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng), centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale), newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));
    return this.setView(newCenter, zoom2, { zoom: options });
  },
  _getBoundsCenterZoom: function(bounds, options) {
    options = options || {};
    bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);
    var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]), paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]), zoom2 = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));
    zoom2 = typeof options.maxZoom === "number" ? Math.min(options.maxZoom, zoom2) : zoom2;
    if (zoom2 === Infinity) {
      return {
        center: bounds.getCenter(),
        zoom: zoom2
      };
    }
    var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2), swPoint = this.project(bounds.getSouthWest(), zoom2), nePoint = this.project(bounds.getNorthEast(), zoom2), center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom2);
    return {
      center,
      zoom: zoom2
    };
  },
  fitBounds: function(bounds, options) {
    bounds = toLatLngBounds(bounds);
    if (!bounds.isValid()) {
      throw new Error("Bounds are not valid.");
    }
    var target = this._getBoundsCenterZoom(bounds, options);
    return this.setView(target.center, target.zoom, options);
  },
  fitWorld: function(options) {
    return this.fitBounds([[-90, -180], [90, 180]], options);
  },
  panTo: function(center, options) {
    return this.setView(center, this._zoom, { pan: options });
  },
  panBy: function(offset, options) {
    offset = toPoint(offset).round();
    options = options || {};
    if (!offset.x && !offset.y) {
      return this.fire("moveend");
    }
    if (options.animate !== true && !this.getSize().contains(offset)) {
      this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
      return this;
    }
    if (!this._panAnim) {
      this._panAnim = new PosAnimation();
      this._panAnim.on({
        "step": this._onPanTransitionStep,
        "end": this._onPanTransitionEnd
      }, this);
    }
    if (!options.noMoveStart) {
      this.fire("movestart");
    }
    if (options.animate !== false) {
      addClass(this._mapPane, "leaflet-pan-anim");
      var newPos = this._getMapPanePos().subtract(offset).round();
      this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
    } else {
      this._rawPanBy(offset);
      this.fire("move").fire("moveend");
    }
    return this;
  },
  flyTo: function(targetCenter, targetZoom, options) {
    options = options || {};
    if (options.animate === false || !Browser_default.any3d) {
      return this.setView(targetCenter, targetZoom, options);
    }
    this._stop();
    var from = this.project(this.getCenter()), to = this.project(targetCenter), size = this.getSize(), startZoom = this._zoom;
    targetCenter = toLatLng(targetCenter);
    targetZoom = targetZoom === void 0 ? startZoom : targetZoom;
    var w0 = Math.max(size.x, size.y), w1 = w0 * this.getZoomScale(startZoom, targetZoom), u1 = to.distanceTo(from) || 1, rho = 1.42, rho2 = rho * rho;
    function r(i) {
      var s1 = i ? -1 : 1, s2 = i ? w1 : w0, t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1, b1 = 2 * s2 * rho2 * u1, b = t1 / b1, sq = Math.sqrt(b * b + 1) - b;
      var log = sq < 1e-9 ? -18 : Math.log(sq);
      return log;
    }
    function sinh(n) {
      return (Math.exp(n) - Math.exp(-n)) / 2;
    }
    function cosh(n) {
      return (Math.exp(n) + Math.exp(-n)) / 2;
    }
    function tanh(n) {
      return sinh(n) / cosh(n);
    }
    var r0 = r(0);
    function w(s) {
      return w0 * (cosh(r0) / cosh(r0 + rho * s));
    }
    function u(s) {
      return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2;
    }
    function easeOut(t) {
      return 1 - Math.pow(1 - t, 1.5);
    }
    var start = Date.now(), S = (r(1) - r0) / rho, duration = options.duration ? 1e3 * options.duration : 1e3 * S * 0.8;
    function frame() {
      var t = (Date.now() - start) / duration, s = easeOut(t) * S;
      if (t <= 1) {
        this._flyToFrame = requestAnimFrame(frame, this);
        this._move(
          this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom),
          this.getScaleZoom(w0 / w(s), startZoom),
          { flyTo: true }
        );
      } else {
        this._move(targetCenter, targetZoom)._moveEnd(true);
      }
    }
    this._moveStart(true, options.noMoveStart);
    frame.call(this);
    return this;
  },
  flyToBounds: function(bounds, options) {
    var target = this._getBoundsCenterZoom(bounds, options);
    return this.flyTo(target.center, target.zoom, options);
  },
  setMaxBounds: function(bounds) {
    bounds = toLatLngBounds(bounds);
    if (this.listens("moveend", this._panInsideMaxBounds)) {
      this.off("moveend", this._panInsideMaxBounds);
    }
    if (!bounds.isValid()) {
      this.options.maxBounds = null;
      return this;
    }
    this.options.maxBounds = bounds;
    if (this._loaded) {
      this._panInsideMaxBounds();
    }
    return this.on("moveend", this._panInsideMaxBounds);
  },
  setMinZoom: function(zoom2) {
    var oldZoom = this.options.minZoom;
    this.options.minZoom = zoom2;
    if (this._loaded && oldZoom !== zoom2) {
      this.fire("zoomlevelschange");
      if (this.getZoom() < this.options.minZoom) {
        return this.setZoom(zoom2);
      }
    }
    return this;
  },
  setMaxZoom: function(zoom2) {
    var oldZoom = this.options.maxZoom;
    this.options.maxZoom = zoom2;
    if (this._loaded && oldZoom !== zoom2) {
      this.fire("zoomlevelschange");
      if (this.getZoom() > this.options.maxZoom) {
        return this.setZoom(zoom2);
      }
    }
    return this;
  },
  panInsideBounds: function(bounds, options) {
    this._enforcingBounds = true;
    var center = this.getCenter(), newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));
    if (!center.equals(newCenter)) {
      this.panTo(newCenter, options);
    }
    this._enforcingBounds = false;
    return this;
  },
  panInside: function(latlng, options) {
    options = options || {};
    var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]), paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]), pixelCenter = this.project(this.getCenter()), pixelPoint = this.project(latlng), pixelBounds = this.getPixelBounds(), paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]), paddedSize = paddedBounds.getSize();
    if (!paddedBounds.contains(pixelPoint)) {
      this._enforcingBounds = true;
      var centerOffset = pixelPoint.subtract(paddedBounds.getCenter());
      var offset = paddedBounds.extend(pixelPoint).getSize().subtract(paddedSize);
      pixelCenter.x += centerOffset.x < 0 ? -offset.x : offset.x;
      pixelCenter.y += centerOffset.y < 0 ? -offset.y : offset.y;
      this.panTo(this.unproject(pixelCenter), options);
      this._enforcingBounds = false;
    }
    return this;
  },
  invalidateSize: function(options) {
    if (!this._loaded) {
      return this;
    }
    options = extend({
      animate: false,
      pan: true
    }, options === true ? { animate: true } : options);
    var oldSize = this.getSize();
    this._sizeChanged = true;
    this._lastCenter = null;
    var newSize = this.getSize(), oldCenter = oldSize.divideBy(2).round(), newCenter = newSize.divideBy(2).round(), offset = oldCenter.subtract(newCenter);
    if (!offset.x && !offset.y) {
      return this;
    }
    if (options.animate && options.pan) {
      this.panBy(offset);
    } else {
      if (options.pan) {
        this._rawPanBy(offset);
      }
      this.fire("move");
      if (options.debounceMoveend) {
        clearTimeout(this._sizeTimer);
        this._sizeTimer = setTimeout(bind(this.fire, this, "moveend"), 200);
      } else {
        this.fire("moveend");
      }
    }
    return this.fire("resize", {
      oldSize,
      newSize
    });
  },
  stop: function() {
    this.setZoom(this._limitZoom(this._zoom));
    if (!this.options.zoomSnap) {
      this.fire("viewreset");
    }
    return this._stop();
  },
  locate: function(options) {
    options = this._locateOptions = extend({
      timeout: 1e4,
      watch: false
    }, options);
    if (!("geolocation" in navigator)) {
      this._handleGeolocationError({
        code: 0,
        message: "Geolocation not supported."
      });
      return this;
    }
    var onResponse = bind(this._handleGeolocationResponse, this), onError = bind(this._handleGeolocationError, this);
    if (options.watch) {
      this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options);
    } else {
      navigator.geolocation.getCurrentPosition(onResponse, onError, options);
    }
    return this;
  },
  stopLocate: function() {
    if (navigator.geolocation && navigator.geolocation.clearWatch) {
      navigator.geolocation.clearWatch(this._locationWatchId);
    }
    if (this._locateOptions) {
      this._locateOptions.setView = false;
    }
    return this;
  },
  _handleGeolocationError: function(error) {
    if (!this._container._leaflet_id) {
      return;
    }
    var c = error.code, message = error.message || (c === 1 ? "permission denied" : c === 2 ? "position unavailable" : "timeout");
    if (this._locateOptions.setView && !this._loaded) {
      this.fitWorld();
    }
    this.fire("locationerror", {
      code: c,
      message: "Geolocation error: " + message + "."
    });
  },
  _handleGeolocationResponse: function(pos) {
    if (!this._container._leaflet_id) {
      return;
    }
    var lat = pos.coords.latitude, lng = pos.coords.longitude, latlng = new LatLng(lat, lng), bounds = latlng.toBounds(pos.coords.accuracy * 2), options = this._locateOptions;
    if (options.setView) {
      var zoom2 = this.getBoundsZoom(bounds);
      this.setView(latlng, options.maxZoom ? Math.min(zoom2, options.maxZoom) : zoom2);
    }
    var data = {
      latlng,
      bounds,
      timestamp: pos.timestamp
    };
    for (var i in pos.coords) {
      if (typeof pos.coords[i] === "number") {
        data[i] = pos.coords[i];
      }
    }
    this.fire("locationfound", data);
  },
  addHandler: function(name, HandlerClass) {
    if (!HandlerClass) {
      return this;
    }
    var handler = this[name] = new HandlerClass(this);
    this._handlers.push(handler);
    if (this.options[name]) {
      handler.enable();
    }
    return this;
  },
  remove: function() {
    this._initEvents(true);
    if (this.options.maxBounds) {
      this.off("moveend", this._panInsideMaxBounds);
    }
    if (this._containerId !== this._container._leaflet_id) {
      throw new Error("Map container is being reused by another instance");
    }
    try {
      delete this._container._leaflet_id;
      delete this._containerId;
    } catch (e) {
      this._container._leaflet_id = void 0;
      this._containerId = void 0;
    }
    if (this._locationWatchId !== void 0) {
      this.stopLocate();
    }
    this._stop();
    remove(this._mapPane);
    if (this._clearControlPos) {
      this._clearControlPos();
    }
    if (this._resizeRequest) {
      cancelAnimFrame(this._resizeRequest);
      this._resizeRequest = null;
    }
    this._clearHandlers();
    if (this._loaded) {
      this.fire("unload");
    }
    var i;
    for (i in this._layers) {
      this._layers[i].remove();
    }
    for (i in this._panes) {
      remove(this._panes[i]);
    }
    this._layers = [];
    this._panes = [];
    delete this._mapPane;
    delete this._renderer;
    return this;
  },
  createPane: function(name, container) {
    var className = "leaflet-pane" + (name ? " leaflet-" + name.replace("Pane", "") + "-pane" : ""), pane = create2("div", className, container || this._mapPane);
    if (name) {
      this._panes[name] = pane;
    }
    return pane;
  },
  getCenter: function() {
    this._checkIfLoaded();
    if (this._lastCenter && !this._moved()) {
      return this._lastCenter.clone();
    }
    return this.layerPointToLatLng(this._getCenterLayerPoint());
  },
  getZoom: function() {
    return this._zoom;
  },
  getBounds: function() {
    var bounds = this.getPixelBounds(), sw = this.unproject(bounds.getBottomLeft()), ne = this.unproject(bounds.getTopRight());
    return new LatLngBounds(sw, ne);
  },
  getMinZoom: function() {
    return this.options.minZoom === void 0 ? this._layersMinZoom || 0 : this.options.minZoom;
  },
  getMaxZoom: function() {
    return this.options.maxZoom === void 0 ? this._layersMaxZoom === void 0 ? Infinity : this._layersMaxZoom : this.options.maxZoom;
  },
  getBoundsZoom: function(bounds, inside, padding) {
    bounds = toLatLngBounds(bounds);
    padding = toPoint(padding || [0, 0]);
    var zoom2 = this.getZoom() || 0, min = this.getMinZoom(), max = this.getMaxZoom(), nw = bounds.getNorthWest(), se = bounds.getSouthEast(), size = this.getSize().subtract(padding), boundsSize = toBounds(this.project(se, zoom2), this.project(nw, zoom2)).getSize(), snap = Browser_default.any3d ? this.options.zoomSnap : 1, scalex = size.x / boundsSize.x, scaley = size.y / boundsSize.y, scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);
    zoom2 = this.getScaleZoom(scale, zoom2);
    if (snap) {
      zoom2 = Math.round(zoom2 / (snap / 100)) * (snap / 100);
      zoom2 = inside ? Math.ceil(zoom2 / snap) * snap : Math.floor(zoom2 / snap) * snap;
    }
    return Math.max(min, Math.min(max, zoom2));
  },
  getSize: function() {
    if (!this._size || this._sizeChanged) {
      this._size = new Point(
        this._container.clientWidth || 0,
        this._container.clientHeight || 0
      );
      this._sizeChanged = false;
    }
    return this._size.clone();
  },
  getPixelBounds: function(center, zoom2) {
    var topLeftPoint = this._getTopLeftPoint(center, zoom2);
    return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
  },
  getPixelOrigin: function() {
    this._checkIfLoaded();
    return this._pixelOrigin;
  },
  getPixelWorldBounds: function(zoom2) {
    return this.options.crs.getProjectedBounds(zoom2 === void 0 ? this.getZoom() : zoom2);
  },
  getPane: function(pane) {
    return typeof pane === "string" ? this._panes[pane] : pane;
  },
  getPanes: function() {
    return this._panes;
  },
  getContainer: function() {
    return this._container;
  },
  getZoomScale: function(toZoom, fromZoom) {
    var crs = this.options.crs;
    fromZoom = fromZoom === void 0 ? this._zoom : fromZoom;
    return crs.scale(toZoom) / crs.scale(fromZoom);
  },
  getScaleZoom: function(scale, fromZoom) {
    var crs = this.options.crs;
    fromZoom = fromZoom === void 0 ? this._zoom : fromZoom;
    var zoom2 = crs.zoom(scale * crs.scale(fromZoom));
    return isNaN(zoom2) ? Infinity : zoom2;
  },
  project: function(latlng, zoom2) {
    zoom2 = zoom2 === void 0 ? this._zoom : zoom2;
    return this.options.crs.latLngToPoint(toLatLng(latlng), zoom2);
  },
  unproject: function(point, zoom2) {
    zoom2 = zoom2 === void 0 ? this._zoom : zoom2;
    return this.options.crs.pointToLatLng(toPoint(point), zoom2);
  },
  layerPointToLatLng: function(point) {
    var projectedPoint = toPoint(point).add(this.getPixelOrigin());
    return this.unproject(projectedPoint);
  },
  latLngToLayerPoint: function(latlng) {
    var projectedPoint = this.project(toLatLng(latlng))._round();
    return projectedPoint._subtract(this.getPixelOrigin());
  },
  wrapLatLng: function(latlng) {
    return this.options.crs.wrapLatLng(toLatLng(latlng));
  },
  wrapLatLngBounds: function(latlng) {
    return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));
  },
  distance: function(latlng1, latlng2) {
    return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));
  },
  containerPointToLayerPoint: function(point) {
    return toPoint(point).subtract(this._getMapPanePos());
  },
  layerPointToContainerPoint: function(point) {
    return toPoint(point).add(this._getMapPanePos());
  },
  containerPointToLatLng: function(point) {
    var layerPoint = this.containerPointToLayerPoint(toPoint(point));
    return this.layerPointToLatLng(layerPoint);
  },
  latLngToContainerPoint: function(latlng) {
    return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));
  },
  mouseEventToContainerPoint: function(e) {
    return getMousePosition(e, this._container);
  },
  mouseEventToLayerPoint: function(e) {
    return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
  },
  mouseEventToLatLng: function(e) {
    return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
  },
  _initContainer: function(id) {
    var container = this._container = get(id);
    if (!container) {
      throw new Error("Map container not found.");
    } else if (container._leaflet_id) {
      throw new Error("Map container is already initialized.");
    }
    on(container, "scroll", this._onScroll, this);
    this._containerId = stamp(container);
  },
  _initLayout: function() {
    var container = this._container;
    this._fadeAnimated = this.options.fadeAnimation && Browser_default.any3d;
    addClass(container, "leaflet-container" + (Browser_default.touch ? " leaflet-touch" : "") + (Browser_default.retina ? " leaflet-retina" : "") + (Browser_default.ielt9 ? " leaflet-oldie" : "") + (Browser_default.safari ? " leaflet-safari" : "") + (this._fadeAnimated ? " leaflet-fade-anim" : ""));
    var position = getStyle(container, "position");
    if (position !== "absolute" && position !== "relative" && position !== "fixed" && position !== "sticky") {
      container.style.position = "relative";
    }
    this._initPanes();
    if (this._initControlPos) {
      this._initControlPos();
    }
  },
  _initPanes: function() {
    var panes = this._panes = {};
    this._paneRenderers = {};
    this._mapPane = this.createPane("mapPane", this._container);
    setPosition(this._mapPane, new Point(0, 0));
    this.createPane("tilePane");
    this.createPane("overlayPane");
    this.createPane("shadowPane");
    this.createPane("markerPane");
    this.createPane("tooltipPane");
    this.createPane("popupPane");
    if (!this.options.markerZoomAnimation) {
      addClass(panes.markerPane, "leaflet-zoom-hide");
      addClass(panes.shadowPane, "leaflet-zoom-hide");
    }
  },
  _resetView: function(center, zoom2, noMoveStart) {
    setPosition(this._mapPane, new Point(0, 0));
    var loading = !this._loaded;
    this._loaded = true;
    zoom2 = this._limitZoom(zoom2);
    this.fire("viewprereset");
    var zoomChanged = this._zoom !== zoom2;
    this._moveStart(zoomChanged, noMoveStart)._move(center, zoom2)._moveEnd(zoomChanged);
    this.fire("viewreset");
    if (loading) {
      this.fire("load");
    }
  },
  _moveStart: function(zoomChanged, noMoveStart) {
    if (zoomChanged) {
      this.fire("zoomstart");
    }
    if (!noMoveStart) {
      this.fire("movestart");
    }
    return this;
  },
  _move: function(center, zoom2, data, supressEvent) {
    if (zoom2 === void 0) {
      zoom2 = this._zoom;
    }
    var zoomChanged = this._zoom !== zoom2;
    this._zoom = zoom2;
    this._lastCenter = center;
    this._pixelOrigin = this._getNewPixelOrigin(center);
    if (!supressEvent) {
      if (zoomChanged || data && data.pinch) {
        this.fire("zoom", data);
      }
      this.fire("move", data);
    } else if (data && data.pinch) {
      this.fire("zoom", data);
    }
    return this;
  },
  _moveEnd: function(zoomChanged) {
    if (zoomChanged) {
      this.fire("zoomend");
    }
    return this.fire("moveend");
  },
  _stop: function() {
    cancelAnimFrame(this._flyToFrame);
    if (this._panAnim) {
      this._panAnim.stop();
    }
    return this;
  },
  _rawPanBy: function(offset) {
    setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
  },
  _getZoomSpan: function() {
    return this.getMaxZoom() - this.getMinZoom();
  },
  _panInsideMaxBounds: function() {
    if (!this._enforcingBounds) {
      this.panInsideBounds(this.options.maxBounds);
    }
  },
  _checkIfLoaded: function() {
    if (!this._loaded) {
      throw new Error("Set map center and zoom first.");
    }
  },
  _initEvents: function(remove2) {
    this._targets = {};
    this._targets[stamp(this._container)] = this;
    var onOff = remove2 ? off : on;
    onOff(this._container, "click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress keydown keyup", this._handleDOMEvent, this);
    if (this.options.trackResize) {
      onOff(window, "resize", this._onResize, this);
    }
    if (Browser_default.any3d && this.options.transform3DLimit) {
      (remove2 ? this.off : this.on).call(this, "moveend", this._onMoveEnd);
    }
  },
  _onResize: function() {
    cancelAnimFrame(this._resizeRequest);
    this._resizeRequest = requestAnimFrame(
      function() {
        this.invalidateSize({ debounceMoveend: true });
      },
      this
    );
  },
  _onScroll: function() {
    this._container.scrollTop = 0;
    this._container.scrollLeft = 0;
  },
  _onMoveEnd: function() {
    var pos = this._getMapPanePos();
    if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
      this._resetView(this.getCenter(), this.getZoom());
    }
  },
  _findEventTargets: function(e, type) {
    var targets = [], target, isHover = type === "mouseout" || type === "mouseover", src = e.target || e.srcElement, dragging = false;
    while (src) {
      target = this._targets[stamp(src)];
      if (target && (type === "click" || type === "preclick") && this._draggableMoved(target)) {
        dragging = true;
        break;
      }
      if (target && target.listens(type, true)) {
        if (isHover && !isExternalTarget(src, e)) {
          break;
        }
        targets.push(target);
        if (isHover) {
          break;
        }
      }
      if (src === this._container) {
        break;
      }
      src = src.parentNode;
    }
    if (!targets.length && !dragging && !isHover && this.listens(type, true)) {
      targets = [this];
    }
    return targets;
  },
  _isClickDisabled: function(el) {
    while (el && el !== this._container) {
      if (el["_leaflet_disable_click"]) {
        return true;
      }
      el = el.parentNode;
    }
  },
  _handleDOMEvent: function(e) {
    var el = e.target || e.srcElement;
    if (!this._loaded || el["_leaflet_disable_events"] || e.type === "click" && this._isClickDisabled(el)) {
      return;
    }
    var type = e.type;
    if (type === "mousedown") {
      preventOutline(el);
    }
    this._fireDOMEvent(e, type);
  },
  _mouseEvents: ["click", "dblclick", "mouseover", "mouseout", "contextmenu"],
  _fireDOMEvent: function(e, type, canvasTargets) {
    if (e.type === "click") {
      var synth = extend({}, e);
      synth.type = "preclick";
      this._fireDOMEvent(synth, synth.type, canvasTargets);
    }
    var targets = this._findEventTargets(e, type);
    if (canvasTargets) {
      var filtered = [];
      for (var i = 0; i < canvasTargets.length; i++) {
        if (canvasTargets[i].listens(type, true)) {
          filtered.push(canvasTargets[i]);
        }
      }
      targets = filtered.concat(targets);
    }
    if (!targets.length) {
      return;
    }
    if (type === "contextmenu") {
      preventDefault(e);
    }
    var target = targets[0];
    var data = {
      originalEvent: e
    };
    if (e.type !== "keypress" && e.type !== "keydown" && e.type !== "keyup") {
      var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);
      data.containerPoint = isMarker ? this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
      data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
      data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
    }
    for (i = 0; i < targets.length; i++) {
      targets[i].fire(type, data, true);
      if (data.originalEvent._stopped || targets[i].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1) {
        return;
      }
    }
  },
  _draggableMoved: function(obj) {
    obj = obj.dragging && obj.dragging.enabled() ? obj : this;
    return obj.dragging && obj.dragging.moved() || this.boxZoom && this.boxZoom.moved();
  },
  _clearHandlers: function() {
    for (var i = 0, len = this._handlers.length; i < len; i++) {
      this._handlers[i].disable();
    }
  },
  whenReady: function(callback, context) {
    if (this._loaded) {
      callback.call(context || this, { target: this });
    } else {
      this.on("load", callback, context);
    }
    return this;
  },
  _getMapPanePos: function() {
    return getPosition(this._mapPane) || new Point(0, 0);
  },
  _moved: function() {
    var pos = this._getMapPanePos();
    return pos && !pos.equals([0, 0]);
  },
  _getTopLeftPoint: function(center, zoom2) {
    var pixelOrigin = center && zoom2 !== void 0 ? this._getNewPixelOrigin(center, zoom2) : this.getPixelOrigin();
    return pixelOrigin.subtract(this._getMapPanePos());
  },
  _getNewPixelOrigin: function(center, zoom2) {
    var viewHalf = this.getSize()._divideBy(2);
    return this.project(center, zoom2)._subtract(viewHalf)._add(this._getMapPanePos())._round();
  },
  _latLngToNewLayerPoint: function(latlng, zoom2, center) {
    var topLeft = this._getNewPixelOrigin(center, zoom2);
    return this.project(latlng, zoom2)._subtract(topLeft);
  },
  _latLngBoundsToNewLayerBounds: function(latLngBounds, zoom2, center) {
    var topLeft = this._getNewPixelOrigin(center, zoom2);
    return toBounds([
      this.project(latLngBounds.getSouthWest(), zoom2)._subtract(topLeft),
      this.project(latLngBounds.getNorthWest(), zoom2)._subtract(topLeft),
      this.project(latLngBounds.getSouthEast(), zoom2)._subtract(topLeft),
      this.project(latLngBounds.getNorthEast(), zoom2)._subtract(topLeft)
    ]);
  },
  _getCenterLayerPoint: function() {
    return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
  },
  _getCenterOffset: function(latlng) {
    return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
  },
  _limitCenter: function(center, zoom2, bounds) {
    if (!bounds) {
      return center;
    }
    var centerPoint = this.project(center, zoom2), viewHalf = this.getSize().divideBy(2), viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)), offset = this._getBoundsOffset(viewBounds, bounds, zoom2);
    if (Math.abs(offset.x) <= 1 && Math.abs(offset.y) <= 1) {
      return center;
    }
    return this.unproject(centerPoint.add(offset), zoom2);
  },
  _limitOffset: function(offset, bounds) {
    if (!bounds) {
      return offset;
    }
    var viewBounds = this.getPixelBounds(), newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));
    return offset.add(this._getBoundsOffset(newBounds, bounds));
  },
  _getBoundsOffset: function(pxBounds, maxBounds, zoom2) {
    var projectedMaxBounds = toBounds(
      this.project(maxBounds.getNorthEast(), zoom2),
      this.project(maxBounds.getSouthWest(), zoom2)
    ), minOffset = projectedMaxBounds.min.subtract(pxBounds.min), maxOffset = projectedMaxBounds.max.subtract(pxBounds.max), dx = this._rebound(minOffset.x, -maxOffset.x), dy = this._rebound(minOffset.y, -maxOffset.y);
    return new Point(dx, dy);
  },
  _rebound: function(left, right) {
    return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
  },
  _limitZoom: function(zoom2) {
    var min = this.getMinZoom(), max = this.getMaxZoom(), snap = Browser_default.any3d ? this.options.zoomSnap : 1;
    if (snap) {
      zoom2 = Math.round(zoom2 / snap) * snap;
    }
    return Math.max(min, Math.min(max, zoom2));
  },
  _onPanTransitionStep: function() {
    this.fire("move");
  },
  _onPanTransitionEnd: function() {
    removeClass(this._mapPane, "leaflet-pan-anim");
    this.fire("moveend");
  },
  _tryAnimatedPan: function(center, options) {
    var offset = this._getCenterOffset(center)._trunc();
    if ((options && options.animate) !== true && !this.getSize().contains(offset)) {
      return false;
    }
    this.panBy(offset, options);
    return true;
  },
  _createAnimProxy: function() {
    var proxy = this._proxy = create2("div", "leaflet-proxy leaflet-zoom-animated");
    this._panes.mapPane.appendChild(proxy);
    this.on("zoomanim", function(e) {
      var prop = TRANSFORM, transform = this._proxy.style[prop];
      setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));
      if (transform === this._proxy.style[prop] && this._animatingZoom) {
        this._onZoomTransitionEnd();
      }
    }, this);
    this.on("load moveend", this._animMoveEnd, this);
    this._on("unload", this._destroyAnimProxy, this);
  },
  _destroyAnimProxy: function() {
    remove(this._proxy);
    this.off("load moveend", this._animMoveEnd, this);
    delete this._proxy;
  },
  _animMoveEnd: function() {
    var c = this.getCenter(), z = this.getZoom();
    setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));
  },
  _catchTransitionEnd: function(e) {
    if (this._animatingZoom && e.propertyName.indexOf("transform") >= 0) {
      this._onZoomTransitionEnd();
    }
  },
  _nothingToAnimate: function() {
    return !this._container.getElementsByClassName("leaflet-zoom-animated").length;
  },
  _tryAnimatedZoom: function(center, zoom2, options) {
    if (this._animatingZoom) {
      return true;
    }
    options = options || {};
    if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() || Math.abs(zoom2 - this._zoom) > this.options.zoomAnimationThreshold) {
      return false;
    }
    var scale = this.getZoomScale(zoom2), offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);
    if (options.animate !== true && !this.getSize().contains(offset)) {
      return false;
    }
    requestAnimFrame(function() {
      this._moveStart(true, options.noMoveStart || false)._animateZoom(center, zoom2, true);
    }, this);
    return true;
  },
  _animateZoom: function(center, zoom2, startAnim, noUpdate) {
    if (!this._mapPane) {
      return;
    }
    if (startAnim) {
      this._animatingZoom = true;
      this._animateToCenter = center;
      this._animateToZoom = zoom2;
      addClass(this._mapPane, "leaflet-zoom-anim");
    }
    this.fire("zoomanim", {
      center,
      zoom: zoom2,
      noUpdate
    });
    if (!this._tempFireZoomEvent) {
      this._tempFireZoomEvent = this._zoom !== this._animateToZoom;
    }
    this._move(this._animateToCenter, this._animateToZoom, void 0, true);
    setTimeout(bind(this._onZoomTransitionEnd, this), 250);
  },
  _onZoomTransitionEnd: function() {
    if (!this._animatingZoom) {
      return;
    }
    if (this._mapPane) {
      removeClass(this._mapPane, "leaflet-zoom-anim");
    }
    this._animatingZoom = false;
    this._move(this._animateToCenter, this._animateToZoom, void 0, true);
    if (this._tempFireZoomEvent) {
      this.fire("zoom");
    }
    delete this._tempFireZoomEvent;
    this.fire("move");
    this._moveEnd(true);
  }
});

// ../node_modules/leaflet/src/control/Control.js
var Control = Class.extend({
  options: {
    position: "topright"
  },
  initialize: function(options) {
    setOptions(this, options);
  },
  getPosition: function() {
    return this.options.position;
  },
  setPosition: function(position) {
    var map = this._map;
    if (map) {
      map.removeControl(this);
    }
    this.options.position = position;
    if (map) {
      map.addControl(this);
    }
    return this;
  },
  getContainer: function() {
    return this._container;
  },
  addTo: function(map) {
    this.remove();
    this._map = map;
    var container = this._container = this.onAdd(map), pos = this.getPosition(), corner = map._controlCorners[pos];
    addClass(container, "leaflet-control");
    if (pos.indexOf("bottom") !== -1) {
      corner.insertBefore(container, corner.firstChild);
    } else {
      corner.appendChild(container);
    }
    this._map.on("unload", this.remove, this);
    return this;
  },
  remove: function() {
    if (!this._map) {
      return this;
    }
    remove(this._container);
    if (this.onRemove) {
      this.onRemove(this._map);
    }
    this._map.off("unload", this.remove, this);
    this._map = null;
    return this;
  },
  _refocusOnMap: function(e) {
    if (this._map && e && e.screenX > 0 && e.screenY > 0) {
      this._map.getContainer().focus();
    }
  }
});
Map.include({
  addControl: function(control) {
    control.addTo(this);
    return this;
  },
  removeControl: function(control) {
    control.remove();
    return this;
  },
  _initControlPos: function() {
    var corners = this._controlCorners = {}, l = "leaflet-", container = this._controlContainer = create2("div", l + "control-container", this._container);
    function createCorner(vSide, hSide) {
      var className = l + vSide + " " + l + hSide;
      corners[vSide + hSide] = create2("div", className, container);
    }
    createCorner("top", "left");
    createCorner("top", "right");
    createCorner("bottom", "left");
    createCorner("bottom", "right");
  },
  _clearControlPos: function() {
    for (var i in this._controlCorners) {
      remove(this._controlCorners[i]);
    }
    remove(this._controlContainer);
    delete this._controlCorners;
    delete this._controlContainer;
  }
});

// ../node_modules/leaflet/src/control/Control.Zoom.js
var Zoom = Control.extend({
  options: {
    position: "topleft",
    zoomInText: '<span aria-hidden="true">+</span>',
    zoomInTitle: "Zoom in",
    zoomOutText: '<span aria-hidden="true">&#x2212;</span>',
    zoomOutTitle: "Zoom out"
  },
  onAdd: function(map) {
    var zoomName = "leaflet-control-zoom", container = create2("div", zoomName + " leaflet-bar"), options = this.options;
    this._zoomInButton = this._createButton(
      options.zoomInText,
      options.zoomInTitle,
      zoomName + "-in",
      container,
      this._zoomIn
    );
    this._zoomOutButton = this._createButton(
      options.zoomOutText,
      options.zoomOutTitle,
      zoomName + "-out",
      container,
      this._zoomOut
    );
    this._updateDisabled();
    map.on("zoomend zoomlevelschange", this._updateDisabled, this);
    return container;
  },
  onRemove: function(map) {
    map.off("zoomend zoomlevelschange", this._updateDisabled, this);
  },
  disable: function() {
    this._disabled = true;
    this._updateDisabled();
    return this;
  },
  enable: function() {
    this._disabled = false;
    this._updateDisabled();
    return this;
  },
  _zoomIn: function(e) {
    if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
      this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
    }
  },
  _zoomOut: function(e) {
    if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
      this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
    }
  },
  _createButton: function(html, title, className, container, fn) {
    var link = create2("a", className, container);
    link.innerHTML = html;
    link.href = "#";
    link.title = title;
    link.setAttribute("role", "button");
    link.setAttribute("aria-label", title);
    disableClickPropagation(link);
    on(link, "click", stop);
    on(link, "click", fn, this);
    on(link, "click", this._refocusOnMap, this);
    return link;
  },
  _updateDisabled: function() {
    var map = this._map, className = "leaflet-disabled";
    removeClass(this._zoomInButton, className);
    removeClass(this._zoomOutButton, className);
    this._zoomInButton.setAttribute("aria-disabled", "false");
    this._zoomOutButton.setAttribute("aria-disabled", "false");
    if (this._disabled || map._zoom === map.getMinZoom()) {
      addClass(this._zoomOutButton, className);
      this._zoomOutButton.setAttribute("aria-disabled", "true");
    }
    if (this._disabled || map._zoom === map.getMaxZoom()) {
      addClass(this._zoomInButton, className);
      this._zoomInButton.setAttribute("aria-disabled", "true");
    }
  }
});
Map.mergeOptions({
  zoomControl: true
});
Map.addInitHook(function() {
  if (this.options.zoomControl) {
    this.zoomControl = new Zoom();
    this.addControl(this.zoomControl);
  }
});
var zoom = function(options) {
  return new Zoom(options);
};
export {
  Zoom,
  zoom
};
//# sourceMappingURL=leaflet_src_control_Control__Zoom.js.map
