// ../node_modules/leaflet/src/core/Util.js
function extend(dest) {
  var i, j, len, src;
  for (j = 1, len = arguments.length; j < len; j++) {
    src = arguments[j];
    for (i in src) {
      dest[i] = src[i];
    }
  }
  return dest;
}
var create = Object.create || function() {
  function F() {
  }
  return function(proto) {
    F.prototype = proto;
    return new F();
  };
}();
function bind(fn, obj) {
  var slice = Array.prototype.slice;
  if (fn.bind) {
    return fn.bind.apply(fn, slice.call(arguments, 1));
  }
  var args = slice.call(arguments, 2);
  return function() {
    return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
  };
}
var lastId = 0;
function stamp(obj) {
  if (!("_leaflet_id" in obj)) {
    obj["_leaflet_id"] = ++lastId;
  }
  return obj._leaflet_id;
}
function wrapNum(x, range, includeMax) {
  var max = range[1], min = range[0], d = max - min;
  return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
}
function falseFn() {
  return false;
}
function formatNum(num, precision) {
  if (precision === false) {
    return num;
  }
  var pow = Math.pow(10, precision === void 0 ? 6 : precision);
  return Math.round(num * pow) / pow;
}
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
}
function splitWords(str) {
  return trim(str).split(/\s+/);
}
function setOptions(obj, options) {
  if (!Object.prototype.hasOwnProperty.call(obj, "options")) {
    obj.options = obj.options ? create(obj.options) : {};
  }
  for (var i in options) {
    obj.options[i] = options[i];
  }
  return obj.options;
}
var isArray = Array.isArray || function(obj) {
  return Object.prototype.toString.call(obj) === "[object Array]";
};
function indexOf(array, el) {
  for (var i = 0; i < array.length; i++) {
    if (array[i] === el) {
      return i;
    }
  }
  return -1;
}
function getPrefixed(name) {
  return window["webkit" + name] || window["moz" + name] || window["ms" + name];
}
var lastTime = 0;
function timeoutDefer(fn) {
  var time = +new Date(), timeToCall = Math.max(0, 16 - (time - lastTime));
  lastTime = time + timeToCall;
  return window.setTimeout(fn, timeToCall);
}
var requestFn = window.requestAnimationFrame || getPrefixed("RequestAnimationFrame") || timeoutDefer;
var cancelFn = window.cancelAnimationFrame || getPrefixed("CancelAnimationFrame") || getPrefixed("CancelRequestAnimationFrame") || function(id) {
  window.clearTimeout(id);
};
function requestAnimFrame(fn, context, immediate) {
  if (immediate && requestFn === timeoutDefer) {
    fn.call(context);
  } else {
    return requestFn.call(window, bind(fn, context));
  }
}
function cancelAnimFrame(id) {
  if (id) {
    cancelFn.call(window, id);
  }
}

// ../node_modules/leaflet/src/geometry/Point.js
function Point(x, y, round) {
  this.x = round ? Math.round(x) : x;
  this.y = round ? Math.round(y) : y;
}
var trunc = Math.trunc || function(v) {
  return v > 0 ? Math.floor(v) : Math.ceil(v);
};
Point.prototype = {
  clone: function() {
    return new Point(this.x, this.y);
  },
  add: function(point) {
    return this.clone()._add(toPoint(point));
  },
  _add: function(point) {
    this.x += point.x;
    this.y += point.y;
    return this;
  },
  subtract: function(point) {
    return this.clone()._subtract(toPoint(point));
  },
  _subtract: function(point) {
    this.x -= point.x;
    this.y -= point.y;
    return this;
  },
  divideBy: function(num) {
    return this.clone()._divideBy(num);
  },
  _divideBy: function(num) {
    this.x /= num;
    this.y /= num;
    return this;
  },
  multiplyBy: function(num) {
    return this.clone()._multiplyBy(num);
  },
  _multiplyBy: function(num) {
    this.x *= num;
    this.y *= num;
    return this;
  },
  scaleBy: function(point) {
    return new Point(this.x * point.x, this.y * point.y);
  },
  unscaleBy: function(point) {
    return new Point(this.x / point.x, this.y / point.y);
  },
  round: function() {
    return this.clone()._round();
  },
  _round: function() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  },
  floor: function() {
    return this.clone()._floor();
  },
  _floor: function() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  },
  ceil: function() {
    return this.clone()._ceil();
  },
  _ceil: function() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  },
  trunc: function() {
    return this.clone()._trunc();
  },
  _trunc: function() {
    this.x = trunc(this.x);
    this.y = trunc(this.y);
    return this;
  },
  distanceTo: function(point) {
    point = toPoint(point);
    var x = point.x - this.x, y = point.y - this.y;
    return Math.sqrt(x * x + y * y);
  },
  equals: function(point) {
    point = toPoint(point);
    return point.x === this.x && point.y === this.y;
  },
  contains: function(point) {
    point = toPoint(point);
    return Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y);
  },
  toString: function() {
    return "Point(" + formatNum(this.x) + ", " + formatNum(this.y) + ")";
  }
};
function toPoint(x, y, round) {
  if (x instanceof Point) {
    return x;
  }
  if (isArray(x)) {
    return new Point(x[0], x[1]);
  }
  if (x === void 0 || x === null) {
    return x;
  }
  if (typeof x === "object" && "x" in x && "y" in x) {
    return new Point(x.x, x.y);
  }
  return new Point(x, y, round);
}

// ../node_modules/leaflet/src/layer/vector/SVG.Util.js
function svgCreate(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}

// ../node_modules/leaflet/src/core/Browser.js
var style = document.documentElement.style;
var ie = "ActiveXObject" in window;
var ielt9 = ie && !document.addEventListener;
var edge = "msLaunchUri" in navigator && !("documentMode" in document);
var webkit = userAgentContains("webkit");
var android = userAgentContains("android");
var android23 = userAgentContains("android 2") || userAgentContains("android 3");
var webkitVer = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10);
var androidStock = android && userAgentContains("Google") && webkitVer < 537 && !("AudioNode" in window);
var opera = !!window.opera;
var chrome = !edge && userAgentContains("chrome");
var gecko = userAgentContains("gecko") && !webkit && !opera && !ie;
var safari = !chrome && userAgentContains("safari");
var phantom = userAgentContains("phantom");
var opera12 = "OTransition" in style;
var win = navigator.platform.indexOf("Win") === 0;
var ie3d = ie && "transition" in style;
var webkit3d = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix() && !android23;
var gecko3d = "MozPerspective" in style;
var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;
var mobile = typeof orientation !== "undefined" || userAgentContains("mobile");
var mobileWebkit = mobile && webkit;
var mobileWebkit3d = mobile && webkit3d;
var msPointer = !window.PointerEvent && window.MSPointerEvent;
var pointer = !!(window.PointerEvent || msPointer);
var touchNative = "ontouchstart" in window || !!window.TouchEvent;
var touch = !window.L_NO_TOUCH && (touchNative || pointer);
var mobileOpera = mobile && opera;
var mobileGecko = mobile && gecko;
var retina = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1;
var passiveEvents = function() {
  var supportsPassiveOption = false;
  try {
    var opts = Object.defineProperty({}, "passive", {
      get: function() {
        supportsPassiveOption = true;
      }
    });
    window.addEventListener("testPassiveEventSupport", falseFn, opts);
    window.removeEventListener("testPassiveEventSupport", falseFn, opts);
  } catch (e) {
  }
  return supportsPassiveOption;
}();
var canvas = function() {
  return !!document.createElement("canvas").getContext;
}();
var svg = !!(document.createElementNS && svgCreate("svg").createSVGRect);
var inlineSvg = !!svg && function() {
  var div = document.createElement("div");
  div.innerHTML = "<svg/>";
  return (div.firstChild && div.firstChild.namespaceURI) === "http://www.w3.org/2000/svg";
}();
var vml = !svg && function() {
  try {
    var div = document.createElement("div");
    div.innerHTML = '<v:shape adj="1"/>';
    var shape = div.firstChild;
    shape.style.behavior = "url(#default#VML)";
    return shape && typeof shape.adj === "object";
  } catch (e) {
    return false;
  }
}();
var mac = navigator.platform.indexOf("Mac") === 0;
var linux = navigator.platform.indexOf("Linux") === 0;
function userAgentContains(str) {
  return navigator.userAgent.toLowerCase().indexOf(str) >= 0;
}
var Browser_default = {
  ie,
  ielt9,
  edge,
  webkit,
  android,
  android23,
  androidStock,
  opera,
  chrome,
  gecko,
  safari,
  phantom,
  opera12,
  win,
  ie3d,
  webkit3d,
  gecko3d,
  any3d,
  mobile,
  mobileWebkit,
  mobileWebkit3d,
  msPointer,
  pointer,
  touch,
  touchNative,
  mobileOpera,
  mobileGecko,
  retina,
  passiveEvents,
  canvas,
  svg,
  vml,
  inlineSvg,
  mac,
  linux
};

// ../node_modules/leaflet/src/dom/DomEvent.Pointer.js
var POINTER_DOWN = Browser_default.msPointer ? "MSPointerDown" : "pointerdown";
var POINTER_MOVE = Browser_default.msPointer ? "MSPointerMove" : "pointermove";
var POINTER_UP = Browser_default.msPointer ? "MSPointerUp" : "pointerup";
var POINTER_CANCEL = Browser_default.msPointer ? "MSPointerCancel" : "pointercancel";
var pEvent = {
  touchstart: POINTER_DOWN,
  touchmove: POINTER_MOVE,
  touchend: POINTER_UP,
  touchcancel: POINTER_CANCEL
};
var handle = {
  touchstart: _onPointerStart,
  touchmove: _handlePointer,
  touchend: _handlePointer,
  touchcancel: _handlePointer
};
var _pointers = {};
var _pointerDocListener = false;
function addPointerListener(obj, type, handler) {
  if (type === "touchstart") {
    _addPointerDocListener();
  }
  if (!handle[type]) {
    console.warn("wrong event specified:", type);
    return falseFn;
  }
  handler = handle[type].bind(this, handler);
  obj.addEventListener(pEvent[type], handler, false);
  return handler;
}
function removePointerListener(obj, type, handler) {
  if (!pEvent[type]) {
    console.warn("wrong event specified:", type);
    return;
  }
  obj.removeEventListener(pEvent[type], handler, false);
}
function _globalPointerDown(e) {
  _pointers[e.pointerId] = e;
}
function _globalPointerMove(e) {
  if (_pointers[e.pointerId]) {
    _pointers[e.pointerId] = e;
  }
}
function _globalPointerUp(e) {
  delete _pointers[e.pointerId];
}
function _addPointerDocListener() {
  if (!_pointerDocListener) {
    document.addEventListener(POINTER_DOWN, _globalPointerDown, true);
    document.addEventListener(POINTER_MOVE, _globalPointerMove, true);
    document.addEventListener(POINTER_UP, _globalPointerUp, true);
    document.addEventListener(POINTER_CANCEL, _globalPointerUp, true);
    _pointerDocListener = true;
  }
}
function _handlePointer(handler, e) {
  if (e.pointerType === (e.MSPOINTER_TYPE_MOUSE || "mouse")) {
    return;
  }
  e.touches = [];
  for (var i in _pointers) {
    e.touches.push(_pointers[i]);
  }
  e.changedTouches = [e];
  handler(e);
}
function _onPointerStart(handler, e) {
  if (e.MSPOINTER_TYPE_TOUCH && e.pointerType === e.MSPOINTER_TYPE_TOUCH) {
    preventDefault(e);
  }
  _handlePointer(handler, e);
}

// ../node_modules/leaflet/src/dom/DomEvent.DoubleTap.js
function makeDblclick(event) {
  var newEvent = {}, prop, i;
  for (i in event) {
    prop = event[i];
    newEvent[i] = prop && prop.bind ? prop.bind(event) : prop;
  }
  event = newEvent;
  newEvent.type = "dblclick";
  newEvent.detail = 2;
  newEvent.isTrusted = false;
  newEvent._simulated = true;
  return newEvent;
}
var delay = 200;
function addDoubleTapListener(obj, handler) {
  obj.addEventListener("dblclick", handler);
  var last = 0, detail;
  function simDblclick(e) {
    if (e.detail !== 1) {
      detail = e.detail;
      return;
    }
    if (e.pointerType === "mouse" || e.sourceCapabilities && !e.sourceCapabilities.firesTouchEvents) {
      return;
    }
    var path = getPropagationPath(e);
    if (path.some(function(el) {
      return el instanceof HTMLLabelElement && el.attributes.for;
    }) && !path.some(function(el) {
      return el instanceof HTMLInputElement || el instanceof HTMLSelectElement;
    })) {
      return;
    }
    var now = Date.now();
    if (now - last <= delay) {
      detail++;
      if (detail === 2) {
        handler(makeDblclick(e));
      }
    } else {
      detail = 1;
    }
    last = now;
  }
  obj.addEventListener("click", simDblclick);
  return {
    dblclick: handler,
    simDblclick
  };
}
function removeDoubleTapListener(obj, handlers) {
  obj.removeEventListener("dblclick", handlers.dblclick);
  obj.removeEventListener("click", handlers.simDblclick);
}

// ../node_modules/leaflet/src/dom/DomEvent.js
function on(obj, types, fn, context) {
  if (types && typeof types === "object") {
    for (var type in types) {
      addOne(obj, type, types[type], fn);
    }
  } else {
    types = splitWords(types);
    for (var i = 0, len = types.length; i < len; i++) {
      addOne(obj, types[i], fn, context);
    }
  }
  return this;
}
var eventsKey = "_leaflet_events";
function off(obj, types, fn, context) {
  if (arguments.length === 1) {
    batchRemove(obj);
    delete obj[eventsKey];
  } else if (types && typeof types === "object") {
    for (var type in types) {
      removeOne(obj, type, types[type], fn);
    }
  } else {
    types = splitWords(types);
    if (arguments.length === 2) {
      batchRemove(obj, function(type2) {
        return indexOf(types, type2) !== -1;
      });
    } else {
      for (var i = 0, len = types.length; i < len; i++) {
        removeOne(obj, types[i], fn, context);
      }
    }
  }
  return this;
}
function batchRemove(obj, filterFn) {
  for (var id in obj[eventsKey]) {
    var type = id.split(/\d/)[0];
    if (!filterFn || filterFn(type)) {
      removeOne(obj, type, null, null, id);
    }
  }
}
var mouseSubst = {
  mouseenter: "mouseover",
  mouseleave: "mouseout",
  wheel: !("onwheel" in window) && "mousewheel"
};
function addOne(obj, type, fn, context) {
  var id = type + stamp(fn) + (context ? "_" + stamp(context) : "");
  if (obj[eventsKey] && obj[eventsKey][id]) {
    return this;
  }
  var handler = function(e) {
    return fn.call(context || obj, e || window.event);
  };
  var originalHandler = handler;
  if (!Browser_default.touchNative && Browser_default.pointer && type.indexOf("touch") === 0) {
    handler = addPointerListener(obj, type, handler);
  } else if (Browser_default.touch && type === "dblclick") {
    handler = addDoubleTapListener(obj, handler);
  } else if ("addEventListener" in obj) {
    if (type === "touchstart" || type === "touchmove" || type === "wheel" || type === "mousewheel") {
      obj.addEventListener(mouseSubst[type] || type, handler, Browser_default.passiveEvents ? { passive: false } : false);
    } else if (type === "mouseenter" || type === "mouseleave") {
      handler = function(e) {
        e = e || window.event;
        if (isExternalTarget(obj, e)) {
          originalHandler(e);
        }
      };
      obj.addEventListener(mouseSubst[type], handler, false);
    } else {
      obj.addEventListener(type, originalHandler, false);
    }
  } else {
    obj.attachEvent("on" + type, handler);
  }
  obj[eventsKey] = obj[eventsKey] || {};
  obj[eventsKey][id] = handler;
}
function removeOne(obj, type, fn, context, id) {
  id = id || type + stamp(fn) + (context ? "_" + stamp(context) : "");
  var handler = obj[eventsKey] && obj[eventsKey][id];
  if (!handler) {
    return this;
  }
  if (!Browser_default.touchNative && Browser_default.pointer && type.indexOf("touch") === 0) {
    removePointerListener(obj, type, handler);
  } else if (Browser_default.touch && type === "dblclick") {
    removeDoubleTapListener(obj, handler);
  } else if ("removeEventListener" in obj) {
    obj.removeEventListener(mouseSubst[type] || type, handler, false);
  } else {
    obj.detachEvent("on" + type, handler);
  }
  obj[eventsKey][id] = null;
}
function stopPropagation(e) {
  if (e.stopPropagation) {
    e.stopPropagation();
  } else if (e.originalEvent) {
    e.originalEvent._stopped = true;
  } else {
    e.cancelBubble = true;
  }
  return this;
}
function disableClickPropagation(el) {
  on(el, "mousedown touchstart dblclick contextmenu", stopPropagation);
  el["_leaflet_disable_click"] = true;
  return this;
}
function preventDefault(e) {
  if (e.preventDefault) {
    e.preventDefault();
  } else {
    e.returnValue = false;
  }
  return this;
}
function stop(e) {
  preventDefault(e);
  stopPropagation(e);
  return this;
}
function getPropagationPath(ev) {
  if (ev.composedPath) {
    return ev.composedPath();
  }
  var path = [];
  var el = ev.target;
  while (el) {
    path.push(el);
    el = el.parentNode;
  }
  return path;
}
function getMousePosition(e, container) {
  if (!container) {
    return new Point(e.clientX, e.clientY);
  }
  var scale = getScale(container), offset = scale.boundingClientRect;
  return new Point(
    (e.clientX - offset.left) / scale.x - container.clientLeft,
    (e.clientY - offset.top) / scale.y - container.clientTop
  );
}
var wheelPxFactor = Browser_default.linux && Browser_default.chrome ? window.devicePixelRatio : Browser_default.mac ? window.devicePixelRatio * 3 : window.devicePixelRatio > 0 ? 2 * window.devicePixelRatio : 1;
function isExternalTarget(el, e) {
  var related = e.relatedTarget;
  if (!related) {
    return true;
  }
  try {
    while (related && related !== el) {
      related = related.parentNode;
    }
  } catch (err) {
    return false;
  }
  return related !== el;
}

// ../node_modules/leaflet/src/dom/DomUtil.js
var TRANSFORM = testProp(
  ["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]
);
var TRANSITION = testProp(
  ["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]
);
var TRANSITION_END = TRANSITION === "webkitTransition" || TRANSITION === "OTransition" ? TRANSITION + "End" : "transitionend";
function get(id) {
  return typeof id === "string" ? document.getElementById(id) : id;
}
function getStyle(el, style2) {
  var value = el.style[style2] || el.currentStyle && el.currentStyle[style2];
  if ((!value || value === "auto") && document.defaultView) {
    var css = document.defaultView.getComputedStyle(el, null);
    value = css ? css[style2] : null;
  }
  return value === "auto" ? null : value;
}
function create2(tagName, className, container) {
  var el = document.createElement(tagName);
  el.className = className || "";
  if (container) {
    container.appendChild(el);
  }
  return el;
}
function remove(el) {
  var parent = el.parentNode;
  if (parent) {
    parent.removeChild(el);
  }
}
function empty(el) {
  while (el.firstChild) {
    el.removeChild(el.firstChild);
  }
}
function toFront(el) {
  var parent = el.parentNode;
  if (parent && parent.lastChild !== el) {
    parent.appendChild(el);
  }
}
function toBack(el) {
  var parent = el.parentNode;
  if (parent && parent.firstChild !== el) {
    parent.insertBefore(el, parent.firstChild);
  }
}
function hasClass(el, name) {
  if (el.classList !== void 0) {
    return el.classList.contains(name);
  }
  var className = getClass(el);
  return className.length > 0 && new RegExp("(^|\\s)" + name + "(\\s|$)").test(className);
}
function addClass(el, name) {
  if (el.classList !== void 0) {
    var classes = splitWords(name);
    for (var i = 0, len = classes.length; i < len; i++) {
      el.classList.add(classes[i]);
    }
  } else if (!hasClass(el, name)) {
    var className = getClass(el);
    setClass(el, (className ? className + " " : "") + name);
  }
}
function removeClass(el, name) {
  if (el.classList !== void 0) {
    el.classList.remove(name);
  } else {
    setClass(el, trim((" " + getClass(el) + " ").replace(" " + name + " ", " ")));
  }
}
function setClass(el, name) {
  if (el.className.baseVal === void 0) {
    el.className = name;
  } else {
    el.className.baseVal = name;
  }
}
function getClass(el) {
  if (el.correspondingElement) {
    el = el.correspondingElement;
  }
  return el.className.baseVal === void 0 ? el.className : el.className.baseVal;
}
function setOpacity(el, value) {
  if ("opacity" in el.style) {
    el.style.opacity = value;
  } else if ("filter" in el.style) {
    _setOpacityIE(el, value);
  }
}
function _setOpacityIE(el, value) {
  var filter = false, filterName = "DXImageTransform.Microsoft.Alpha";
  try {
    filter = el.filters.item(filterName);
  } catch (e) {
    if (value === 1) {
      return;
    }
  }
  value = Math.round(value * 100);
  if (filter) {
    filter.Enabled = value !== 100;
    filter.Opacity = value;
  } else {
    el.style.filter += " progid:" + filterName + "(opacity=" + value + ")";
  }
}
function testProp(props) {
  var style2 = document.documentElement.style;
  for (var i = 0; i < props.length; i++) {
    if (props[i] in style2) {
      return props[i];
    }
  }
  return false;
}
function setTransform(el, offset, scale) {
  var pos = offset || new Point(0, 0);
  el.style[TRANSFORM] = (Browser_default.ie3d ? "translate(" + pos.x + "px," + pos.y + "px)" : "translate3d(" + pos.x + "px," + pos.y + "px,0)") + (scale ? " scale(" + scale + ")" : "");
}
function setPosition(el, point) {
  el._leaflet_pos = point;
  if (Browser_default.any3d) {
    setTransform(el, point);
  } else {
    el.style.left = point.x + "px";
    el.style.top = point.y + "px";
  }
}
function getPosition(el) {
  return el._leaflet_pos || new Point(0, 0);
}
var disableTextSelection;
var enableTextSelection;
var _userSelect;
if ("onselectstart" in document) {
  disableTextSelection = function() {
    on(window, "selectstart", preventDefault);
  };
  enableTextSelection = function() {
    off(window, "selectstart", preventDefault);
  };
} else {
  userSelectProperty = testProp(
    ["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]
  );
  disableTextSelection = function() {
    if (userSelectProperty) {
      var style2 = document.documentElement.style;
      _userSelect = style2[userSelectProperty];
      style2[userSelectProperty] = "none";
    }
  };
  enableTextSelection = function() {
    if (userSelectProperty) {
      document.documentElement.style[userSelectProperty] = _userSelect;
      _userSelect = void 0;
    }
  };
}
var userSelectProperty;
function disableImageDrag() {
  on(window, "dragstart", preventDefault);
}
function enableImageDrag() {
  off(window, "dragstart", preventDefault);
}
var _outlineElement;
var _outlineStyle;
function preventOutline(element) {
  while (element.tabIndex === -1) {
    element = element.parentNode;
  }
  if (!element.style) {
    return;
  }
  restoreOutline();
  _outlineElement = element;
  _outlineStyle = element.style.outlineStyle;
  element.style.outlineStyle = "none";
  on(window, "keydown", restoreOutline);
}
function restoreOutline() {
  if (!_outlineElement) {
    return;
  }
  _outlineElement.style.outlineStyle = _outlineStyle;
  _outlineElement = void 0;
  _outlineStyle = void 0;
  off(window, "keydown", restoreOutline);
}
function getSizedParentNode(element) {
  do {
    element = element.parentNode;
  } while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);
  return element;
}
function getScale(element) {
  var rect = element.getBoundingClientRect();
  return {
    x: rect.width / element.offsetWidth || 1,
    y: rect.height / element.offsetHeight || 1,
    boundingClientRect: rect
  };
}

export {
  extend,
  create,
  bind,
  stamp,
  wrapNum,
  falseFn,
  formatNum,
  splitWords,
  setOptions,
  isArray,
  indexOf,
  requestAnimFrame,
  cancelAnimFrame,
  Point,
  toPoint,
  Browser_default,
  on,
  off,
  disableClickPropagation,
  preventDefault,
  stop,
  getMousePosition,
  isExternalTarget,
  TRANSFORM,
  TRANSITION,
  TRANSITION_END,
  get,
  getStyle,
  create2,
  remove,
  empty,
  toFront,
  toBack,
  hasClass,
  addClass,
  removeClass,
  setClass,
  getClass,
  setOpacity,
  testProp,
  setTransform,
  setPosition,
  getPosition,
  disableTextSelection,
  enableTextSelection,
  disableImageDrag,
  enableImageDrag,
  preventOutline,
  restoreOutline,
  getSizedParentNode,
  getScale
};
//# sourceMappingURL=chunk-ZIY7C4EG.js.map
