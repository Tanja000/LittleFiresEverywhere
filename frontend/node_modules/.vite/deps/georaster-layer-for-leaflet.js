import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-J43GMYXM.js";

// node_modules/regenerator-runtime/runtime.js
var require_runtime = __commonJS({
  "node_modules/regenerator-runtime/runtime.js"(exports4, module) {
    var runtime = function(exports5) {
      "use strict";
      var Op = Object.prototype;
      var hasOwn = Op.hasOwnProperty;
      var defineProperty = Object.defineProperty || function(obj2, key, desc) {
        obj2[key] = desc.value;
      };
      var undefined2;
      var $Symbol = typeof Symbol === "function" ? Symbol : {};
      var iteratorSymbol = $Symbol.iterator || "@@iterator";
      var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
      var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
      function define2(obj2, key, value) {
        Object.defineProperty(obj2, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
        return obj2[key];
      }
      try {
        define2({}, "");
      } catch (err) {
        define2 = function(obj2, key, value) {
          return obj2[key] = value;
        };
      }
      function wrap(innerFn, outerFn, self2, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
        var generator = Object.create(protoGenerator.prototype);
        var context = new Context(tryLocsList || []);
        defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self2, context) });
        return generator;
      }
      exports5.wrap = wrap;
      function tryCatch(fn, obj2, arg) {
        try {
          return { type: "normal", arg: fn.call(obj2, arg) };
        } catch (err) {
          return { type: "throw", arg: err };
        }
      }
      var GenStateSuspendedStart = "suspendedStart";
      var GenStateSuspendedYield = "suspendedYield";
      var GenStateExecuting = "executing";
      var GenStateCompleted = "completed";
      var ContinueSentinel = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var IteratorPrototype = {};
      define2(IteratorPrototype, iteratorSymbol, function() {
        return this;
      });
      var getProto = Object.getPrototypeOf;
      var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
      if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
        IteratorPrototype = NativeIteratorPrototype;
      }
      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      GeneratorFunction.prototype = GeneratorFunctionPrototype;
      defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: true });
      defineProperty(
        GeneratorFunctionPrototype,
        "constructor",
        { value: GeneratorFunction, configurable: true }
      );
      GeneratorFunction.displayName = define2(
        GeneratorFunctionPrototype,
        toStringTagSymbol,
        "GeneratorFunction"
      );
      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function(method) {
          define2(prototype, method, function(arg) {
            return this._invoke(method, arg);
          });
        });
      }
      exports5.isGeneratorFunction = function(genFun) {
        var ctor = typeof genFun === "function" && genFun.constructor;
        return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
      };
      exports5.mark = function(genFun) {
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
        } else {
          genFun.__proto__ = GeneratorFunctionPrototype;
          define2(genFun, toStringTagSymbol, "GeneratorFunction");
        }
        genFun.prototype = Object.create(Gp);
        return genFun;
      };
      exports5.awrap = function(arg) {
        return { __await: arg };
      };
      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
          var record = tryCatch(generator[method], generator, arg);
          if (record.type === "throw") {
            reject(record.arg);
          } else {
            var result2 = record.arg;
            var value = result2.value;
            if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
              return PromiseImpl.resolve(value.__await).then(function(value2) {
                invoke("next", value2, resolve, reject);
              }, function(err) {
                invoke("throw", err, resolve, reject);
              });
            }
            return PromiseImpl.resolve(value).then(function(unwrapped) {
              result2.value = unwrapped;
              resolve(result2);
            }, function(error) {
              return invoke("throw", error, resolve, reject);
            });
          }
        }
        var previousPromise;
        function enqueue(method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function(resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }
          return previousPromise = previousPromise ? previousPromise.then(
            callInvokeWithMethodAndArg,
            callInvokeWithMethodAndArg
          ) : callInvokeWithMethodAndArg();
        }
        defineProperty(this, "_invoke", { value: enqueue });
      }
      defineIteratorMethods(AsyncIterator.prototype);
      define2(AsyncIterator.prototype, asyncIteratorSymbol, function() {
        return this;
      });
      exports5.AsyncIterator = AsyncIterator;
      exports5.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
        if (PromiseImpl === void 0)
          PromiseImpl = Promise;
        var iter = new AsyncIterator(
          wrap(innerFn, outerFn, self2, tryLocsList),
          PromiseImpl
        );
        return exports5.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result2) {
          return result2.done ? result2.value : iter.next();
        });
      };
      function makeInvokeMethod(innerFn, self2, context) {
        var state = GenStateSuspendedStart;
        return function invoke(method, arg) {
          if (state === GenStateExecuting) {
            throw new Error("Generator is already running");
          }
          if (state === GenStateCompleted) {
            if (method === "throw") {
              throw arg;
            }
            return doneResult();
          }
          context.method = method;
          context.arg = arg;
          while (true) {
            var delegate = context.delegate;
            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);
              if (delegateResult) {
                if (delegateResult === ContinueSentinel)
                  continue;
                return delegateResult;
              }
            }
            if (context.method === "next") {
              context.sent = context._sent = context.arg;
            } else if (context.method === "throw") {
              if (state === GenStateSuspendedStart) {
                state = GenStateCompleted;
                throw context.arg;
              }
              context.dispatchException(context.arg);
            } else if (context.method === "return") {
              context.abrupt("return", context.arg);
            }
            state = GenStateExecuting;
            var record = tryCatch(innerFn, self2, context);
            if (record.type === "normal") {
              state = context.done ? GenStateCompleted : GenStateSuspendedYield;
              if (record.arg === ContinueSentinel) {
                continue;
              }
              return {
                value: record.arg,
                done: context.done
              };
            } else if (record.type === "throw") {
              state = GenStateCompleted;
              context.method = "throw";
              context.arg = record.arg;
            }
          }
        };
      }
      function maybeInvokeDelegate(delegate, context) {
        var methodName = context.method;
        var method = delegate.iterator[methodName];
        if (method === undefined2) {
          context.delegate = null;
          if (methodName === "throw" && delegate.iterator["return"]) {
            context.method = "return";
            context.arg = undefined2;
            maybeInvokeDelegate(delegate, context);
            if (context.method === "throw") {
              return ContinueSentinel;
            }
          }
          if (methodName !== "return") {
            context.method = "throw";
            context.arg = new TypeError(
              "The iterator does not provide a '" + methodName + "' method"
            );
          }
          return ContinueSentinel;
        }
        var record = tryCatch(method, delegate.iterator, context.arg);
        if (record.type === "throw") {
          context.method = "throw";
          context.arg = record.arg;
          context.delegate = null;
          return ContinueSentinel;
        }
        var info = record.arg;
        if (!info) {
          context.method = "throw";
          context.arg = new TypeError("iterator result is not an object");
          context.delegate = null;
          return ContinueSentinel;
        }
        if (info.done) {
          context[delegate.resultName] = info.value;
          context.next = delegate.nextLoc;
          if (context.method !== "return") {
            context.method = "next";
            context.arg = undefined2;
          }
        } else {
          return info;
        }
        context.delegate = null;
        return ContinueSentinel;
      }
      defineIteratorMethods(Gp);
      define2(Gp, toStringTagSymbol, "Generator");
      define2(Gp, iteratorSymbol, function() {
        return this;
      });
      define2(Gp, "toString", function() {
        return "[object Generator]";
      });
      function pushTryEntry(locs) {
        var entry = { tryLoc: locs[0] };
        if (1 in locs) {
          entry.catchLoc = locs[1];
        }
        if (2 in locs) {
          entry.finallyLoc = locs[2];
          entry.afterLoc = locs[3];
        }
        this.tryEntries.push(entry);
      }
      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal";
        delete record.arg;
        entry.completion = record;
      }
      function Context(tryLocsList) {
        this.tryEntries = [{ tryLoc: "root" }];
        tryLocsList.forEach(pushTryEntry, this);
        this.reset(true);
      }
      exports5.keys = function(val) {
        var object = Object(val);
        var keys = [];
        for (var key in object) {
          keys.push(key);
        }
        keys.reverse();
        return function next() {
          while (keys.length) {
            var key2 = keys.pop();
            if (key2 in object) {
              next.value = key2;
              next.done = false;
              return next;
            }
          }
          next.done = true;
          return next;
        };
      };
      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod) {
            return iteratorMethod.call(iterable);
          }
          if (typeof iterable.next === "function") {
            return iterable;
          }
          if (!isNaN(iterable.length)) {
            var i = -1, next = function next2() {
              while (++i < iterable.length) {
                if (hasOwn.call(iterable, i)) {
                  next2.value = iterable[i];
                  next2.done = false;
                  return next2;
                }
              }
              next2.value = undefined2;
              next2.done = true;
              return next2;
            };
            return next.next = next;
          }
        }
        return { next: doneResult };
      }
      exports5.values = values;
      function doneResult() {
        return { value: undefined2, done: true };
      }
      Context.prototype = {
        constructor: Context,
        reset: function(skipTempReset) {
          this.prev = 0;
          this.next = 0;
          this.sent = this._sent = undefined2;
          this.done = false;
          this.delegate = null;
          this.method = "next";
          this.arg = undefined2;
          this.tryEntries.forEach(resetTryEntry);
          if (!skipTempReset) {
            for (var name in this) {
              if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                this[name] = undefined2;
              }
            }
          }
        },
        stop: function() {
          this.done = true;
          var rootEntry = this.tryEntries[0];
          var rootRecord = rootEntry.completion;
          if (rootRecord.type === "throw") {
            throw rootRecord.arg;
          }
          return this.rval;
        },
        dispatchException: function(exception) {
          if (this.done) {
            throw exception;
          }
          var context = this;
          function handle(loc, caught) {
            record.type = "throw";
            record.arg = exception;
            context.next = loc;
            if (caught) {
              context.method = "next";
              context.arg = undefined2;
            }
            return !!caught;
          }
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            var record = entry.completion;
            if (entry.tryLoc === "root") {
              return handle("end");
            }
            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc");
              var hasFinally = hasOwn.call(entry, "finallyLoc");
              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                } else if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                }
              } else if (hasFinally) {
                if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else {
                throw new Error("try statement without catch or finally");
              }
            }
          }
        },
        abrupt: function(type, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }
          if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
            finallyEntry = null;
          }
          var record = finallyEntry ? finallyEntry.completion : {};
          record.type = type;
          record.arg = arg;
          if (finallyEntry) {
            this.method = "next";
            this.next = finallyEntry.finallyLoc;
            return ContinueSentinel;
          }
          return this.complete(record);
        },
        complete: function(record, afterLoc) {
          if (record.type === "throw") {
            throw record.arg;
          }
          if (record.type === "break" || record.type === "continue") {
            this.next = record.arg;
          } else if (record.type === "return") {
            this.rval = this.arg = record.arg;
            this.method = "return";
            this.next = "end";
          } else if (record.type === "normal" && afterLoc) {
            this.next = afterLoc;
          }
          return ContinueSentinel;
        },
        finish: function(finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.finallyLoc === finallyLoc) {
              this.complete(entry.completion, entry.afterLoc);
              resetTryEntry(entry);
              return ContinueSentinel;
            }
          }
        },
        "catch": function(tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;
              if (record.type === "throw") {
                var thrown = record.arg;
                resetTryEntry(entry);
              }
              return thrown;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function(iterable, resultName, nextLoc) {
          this.delegate = {
            iterator: values(iterable),
            resultName,
            nextLoc
          };
          if (this.method === "next") {
            this.arg = undefined2;
          }
          return ContinueSentinel;
        }
      };
      return exports5;
    }(
      typeof module === "object" ? module.exports : {}
    );
    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      if (typeof globalThis === "object") {
        globalThis.regeneratorRuntime = runtime;
      } else {
        Function("r", "regeneratorRuntime = r")(runtime);
      }
    }
  }
});

// ../node_modules/leaflet/dist/leaflet-src.js
var require_leaflet_src = __commonJS({
  "../node_modules/leaflet/dist/leaflet-src.js"(exports4, module) {
    (function(global, factory) {
      typeof exports4 === "object" && typeof module !== "undefined" ? factory(exports4) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.leaflet = {}));
    })(exports4, function(exports5) {
      "use strict";
      var version = "1.9.4";
      function extend(dest) {
        var i, j, len, src;
        for (j = 1, len = arguments.length; j < len; j++) {
          src = arguments[j];
          for (i in src) {
            dest[i] = src[i];
          }
        }
        return dest;
      }
      var create$2 = Object.create || function() {
        function F() {
        }
        return function(proto) {
          F.prototype = proto;
          return new F();
        };
      }();
      function bind(fn, obj2) {
        var slice = Array.prototype.slice;
        if (fn.bind) {
          return fn.bind.apply(fn, slice.call(arguments, 1));
        }
        var args = slice.call(arguments, 2);
        return function() {
          return fn.apply(obj2, args.length ? args.concat(slice.call(arguments)) : arguments);
        };
      }
      var lastId = 0;
      function stamp(obj2) {
        if (!("_leaflet_id" in obj2)) {
          obj2["_leaflet_id"] = ++lastId;
        }
        return obj2._leaflet_id;
      }
      function throttle(fn, time, context) {
        var lock, args, wrapperFn, later;
        later = function() {
          lock = false;
          if (args) {
            wrapperFn.apply(context, args);
            args = false;
          }
        };
        wrapperFn = function() {
          if (lock) {
            args = arguments;
          } else {
            fn.apply(context, arguments);
            setTimeout(later, time);
            lock = true;
          }
        };
        return wrapperFn;
      }
      function wrapNum(x, range2, includeMax) {
        var max = range2[1], min = range2[0], d = max - min;
        return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
      }
      function falseFn() {
        return false;
      }
      function formatNum(num, precision) {
        if (precision === false) {
          return num;
        }
        var pow = Math.pow(10, precision === void 0 ? 6 : precision);
        return Math.round(num * pow) / pow;
      }
      function trim(str) {
        return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
      }
      function splitWords(str) {
        return trim(str).split(/\s+/);
      }
      function setOptions(obj2, options) {
        if (!Object.prototype.hasOwnProperty.call(obj2, "options")) {
          obj2.options = obj2.options ? create$2(obj2.options) : {};
        }
        for (var i in options) {
          obj2.options[i] = options[i];
        }
        return obj2.options;
      }
      function getParamString(obj2, existingUrl, uppercase) {
        var params2 = [];
        for (var i in obj2) {
          params2.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + "=" + encodeURIComponent(obj2[i]));
        }
        return (!existingUrl || existingUrl.indexOf("?") === -1 ? "?" : "&") + params2.join("&");
      }
      var templateRe = /\{ *([\w_ -]+) *\}/g;
      function template(str, data) {
        return str.replace(templateRe, function(str2, key) {
          var value = data[key];
          if (value === void 0) {
            throw new Error("No value provided for variable " + str2);
          } else if (typeof value === "function") {
            value = value(data);
          }
          return value;
        });
      }
      var isArray = Array.isArray || function(obj2) {
        return Object.prototype.toString.call(obj2) === "[object Array]";
      };
      function indexOf(array, el) {
        for (var i = 0; i < array.length; i++) {
          if (array[i] === el) {
            return i;
          }
        }
        return -1;
      }
      var emptyImageUrl = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";
      function getPrefixed(name) {
        return window["webkit" + name] || window["moz" + name] || window["ms" + name];
      }
      var lastTime = 0;
      function timeoutDefer(fn) {
        var time = +new Date(), timeToCall = Math.max(0, 16 - (time - lastTime));
        lastTime = time + timeToCall;
        return window.setTimeout(fn, timeToCall);
      }
      var requestFn = window.requestAnimationFrame || getPrefixed("RequestAnimationFrame") || timeoutDefer;
      var cancelFn = window.cancelAnimationFrame || getPrefixed("CancelAnimationFrame") || getPrefixed("CancelRequestAnimationFrame") || function(id) {
        window.clearTimeout(id);
      };
      function requestAnimFrame(fn, context, immediate) {
        if (immediate && requestFn === timeoutDefer) {
          fn.call(context);
        } else {
          return requestFn.call(window, bind(fn, context));
        }
      }
      function cancelAnimFrame(id) {
        if (id) {
          cancelFn.call(window, id);
        }
      }
      var Util2 = {
        __proto__: null,
        extend,
        create: create$2,
        bind,
        get lastId() {
          return lastId;
        },
        stamp,
        throttle,
        wrapNum,
        falseFn,
        formatNum,
        trim,
        splitWords,
        setOptions,
        getParamString,
        template,
        isArray,
        indexOf,
        emptyImageUrl,
        requestFn,
        cancelFn,
        requestAnimFrame,
        cancelAnimFrame
      };
      function Class() {
      }
      Class.extend = function(props) {
        var NewClass = function() {
          setOptions(this);
          if (this.initialize) {
            this.initialize.apply(this, arguments);
          }
          this.callInitHooks();
        };
        var parentProto = NewClass.__super__ = this.prototype;
        var proto = create$2(parentProto);
        proto.constructor = NewClass;
        NewClass.prototype = proto;
        for (var i in this) {
          if (Object.prototype.hasOwnProperty.call(this, i) && i !== "prototype" && i !== "__super__") {
            NewClass[i] = this[i];
          }
        }
        if (props.statics) {
          extend(NewClass, props.statics);
        }
        if (props.includes) {
          checkDeprecatedMixinEvents(props.includes);
          extend.apply(null, [proto].concat(props.includes));
        }
        extend(proto, props);
        delete proto.statics;
        delete proto.includes;
        if (proto.options) {
          proto.options = parentProto.options ? create$2(parentProto.options) : {};
          extend(proto.options, props.options);
        }
        proto._initHooks = [];
        proto.callInitHooks = function() {
          if (this._initHooksCalled) {
            return;
          }
          if (parentProto.callInitHooks) {
            parentProto.callInitHooks.call(this);
          }
          this._initHooksCalled = true;
          for (var i2 = 0, len = proto._initHooks.length; i2 < len; i2++) {
            proto._initHooks[i2].call(this);
          }
        };
        return NewClass;
      };
      Class.include = function(props) {
        var parentOptions = this.prototype.options;
        extend(this.prototype, props);
        if (props.options) {
          this.prototype.options = parentOptions;
          this.mergeOptions(props.options);
        }
        return this;
      };
      Class.mergeOptions = function(options) {
        extend(this.prototype.options, options);
        return this;
      };
      Class.addInitHook = function(fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        var init33 = typeof fn === "function" ? fn : function() {
          this[fn].apply(this, args);
        };
        this.prototype._initHooks = this.prototype._initHooks || [];
        this.prototype._initHooks.push(init33);
        return this;
      };
      function checkDeprecatedMixinEvents(includes) {
        if (typeof L === "undefined" || !L || !L.Mixin) {
          return;
        }
        includes = isArray(includes) ? includes : [includes];
        for (var i = 0; i < includes.length; i++) {
          if (includes[i] === L.Mixin.Events) {
            console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.", new Error().stack);
          }
        }
      }
      var Events = {
        on: function(types, fn, context) {
          if (typeof types === "object") {
            for (var type in types) {
              this._on(type, types[type], fn);
            }
          } else {
            types = splitWords(types);
            for (var i = 0, len = types.length; i < len; i++) {
              this._on(types[i], fn, context);
            }
          }
          return this;
        },
        off: function(types, fn, context) {
          if (!arguments.length) {
            delete this._events;
          } else if (typeof types === "object") {
            for (var type in types) {
              this._off(type, types[type], fn);
            }
          } else {
            types = splitWords(types);
            var removeAll = arguments.length === 1;
            for (var i = 0, len = types.length; i < len; i++) {
              if (removeAll) {
                this._off(types[i]);
              } else {
                this._off(types[i], fn, context);
              }
            }
          }
          return this;
        },
        _on: function(type, fn, context, _once) {
          if (typeof fn !== "function") {
            console.warn("wrong listener type: " + typeof fn);
            return;
          }
          if (this._listens(type, fn, context) !== false) {
            return;
          }
          if (context === this) {
            context = void 0;
          }
          var newListener = { fn, ctx: context };
          if (_once) {
            newListener.once = true;
          }
          this._events = this._events || {};
          this._events[type] = this._events[type] || [];
          this._events[type].push(newListener);
        },
        _off: function(type, fn, context) {
          var listeners, i, len;
          if (!this._events) {
            return;
          }
          listeners = this._events[type];
          if (!listeners) {
            return;
          }
          if (arguments.length === 1) {
            if (this._firingCount) {
              for (i = 0, len = listeners.length; i < len; i++) {
                listeners[i].fn = falseFn;
              }
            }
            delete this._events[type];
            return;
          }
          if (typeof fn !== "function") {
            console.warn("wrong listener type: " + typeof fn);
            return;
          }
          var index2 = this._listens(type, fn, context);
          if (index2 !== false) {
            var listener = listeners[index2];
            if (this._firingCount) {
              listener.fn = falseFn;
              this._events[type] = listeners = listeners.slice();
            }
            listeners.splice(index2, 1);
          }
        },
        fire: function(type, data, propagate) {
          if (!this.listens(type, propagate)) {
            return this;
          }
          var event = extend({}, data, {
            type,
            target: this,
            sourceTarget: data && data.sourceTarget || this
          });
          if (this._events) {
            var listeners = this._events[type];
            if (listeners) {
              this._firingCount = this._firingCount + 1 || 1;
              for (var i = 0, len = listeners.length; i < len; i++) {
                var l = listeners[i];
                var fn = l.fn;
                if (l.once) {
                  this.off(type, fn, l.ctx);
                }
                fn.call(l.ctx || this, event);
              }
              this._firingCount--;
            }
          }
          if (propagate) {
            this._propagateEvent(event);
          }
          return this;
        },
        listens: function(type, fn, context, propagate) {
          if (typeof type !== "string") {
            console.warn('"string" type argument expected');
          }
          var _fn = fn;
          if (typeof fn !== "function") {
            propagate = !!fn;
            _fn = void 0;
            context = void 0;
          }
          var listeners = this._events && this._events[type];
          if (listeners && listeners.length) {
            if (this._listens(type, _fn, context) !== false) {
              return true;
            }
          }
          if (propagate) {
            for (var id in this._eventParents) {
              if (this._eventParents[id].listens(type, fn, context, propagate)) {
                return true;
              }
            }
          }
          return false;
        },
        _listens: function(type, fn, context) {
          if (!this._events) {
            return false;
          }
          var listeners = this._events[type] || [];
          if (!fn) {
            return !!listeners.length;
          }
          if (context === this) {
            context = void 0;
          }
          for (var i = 0, len = listeners.length; i < len; i++) {
            if (listeners[i].fn === fn && listeners[i].ctx === context) {
              return i;
            }
          }
          return false;
        },
        once: function(types, fn, context) {
          if (typeof types === "object") {
            for (var type in types) {
              this._on(type, types[type], fn, true);
            }
          } else {
            types = splitWords(types);
            for (var i = 0, len = types.length; i < len; i++) {
              this._on(types[i], fn, context, true);
            }
          }
          return this;
        },
        addEventParent: function(obj2) {
          this._eventParents = this._eventParents || {};
          this._eventParents[stamp(obj2)] = obj2;
          return this;
        },
        removeEventParent: function(obj2) {
          if (this._eventParents) {
            delete this._eventParents[stamp(obj2)];
          }
          return this;
        },
        _propagateEvent: function(e) {
          for (var id in this._eventParents) {
            this._eventParents[id].fire(e.type, extend({
              layer: e.target,
              propagatedFrom: e.target
            }, e), true);
          }
        }
      };
      Events.addEventListener = Events.on;
      Events.removeEventListener = Events.clearAllEventListeners = Events.off;
      Events.addOneTimeEventListener = Events.once;
      Events.fireEvent = Events.fire;
      Events.hasEventListeners = Events.listens;
      var Evented = Class.extend(Events);
      function Point2(x, y, round) {
        this.x = round ? Math.round(x) : x;
        this.y = round ? Math.round(y) : y;
      }
      var trunc = Math.trunc || function(v) {
        return v > 0 ? Math.floor(v) : Math.ceil(v);
      };
      Point2.prototype = {
        clone: function() {
          return new Point2(this.x, this.y);
        },
        add: function(point3) {
          return this.clone()._add(toPoint2(point3));
        },
        _add: function(point3) {
          this.x += point3.x;
          this.y += point3.y;
          return this;
        },
        subtract: function(point3) {
          return this.clone()._subtract(toPoint2(point3));
        },
        _subtract: function(point3) {
          this.x -= point3.x;
          this.y -= point3.y;
          return this;
        },
        divideBy: function(num) {
          return this.clone()._divideBy(num);
        },
        _divideBy: function(num) {
          this.x /= num;
          this.y /= num;
          return this;
        },
        multiplyBy: function(num) {
          return this.clone()._multiplyBy(num);
        },
        _multiplyBy: function(num) {
          this.x *= num;
          this.y *= num;
          return this;
        },
        scaleBy: function(point3) {
          return new Point2(this.x * point3.x, this.y * point3.y);
        },
        unscaleBy: function(point3) {
          return new Point2(this.x / point3.x, this.y / point3.y);
        },
        round: function() {
          return this.clone()._round();
        },
        _round: function() {
          this.x = Math.round(this.x);
          this.y = Math.round(this.y);
          return this;
        },
        floor: function() {
          return this.clone()._floor();
        },
        _floor: function() {
          this.x = Math.floor(this.x);
          this.y = Math.floor(this.y);
          return this;
        },
        ceil: function() {
          return this.clone()._ceil();
        },
        _ceil: function() {
          this.x = Math.ceil(this.x);
          this.y = Math.ceil(this.y);
          return this;
        },
        trunc: function() {
          return this.clone()._trunc();
        },
        _trunc: function() {
          this.x = trunc(this.x);
          this.y = trunc(this.y);
          return this;
        },
        distanceTo: function(point3) {
          point3 = toPoint2(point3);
          var x = point3.x - this.x, y = point3.y - this.y;
          return Math.sqrt(x * x + y * y);
        },
        equals: function(point3) {
          point3 = toPoint2(point3);
          return point3.x === this.x && point3.y === this.y;
        },
        contains: function(point3) {
          point3 = toPoint2(point3);
          return Math.abs(point3.x) <= Math.abs(this.x) && Math.abs(point3.y) <= Math.abs(this.y);
        },
        toString: function() {
          return "Point(" + formatNum(this.x) + ", " + formatNum(this.y) + ")";
        }
      };
      function toPoint2(x, y, round) {
        if (x instanceof Point2) {
          return x;
        }
        if (isArray(x)) {
          return new Point2(x[0], x[1]);
        }
        if (x === void 0 || x === null) {
          return x;
        }
        if (typeof x === "object" && "x" in x && "y" in x) {
          return new Point2(x.x, x.y);
        }
        return new Point2(x, y, round);
      }
      function Bounds(a, b) {
        if (!a) {
          return;
        }
        var points = b ? [a, b] : a;
        for (var i = 0, len = points.length; i < len; i++) {
          this.extend(points[i]);
        }
      }
      Bounds.prototype = {
        extend: function(obj2) {
          var min2, max2;
          if (!obj2) {
            return this;
          }
          if (obj2 instanceof Point2 || typeof obj2[0] === "number" || "x" in obj2) {
            min2 = max2 = toPoint2(obj2);
          } else {
            obj2 = toBounds(obj2);
            min2 = obj2.min;
            max2 = obj2.max;
            if (!min2 || !max2) {
              return this;
            }
          }
          if (!this.min && !this.max) {
            this.min = min2.clone();
            this.max = max2.clone();
          } else {
            this.min.x = Math.min(min2.x, this.min.x);
            this.max.x = Math.max(max2.x, this.max.x);
            this.min.y = Math.min(min2.y, this.min.y);
            this.max.y = Math.max(max2.y, this.max.y);
          }
          return this;
        },
        getCenter: function(round) {
          return toPoint2(
            (this.min.x + this.max.x) / 2,
            (this.min.y + this.max.y) / 2,
            round
          );
        },
        getBottomLeft: function() {
          return toPoint2(this.min.x, this.max.y);
        },
        getTopRight: function() {
          return toPoint2(this.max.x, this.min.y);
        },
        getTopLeft: function() {
          return this.min;
        },
        getBottomRight: function() {
          return this.max;
        },
        getSize: function() {
          return this.max.subtract(this.min);
        },
        contains: function(obj2) {
          var min, max;
          if (typeof obj2[0] === "number" || obj2 instanceof Point2) {
            obj2 = toPoint2(obj2);
          } else {
            obj2 = toBounds(obj2);
          }
          if (obj2 instanceof Bounds) {
            min = obj2.min;
            max = obj2.max;
          } else {
            min = max = obj2;
          }
          return min.x >= this.min.x && max.x <= this.max.x && min.y >= this.min.y && max.y <= this.max.y;
        },
        intersects: function(bounds) {
          bounds = toBounds(bounds);
          var min = this.min, max = this.max, min2 = bounds.min, max2 = bounds.max, xIntersects = max2.x >= min.x && min2.x <= max.x, yIntersects = max2.y >= min.y && min2.y <= max.y;
          return xIntersects && yIntersects;
        },
        overlaps: function(bounds) {
          bounds = toBounds(bounds);
          var min = this.min, max = this.max, min2 = bounds.min, max2 = bounds.max, xOverlaps = max2.x > min.x && min2.x < max.x, yOverlaps = max2.y > min.y && min2.y < max.y;
          return xOverlaps && yOverlaps;
        },
        isValid: function() {
          return !!(this.min && this.max);
        },
        pad: function(bufferRatio) {
          var min = this.min, max = this.max, heightBuffer = Math.abs(min.x - max.x) * bufferRatio, widthBuffer = Math.abs(min.y - max.y) * bufferRatio;
          return toBounds(
            toPoint2(min.x - heightBuffer, min.y - widthBuffer),
            toPoint2(max.x + heightBuffer, max.y + widthBuffer)
          );
        },
        equals: function(bounds) {
          if (!bounds) {
            return false;
          }
          bounds = toBounds(bounds);
          return this.min.equals(bounds.getTopLeft()) && this.max.equals(bounds.getBottomRight());
        }
      };
      function toBounds(a, b) {
        if (!a || a instanceof Bounds) {
          return a;
        }
        return new Bounds(a, b);
      }
      function LatLngBounds2(corner1, corner2) {
        if (!corner1) {
          return;
        }
        var latlngs = corner2 ? [corner1, corner2] : corner1;
        for (var i = 0, len = latlngs.length; i < len; i++) {
          this.extend(latlngs[i]);
        }
      }
      LatLngBounds2.prototype = {
        extend: function(obj2) {
          var sw = this._southWest, ne = this._northEast, sw2, ne2;
          if (obj2 instanceof LatLng) {
            sw2 = obj2;
            ne2 = obj2;
          } else if (obj2 instanceof LatLngBounds2) {
            sw2 = obj2._southWest;
            ne2 = obj2._northEast;
            if (!sw2 || !ne2) {
              return this;
            }
          } else {
            return obj2 ? this.extend(toLatLng(obj2) || toLatLngBounds(obj2)) : this;
          }
          if (!sw && !ne) {
            this._southWest = new LatLng(sw2.lat, sw2.lng);
            this._northEast = new LatLng(ne2.lat, ne2.lng);
          } else {
            sw.lat = Math.min(sw2.lat, sw.lat);
            sw.lng = Math.min(sw2.lng, sw.lng);
            ne.lat = Math.max(ne2.lat, ne.lat);
            ne.lng = Math.max(ne2.lng, ne.lng);
          }
          return this;
        },
        pad: function(bufferRatio) {
          var sw = this._southWest, ne = this._northEast, heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio, widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;
          return new LatLngBounds2(
            new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),
            new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer)
          );
        },
        getCenter: function() {
          return new LatLng(
            (this._southWest.lat + this._northEast.lat) / 2,
            (this._southWest.lng + this._northEast.lng) / 2
          );
        },
        getSouthWest: function() {
          return this._southWest;
        },
        getNorthEast: function() {
          return this._northEast;
        },
        getNorthWest: function() {
          return new LatLng(this.getNorth(), this.getWest());
        },
        getSouthEast: function() {
          return new LatLng(this.getSouth(), this.getEast());
        },
        getWest: function() {
          return this._southWest.lng;
        },
        getSouth: function() {
          return this._southWest.lat;
        },
        getEast: function() {
          return this._northEast.lng;
        },
        getNorth: function() {
          return this._northEast.lat;
        },
        contains: function(obj2) {
          if (typeof obj2[0] === "number" || obj2 instanceof LatLng || "lat" in obj2) {
            obj2 = toLatLng(obj2);
          } else {
            obj2 = toLatLngBounds(obj2);
          }
          var sw = this._southWest, ne = this._northEast, sw2, ne2;
          if (obj2 instanceof LatLngBounds2) {
            sw2 = obj2.getSouthWest();
            ne2 = obj2.getNorthEast();
          } else {
            sw2 = ne2 = obj2;
          }
          return sw2.lat >= sw.lat && ne2.lat <= ne.lat && sw2.lng >= sw.lng && ne2.lng <= ne.lng;
        },
        intersects: function(bounds) {
          bounds = toLatLngBounds(bounds);
          var sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat, lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;
          return latIntersects && lngIntersects;
        },
        overlaps: function(bounds) {
          bounds = toLatLngBounds(bounds);
          var sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), latOverlaps = ne2.lat > sw.lat && sw2.lat < ne.lat, lngOverlaps = ne2.lng > sw.lng && sw2.lng < ne.lng;
          return latOverlaps && lngOverlaps;
        },
        toBBoxString: function() {
          return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(",");
        },
        equals: function(bounds, maxMargin) {
          if (!bounds) {
            return false;
          }
          bounds = toLatLngBounds(bounds);
          return this._southWest.equals(bounds.getSouthWest(), maxMargin) && this._northEast.equals(bounds.getNorthEast(), maxMargin);
        },
        isValid: function() {
          return !!(this._southWest && this._northEast);
        }
      };
      function toLatLngBounds(a, b) {
        if (a instanceof LatLngBounds2) {
          return a;
        }
        return new LatLngBounds2(a, b);
      }
      function LatLng(lat, lng, alt) {
        if (isNaN(lat) || isNaN(lng)) {
          throw new Error("Invalid LatLng object: (" + lat + ", " + lng + ")");
        }
        this.lat = +lat;
        this.lng = +lng;
        if (alt !== void 0) {
          this.alt = +alt;
        }
      }
      LatLng.prototype = {
        equals: function(obj2, maxMargin) {
          if (!obj2) {
            return false;
          }
          obj2 = toLatLng(obj2);
          var margin = Math.max(
            Math.abs(this.lat - obj2.lat),
            Math.abs(this.lng - obj2.lng)
          );
          return margin <= (maxMargin === void 0 ? 1e-9 : maxMargin);
        },
        toString: function(precision) {
          return "LatLng(" + formatNum(this.lat, precision) + ", " + formatNum(this.lng, precision) + ")";
        },
        distanceTo: function(other) {
          return Earth.distance(this, toLatLng(other));
        },
        wrap: function() {
          return Earth.wrapLatLng(this);
        },
        toBounds: function(sizeInMeters) {
          var latAccuracy = 180 * sizeInMeters / 40075017, lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * this.lat);
          return toLatLngBounds(
            [this.lat - latAccuracy, this.lng - lngAccuracy],
            [this.lat + latAccuracy, this.lng + lngAccuracy]
          );
        },
        clone: function() {
          return new LatLng(this.lat, this.lng, this.alt);
        }
      };
      function toLatLng(a, b, c) {
        if (a instanceof LatLng) {
          return a;
        }
        if (isArray(a) && typeof a[0] !== "object") {
          if (a.length === 3) {
            return new LatLng(a[0], a[1], a[2]);
          }
          if (a.length === 2) {
            return new LatLng(a[0], a[1]);
          }
          return null;
        }
        if (a === void 0 || a === null) {
          return a;
        }
        if (typeof a === "object" && "lat" in a) {
          return new LatLng(a.lat, "lng" in a ? a.lng : a.lon, a.alt);
        }
        if (b === void 0) {
          return null;
        }
        return new LatLng(a, b, c);
      }
      var CRS2 = {
        latLngToPoint: function(latlng, zoom2) {
          var projectedPoint = this.projection.project(latlng), scale2 = this.scale(zoom2);
          return this.transformation._transform(projectedPoint, scale2);
        },
        pointToLatLng: function(point3, zoom2) {
          var scale2 = this.scale(zoom2), untransformedPoint = this.transformation.untransform(point3, scale2);
          return this.projection.unproject(untransformedPoint);
        },
        project: function(latlng) {
          return this.projection.project(latlng);
        },
        unproject: function(point3) {
          return this.projection.unproject(point3);
        },
        scale: function(zoom2) {
          return 256 * Math.pow(2, zoom2);
        },
        zoom: function(scale2) {
          return Math.log(scale2 / 256) / Math.LN2;
        },
        getProjectedBounds: function(zoom2) {
          if (this.infinite) {
            return null;
          }
          var b = this.projection.bounds, s = this.scale(zoom2), min = this.transformation.transform(b.min, s), max = this.transformation.transform(b.max, s);
          return new Bounds(min, max);
        },
        infinite: false,
        wrapLatLng: function(latlng) {
          var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng, lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat, alt = latlng.alt;
          return new LatLng(lat, lng, alt);
        },
        wrapLatLngBounds: function(bounds) {
          var center = bounds.getCenter(), newCenter = this.wrapLatLng(center), latShift = center.lat - newCenter.lat, lngShift = center.lng - newCenter.lng;
          if (latShift === 0 && lngShift === 0) {
            return bounds;
          }
          var sw = bounds.getSouthWest(), ne = bounds.getNorthEast(), newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift), newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);
          return new LatLngBounds2(newSw, newNe);
        }
      };
      var Earth = extend({}, CRS2, {
        wrapLng: [-180, 180],
        R: 6371e3,
        distance: function(latlng1, latlng2) {
          var rad = Math.PI / 180, lat1 = latlng1.lat * rad, lat2 = latlng2.lat * rad, sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2), sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2), a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon, c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
          return this.R * c;
        }
      });
      var earthRadius = 6378137;
      var SphericalMercator = {
        R: earthRadius,
        MAX_LATITUDE: 85.0511287798,
        project: function(latlng) {
          var d = Math.PI / 180, max = this.MAX_LATITUDE, lat = Math.max(Math.min(max, latlng.lat), -max), sin = Math.sin(lat * d);
          return new Point2(
            this.R * latlng.lng * d,
            this.R * Math.log((1 + sin) / (1 - sin)) / 2
          );
        },
        unproject: function(point3) {
          var d = 180 / Math.PI;
          return new LatLng(
            (2 * Math.atan(Math.exp(point3.y / this.R)) - Math.PI / 2) * d,
            point3.x * d / this.R
          );
        },
        bounds: function() {
          var d = earthRadius * Math.PI;
          return new Bounds([-d, -d], [d, d]);
        }()
      };
      function Transformation(a, b, c, d) {
        if (isArray(a)) {
          this._a = a[0];
          this._b = a[1];
          this._c = a[2];
          this._d = a[3];
          return;
        }
        this._a = a;
        this._b = b;
        this._c = c;
        this._d = d;
      }
      Transformation.prototype = {
        transform: function(point3, scale2) {
          return this._transform(point3.clone(), scale2);
        },
        _transform: function(point3, scale2) {
          scale2 = scale2 || 1;
          point3.x = scale2 * (this._a * point3.x + this._b);
          point3.y = scale2 * (this._c * point3.y + this._d);
          return point3;
        },
        untransform: function(point3, scale2) {
          scale2 = scale2 || 1;
          return new Point2(
            (point3.x / scale2 - this._b) / this._a,
            (point3.y / scale2 - this._d) / this._c
          );
        }
      };
      function toTransformation(a, b, c, d) {
        return new Transformation(a, b, c, d);
      }
      var EPSG3857 = extend({}, Earth, {
        code: "EPSG:3857",
        projection: SphericalMercator,
        transformation: function() {
          var scale2 = 0.5 / (Math.PI * SphericalMercator.R);
          return toTransformation(scale2, 0.5, -scale2, 0.5);
        }()
      });
      var EPSG900913 = extend({}, EPSG3857, {
        code: "EPSG:900913"
      });
      function svgCreate(name) {
        return document.createElementNS("http://www.w3.org/2000/svg", name);
      }
      function pointsToPath(rings, closed) {
        var str = "", i, j, len, len2, points, p;
        for (i = 0, len = rings.length; i < len; i++) {
          points = rings[i];
          for (j = 0, len2 = points.length; j < len2; j++) {
            p = points[j];
            str += (j ? "L" : "M") + p.x + " " + p.y;
          }
          str += closed ? Browser2.svg ? "z" : "x" : "";
        }
        return str || "M0 0";
      }
      var style = document.documentElement.style;
      var ie = "ActiveXObject" in window;
      var ielt9 = ie && !document.addEventListener;
      var edge = "msLaunchUri" in navigator && !("documentMode" in document);
      var webkit = userAgentContains("webkit");
      var android = userAgentContains("android");
      var android23 = userAgentContains("android 2") || userAgentContains("android 3");
      var webkitVer = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10);
      var androidStock = android && userAgentContains("Google") && webkitVer < 537 && !("AudioNode" in window);
      var opera = !!window.opera;
      var chrome = !edge && userAgentContains("chrome");
      var gecko = userAgentContains("gecko") && !webkit && !opera && !ie;
      var safari = !chrome && userAgentContains("safari");
      var phantom = userAgentContains("phantom");
      var opera12 = "OTransition" in style;
      var win = navigator.platform.indexOf("Win") === 0;
      var ie3d = ie && "transition" in style;
      var webkit3d = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix() && !android23;
      var gecko3d = "MozPerspective" in style;
      var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;
      var mobile = typeof orientation !== "undefined" || userAgentContains("mobile");
      var mobileWebkit = mobile && webkit;
      var mobileWebkit3d = mobile && webkit3d;
      var msPointer = !window.PointerEvent && window.MSPointerEvent;
      var pointer = !!(window.PointerEvent || msPointer);
      var touchNative = "ontouchstart" in window || !!window.TouchEvent;
      var touch = !window.L_NO_TOUCH && (touchNative || pointer);
      var mobileOpera = mobile && opera;
      var mobileGecko = mobile && gecko;
      var retina = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1;
      var passiveEvents = function() {
        var supportsPassiveOption = false;
        try {
          var opts = Object.defineProperty({}, "passive", {
            get: function() {
              supportsPassiveOption = true;
            }
          });
          window.addEventListener("testPassiveEventSupport", falseFn, opts);
          window.removeEventListener("testPassiveEventSupport", falseFn, opts);
        } catch (e) {
        }
        return supportsPassiveOption;
      }();
      var canvas$1 = function() {
        return !!document.createElement("canvas").getContext;
      }();
      var svg$1 = !!(document.createElementNS && svgCreate("svg").createSVGRect);
      var inlineSvg = !!svg$1 && function() {
        var div = document.createElement("div");
        div.innerHTML = "<svg/>";
        return (div.firstChild && div.firstChild.namespaceURI) === "http://www.w3.org/2000/svg";
      }();
      var vml = !svg$1 && function() {
        try {
          var div = document.createElement("div");
          div.innerHTML = '<v:shape adj="1"/>';
          var shape = div.firstChild;
          shape.style.behavior = "url(#default#VML)";
          return shape && typeof shape.adj === "object";
        } catch (e) {
          return false;
        }
      }();
      var mac = navigator.platform.indexOf("Mac") === 0;
      var linux = navigator.platform.indexOf("Linux") === 0;
      function userAgentContains(str) {
        return navigator.userAgent.toLowerCase().indexOf(str) >= 0;
      }
      var Browser2 = {
        ie,
        ielt9,
        edge,
        webkit,
        android,
        android23,
        androidStock,
        opera,
        chrome,
        gecko,
        safari,
        phantom,
        opera12,
        win,
        ie3d,
        webkit3d,
        gecko3d,
        any3d,
        mobile,
        mobileWebkit,
        mobileWebkit3d,
        msPointer,
        pointer,
        touch,
        touchNative,
        mobileOpera,
        mobileGecko,
        retina,
        passiveEvents,
        canvas: canvas$1,
        svg: svg$1,
        vml,
        inlineSvg,
        mac,
        linux
      };
      var POINTER_DOWN = Browser2.msPointer ? "MSPointerDown" : "pointerdown";
      var POINTER_MOVE = Browser2.msPointer ? "MSPointerMove" : "pointermove";
      var POINTER_UP = Browser2.msPointer ? "MSPointerUp" : "pointerup";
      var POINTER_CANCEL = Browser2.msPointer ? "MSPointerCancel" : "pointercancel";
      var pEvent = {
        touchstart: POINTER_DOWN,
        touchmove: POINTER_MOVE,
        touchend: POINTER_UP,
        touchcancel: POINTER_CANCEL
      };
      var handle = {
        touchstart: _onPointerStart,
        touchmove: _handlePointer,
        touchend: _handlePointer,
        touchcancel: _handlePointer
      };
      var _pointers = {};
      var _pointerDocListener = false;
      function addPointerListener(obj2, type, handler) {
        if (type === "touchstart") {
          _addPointerDocListener();
        }
        if (!handle[type]) {
          console.warn("wrong event specified:", type);
          return falseFn;
        }
        handler = handle[type].bind(this, handler);
        obj2.addEventListener(pEvent[type], handler, false);
        return handler;
      }
      function removePointerListener(obj2, type, handler) {
        if (!pEvent[type]) {
          console.warn("wrong event specified:", type);
          return;
        }
        obj2.removeEventListener(pEvent[type], handler, false);
      }
      function _globalPointerDown(e) {
        _pointers[e.pointerId] = e;
      }
      function _globalPointerMove(e) {
        if (_pointers[e.pointerId]) {
          _pointers[e.pointerId] = e;
        }
      }
      function _globalPointerUp(e) {
        delete _pointers[e.pointerId];
      }
      function _addPointerDocListener() {
        if (!_pointerDocListener) {
          document.addEventListener(POINTER_DOWN, _globalPointerDown, true);
          document.addEventListener(POINTER_MOVE, _globalPointerMove, true);
          document.addEventListener(POINTER_UP, _globalPointerUp, true);
          document.addEventListener(POINTER_CANCEL, _globalPointerUp, true);
          _pointerDocListener = true;
        }
      }
      function _handlePointer(handler, e) {
        if (e.pointerType === (e.MSPOINTER_TYPE_MOUSE || "mouse")) {
          return;
        }
        e.touches = [];
        for (var i in _pointers) {
          e.touches.push(_pointers[i]);
        }
        e.changedTouches = [e];
        handler(e);
      }
      function _onPointerStart(handler, e) {
        if (e.MSPOINTER_TYPE_TOUCH && e.pointerType === e.MSPOINTER_TYPE_TOUCH) {
          preventDefault(e);
        }
        _handlePointer(handler, e);
      }
      function makeDblclick(event) {
        var newEvent = {}, prop, i;
        for (i in event) {
          prop = event[i];
          newEvent[i] = prop && prop.bind ? prop.bind(event) : prop;
        }
        event = newEvent;
        newEvent.type = "dblclick";
        newEvent.detail = 2;
        newEvent.isTrusted = false;
        newEvent._simulated = true;
        return newEvent;
      }
      var delay = 200;
      function addDoubleTapListener(obj2, handler) {
        obj2.addEventListener("dblclick", handler);
        var last = 0, detail;
        function simDblclick(e) {
          if (e.detail !== 1) {
            detail = e.detail;
            return;
          }
          if (e.pointerType === "mouse" || e.sourceCapabilities && !e.sourceCapabilities.firesTouchEvents) {
            return;
          }
          var path = getPropagationPath(e);
          if (path.some(function(el) {
            return el instanceof HTMLLabelElement && el.attributes.for;
          }) && !path.some(function(el) {
            return el instanceof HTMLInputElement || el instanceof HTMLSelectElement;
          })) {
            return;
          }
          var now = Date.now();
          if (now - last <= delay) {
            detail++;
            if (detail === 2) {
              handler(makeDblclick(e));
            }
          } else {
            detail = 1;
          }
          last = now;
        }
        obj2.addEventListener("click", simDblclick);
        return {
          dblclick: handler,
          simDblclick
        };
      }
      function removeDoubleTapListener(obj2, handlers) {
        obj2.removeEventListener("dblclick", handlers.dblclick);
        obj2.removeEventListener("click", handlers.simDblclick);
      }
      var TRANSFORM = testProp(
        ["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]
      );
      var TRANSITION = testProp(
        ["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]
      );
      var TRANSITION_END = TRANSITION === "webkitTransition" || TRANSITION === "OTransition" ? TRANSITION + "End" : "transitionend";
      function get2(id) {
        return typeof id === "string" ? document.getElementById(id) : id;
      }
      function getStyle(el, style2) {
        var value = el.style[style2] || el.currentStyle && el.currentStyle[style2];
        if ((!value || value === "auto") && document.defaultView) {
          var css = document.defaultView.getComputedStyle(el, null);
          value = css ? css[style2] : null;
        }
        return value === "auto" ? null : value;
      }
      function create$1(tagName, className, container) {
        var el = document.createElement(tagName);
        el.className = className || "";
        if (container) {
          container.appendChild(el);
        }
        return el;
      }
      function remove(el) {
        var parent = el.parentNode;
        if (parent) {
          parent.removeChild(el);
        }
      }
      function empty(el) {
        while (el.firstChild) {
          el.removeChild(el.firstChild);
        }
      }
      function toFront(el) {
        var parent = el.parentNode;
        if (parent && parent.lastChild !== el) {
          parent.appendChild(el);
        }
      }
      function toBack(el) {
        var parent = el.parentNode;
        if (parent && parent.firstChild !== el) {
          parent.insertBefore(el, parent.firstChild);
        }
      }
      function hasClass(el, name) {
        if (el.classList !== void 0) {
          return el.classList.contains(name);
        }
        var className = getClass(el);
        return className.length > 0 && new RegExp("(^|\\s)" + name + "(\\s|$)").test(className);
      }
      function addClass(el, name) {
        if (el.classList !== void 0) {
          var classes = splitWords(name);
          for (var i = 0, len = classes.length; i < len; i++) {
            el.classList.add(classes[i]);
          }
        } else if (!hasClass(el, name)) {
          var className = getClass(el);
          setClass(el, (className ? className + " " : "") + name);
        }
      }
      function removeClass(el, name) {
        if (el.classList !== void 0) {
          el.classList.remove(name);
        } else {
          setClass(el, trim((" " + getClass(el) + " ").replace(" " + name + " ", " ")));
        }
      }
      function setClass(el, name) {
        if (el.className.baseVal === void 0) {
          el.className = name;
        } else {
          el.className.baseVal = name;
        }
      }
      function getClass(el) {
        if (el.correspondingElement) {
          el = el.correspondingElement;
        }
        return el.className.baseVal === void 0 ? el.className : el.className.baseVal;
      }
      function setOpacity(el, value) {
        if ("opacity" in el.style) {
          el.style.opacity = value;
        } else if ("filter" in el.style) {
          _setOpacityIE(el, value);
        }
      }
      function _setOpacityIE(el, value) {
        var filter = false, filterName = "DXImageTransform.Microsoft.Alpha";
        try {
          filter = el.filters.item(filterName);
        } catch (e) {
          if (value === 1) {
            return;
          }
        }
        value = Math.round(value * 100);
        if (filter) {
          filter.Enabled = value !== 100;
          filter.Opacity = value;
        } else {
          el.style.filter += " progid:" + filterName + "(opacity=" + value + ")";
        }
      }
      function testProp(props) {
        var style2 = document.documentElement.style;
        for (var i = 0; i < props.length; i++) {
          if (props[i] in style2) {
            return props[i];
          }
        }
        return false;
      }
      function setTransform(el, offset, scale2) {
        var pos = offset || new Point2(0, 0);
        el.style[TRANSFORM] = (Browser2.ie3d ? "translate(" + pos.x + "px," + pos.y + "px)" : "translate3d(" + pos.x + "px," + pos.y + "px,0)") + (scale2 ? " scale(" + scale2 + ")" : "");
      }
      function setPosition(el, point3) {
        el._leaflet_pos = point3;
        if (Browser2.any3d) {
          setTransform(el, point3);
        } else {
          el.style.left = point3.x + "px";
          el.style.top = point3.y + "px";
        }
      }
      function getPosition(el) {
        return el._leaflet_pos || new Point2(0, 0);
      }
      var disableTextSelection;
      var enableTextSelection;
      var _userSelect;
      if ("onselectstart" in document) {
        disableTextSelection = function() {
          on(window, "selectstart", preventDefault);
        };
        enableTextSelection = function() {
          off(window, "selectstart", preventDefault);
        };
      } else {
        var userSelectProperty = testProp(
          ["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]
        );
        disableTextSelection = function() {
          if (userSelectProperty) {
            var style2 = document.documentElement.style;
            _userSelect = style2[userSelectProperty];
            style2[userSelectProperty] = "none";
          }
        };
        enableTextSelection = function() {
          if (userSelectProperty) {
            document.documentElement.style[userSelectProperty] = _userSelect;
            _userSelect = void 0;
          }
        };
      }
      function disableImageDrag() {
        on(window, "dragstart", preventDefault);
      }
      function enableImageDrag() {
        off(window, "dragstart", preventDefault);
      }
      var _outlineElement, _outlineStyle;
      function preventOutline(element) {
        while (element.tabIndex === -1) {
          element = element.parentNode;
        }
        if (!element.style) {
          return;
        }
        restoreOutline();
        _outlineElement = element;
        _outlineStyle = element.style.outlineStyle;
        element.style.outlineStyle = "none";
        on(window, "keydown", restoreOutline);
      }
      function restoreOutline() {
        if (!_outlineElement) {
          return;
        }
        _outlineElement.style.outlineStyle = _outlineStyle;
        _outlineElement = void 0;
        _outlineStyle = void 0;
        off(window, "keydown", restoreOutline);
      }
      function getSizedParentNode(element) {
        do {
          element = element.parentNode;
        } while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);
        return element;
      }
      function getScale(element) {
        var rect = element.getBoundingClientRect();
        return {
          x: rect.width / element.offsetWidth || 1,
          y: rect.height / element.offsetHeight || 1,
          boundingClientRect: rect
        };
      }
      var DomUtil2 = {
        __proto__: null,
        TRANSFORM,
        TRANSITION,
        TRANSITION_END,
        get: get2,
        getStyle,
        create: create$1,
        remove,
        empty,
        toFront,
        toBack,
        hasClass,
        addClass,
        removeClass,
        setClass,
        getClass,
        setOpacity,
        testProp,
        setTransform,
        setPosition,
        getPosition,
        get disableTextSelection() {
          return disableTextSelection;
        },
        get enableTextSelection() {
          return enableTextSelection;
        },
        disableImageDrag,
        enableImageDrag,
        preventOutline,
        restoreOutline,
        getSizedParentNode,
        getScale
      };
      function on(obj2, types, fn, context) {
        if (types && typeof types === "object") {
          for (var type in types) {
            addOne(obj2, type, types[type], fn);
          }
        } else {
          types = splitWords(types);
          for (var i = 0, len = types.length; i < len; i++) {
            addOne(obj2, types[i], fn, context);
          }
        }
        return this;
      }
      var eventsKey = "_leaflet_events";
      function off(obj2, types, fn, context) {
        if (arguments.length === 1) {
          batchRemove(obj2);
          delete obj2[eventsKey];
        } else if (types && typeof types === "object") {
          for (var type in types) {
            removeOne(obj2, type, types[type], fn);
          }
        } else {
          types = splitWords(types);
          if (arguments.length === 2) {
            batchRemove(obj2, function(type2) {
              return indexOf(types, type2) !== -1;
            });
          } else {
            for (var i = 0, len = types.length; i < len; i++) {
              removeOne(obj2, types[i], fn, context);
            }
          }
        }
        return this;
      }
      function batchRemove(obj2, filterFn) {
        for (var id in obj2[eventsKey]) {
          var type = id.split(/\d/)[0];
          if (!filterFn || filterFn(type)) {
            removeOne(obj2, type, null, null, id);
          }
        }
      }
      var mouseSubst = {
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        wheel: !("onwheel" in window) && "mousewheel"
      };
      function addOne(obj2, type, fn, context) {
        var id = type + stamp(fn) + (context ? "_" + stamp(context) : "");
        if (obj2[eventsKey] && obj2[eventsKey][id]) {
          return this;
        }
        var handler = function(e) {
          return fn.call(context || obj2, e || window.event);
        };
        var originalHandler = handler;
        if (!Browser2.touchNative && Browser2.pointer && type.indexOf("touch") === 0) {
          handler = addPointerListener(obj2, type, handler);
        } else if (Browser2.touch && type === "dblclick") {
          handler = addDoubleTapListener(obj2, handler);
        } else if ("addEventListener" in obj2) {
          if (type === "touchstart" || type === "touchmove" || type === "wheel" || type === "mousewheel") {
            obj2.addEventListener(mouseSubst[type] || type, handler, Browser2.passiveEvents ? { passive: false } : false);
          } else if (type === "mouseenter" || type === "mouseleave") {
            handler = function(e) {
              e = e || window.event;
              if (isExternalTarget(obj2, e)) {
                originalHandler(e);
              }
            };
            obj2.addEventListener(mouseSubst[type], handler, false);
          } else {
            obj2.addEventListener(type, originalHandler, false);
          }
        } else {
          obj2.attachEvent("on" + type, handler);
        }
        obj2[eventsKey] = obj2[eventsKey] || {};
        obj2[eventsKey][id] = handler;
      }
      function removeOne(obj2, type, fn, context, id) {
        id = id || type + stamp(fn) + (context ? "_" + stamp(context) : "");
        var handler = obj2[eventsKey] && obj2[eventsKey][id];
        if (!handler) {
          return this;
        }
        if (!Browser2.touchNative && Browser2.pointer && type.indexOf("touch") === 0) {
          removePointerListener(obj2, type, handler);
        } else if (Browser2.touch && type === "dblclick") {
          removeDoubleTapListener(obj2, handler);
        } else if ("removeEventListener" in obj2) {
          obj2.removeEventListener(mouseSubst[type] || type, handler, false);
        } else {
          obj2.detachEvent("on" + type, handler);
        }
        obj2[eventsKey][id] = null;
      }
      function stopPropagation(e) {
        if (e.stopPropagation) {
          e.stopPropagation();
        } else if (e.originalEvent) {
          e.originalEvent._stopped = true;
        } else {
          e.cancelBubble = true;
        }
        return this;
      }
      function disableScrollPropagation(el) {
        addOne(el, "wheel", stopPropagation);
        return this;
      }
      function disableClickPropagation(el) {
        on(el, "mousedown touchstart dblclick contextmenu", stopPropagation);
        el["_leaflet_disable_click"] = true;
        return this;
      }
      function preventDefault(e) {
        if (e.preventDefault) {
          e.preventDefault();
        } else {
          e.returnValue = false;
        }
        return this;
      }
      function stop(e) {
        preventDefault(e);
        stopPropagation(e);
        return this;
      }
      function getPropagationPath(ev) {
        if (ev.composedPath) {
          return ev.composedPath();
        }
        var path = [];
        var el = ev.target;
        while (el) {
          path.push(el);
          el = el.parentNode;
        }
        return path;
      }
      function getMousePosition(e, container) {
        if (!container) {
          return new Point2(e.clientX, e.clientY);
        }
        var scale2 = getScale(container), offset = scale2.boundingClientRect;
        return new Point2(
          (e.clientX - offset.left) / scale2.x - container.clientLeft,
          (e.clientY - offset.top) / scale2.y - container.clientTop
        );
      }
      var wheelPxFactor = Browser2.linux && Browser2.chrome ? window.devicePixelRatio : Browser2.mac ? window.devicePixelRatio * 3 : window.devicePixelRatio > 0 ? 2 * window.devicePixelRatio : 1;
      function getWheelDelta(e) {
        return Browser2.edge ? e.wheelDeltaY / 2 : e.deltaY && e.deltaMode === 0 ? -e.deltaY / wheelPxFactor : e.deltaY && e.deltaMode === 1 ? -e.deltaY * 20 : e.deltaY && e.deltaMode === 2 ? -e.deltaY * 60 : e.deltaX || e.deltaZ ? 0 : e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : e.detail && Math.abs(e.detail) < 32765 ? -e.detail * 20 : e.detail ? e.detail / -32765 * 60 : 0;
      }
      function isExternalTarget(el, e) {
        var related = e.relatedTarget;
        if (!related) {
          return true;
        }
        try {
          while (related && related !== el) {
            related = related.parentNode;
          }
        } catch (err) {
          return false;
        }
        return related !== el;
      }
      var DomEvent = {
        __proto__: null,
        on,
        off,
        stopPropagation,
        disableScrollPropagation,
        disableClickPropagation,
        preventDefault,
        stop,
        getPropagationPath,
        getMousePosition,
        getWheelDelta,
        isExternalTarget,
        addListener: on,
        removeListener: off
      };
      var PosAnimation = Evented.extend({
        run: function(el, newPos, duration, easeLinearity) {
          this.stop();
          this._el = el;
          this._inProgress = true;
          this._duration = duration || 0.25;
          this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);
          this._startPos = getPosition(el);
          this._offset = newPos.subtract(this._startPos);
          this._startTime = +new Date();
          this.fire("start");
          this._animate();
        },
        stop: function() {
          if (!this._inProgress) {
            return;
          }
          this._step(true);
          this._complete();
        },
        _animate: function() {
          this._animId = requestAnimFrame(this._animate, this);
          this._step();
        },
        _step: function(round) {
          var elapsed = +new Date() - this._startTime, duration = this._duration * 1e3;
          if (elapsed < duration) {
            this._runFrame(this._easeOut(elapsed / duration), round);
          } else {
            this._runFrame(1);
            this._complete();
          }
        },
        _runFrame: function(progress, round) {
          var pos = this._startPos.add(this._offset.multiplyBy(progress));
          if (round) {
            pos._round();
          }
          setPosition(this._el, pos);
          this.fire("step");
        },
        _complete: function() {
          cancelAnimFrame(this._animId);
          this._inProgress = false;
          this.fire("end");
        },
        _easeOut: function(t) {
          return 1 - Math.pow(1 - t, this._easeOutPower);
        }
      });
      var Map = Evented.extend({
        options: {
          crs: EPSG3857,
          center: void 0,
          zoom: void 0,
          minZoom: void 0,
          maxZoom: void 0,
          layers: [],
          maxBounds: void 0,
          renderer: void 0,
          zoomAnimation: true,
          zoomAnimationThreshold: 4,
          fadeAnimation: true,
          markerZoomAnimation: true,
          transform3DLimit: 8388608,
          zoomSnap: 1,
          zoomDelta: 1,
          trackResize: true
        },
        initialize: function(id, options) {
          options = setOptions(this, options);
          this._handlers = [];
          this._layers = {};
          this._zoomBoundLayers = {};
          this._sizeChanged = true;
          this._initContainer(id);
          this._initLayout();
          this._onResize = bind(this._onResize, this);
          this._initEvents();
          if (options.maxBounds) {
            this.setMaxBounds(options.maxBounds);
          }
          if (options.zoom !== void 0) {
            this._zoom = this._limitZoom(options.zoom);
          }
          if (options.center && options.zoom !== void 0) {
            this.setView(toLatLng(options.center), options.zoom, { reset: true });
          }
          this.callInitHooks();
          this._zoomAnimated = TRANSITION && Browser2.any3d && !Browser2.mobileOpera && this.options.zoomAnimation;
          if (this._zoomAnimated) {
            this._createAnimProxy();
            on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);
          }
          this._addLayers(this.options.layers);
        },
        setView: function(center, zoom2, options) {
          zoom2 = zoom2 === void 0 ? this._zoom : this._limitZoom(zoom2);
          center = this._limitCenter(toLatLng(center), zoom2, this.options.maxBounds);
          options = options || {};
          this._stop();
          if (this._loaded && !options.reset && options !== true) {
            if (options.animate !== void 0) {
              options.zoom = extend({ animate: options.animate }, options.zoom);
              options.pan = extend({ animate: options.animate, duration: options.duration }, options.pan);
            }
            var moved = this._zoom !== zoom2 ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom2, options.zoom) : this._tryAnimatedPan(center, options.pan);
            if (moved) {
              clearTimeout(this._sizeTimer);
              return this;
            }
          }
          this._resetView(center, zoom2, options.pan && options.pan.noMoveStart);
          return this;
        },
        setZoom: function(zoom2, options) {
          if (!this._loaded) {
            this._zoom = zoom2;
            return this;
          }
          return this.setView(this.getCenter(), zoom2, { zoom: options });
        },
        zoomIn: function(delta, options) {
          delta = delta || (Browser2.any3d ? this.options.zoomDelta : 1);
          return this.setZoom(this._zoom + delta, options);
        },
        zoomOut: function(delta, options) {
          delta = delta || (Browser2.any3d ? this.options.zoomDelta : 1);
          return this.setZoom(this._zoom - delta, options);
        },
        setZoomAround: function(latlng, zoom2, options) {
          var scale2 = this.getZoomScale(zoom2), viewHalf = this.getSize().divideBy(2), containerPoint = latlng instanceof Point2 ? latlng : this.latLngToContainerPoint(latlng), centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale2), newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));
          return this.setView(newCenter, zoom2, { zoom: options });
        },
        _getBoundsCenterZoom: function(bounds, options) {
          options = options || {};
          bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);
          var paddingTL = toPoint2(options.paddingTopLeft || options.padding || [0, 0]), paddingBR = toPoint2(options.paddingBottomRight || options.padding || [0, 0]), zoom2 = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));
          zoom2 = typeof options.maxZoom === "number" ? Math.min(options.maxZoom, zoom2) : zoom2;
          if (zoom2 === Infinity) {
            return {
              center: bounds.getCenter(),
              zoom: zoom2
            };
          }
          var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2), swPoint = this.project(bounds.getSouthWest(), zoom2), nePoint = this.project(bounds.getNorthEast(), zoom2), center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom2);
          return {
            center,
            zoom: zoom2
          };
        },
        fitBounds: function(bounds, options) {
          bounds = toLatLngBounds(bounds);
          if (!bounds.isValid()) {
            throw new Error("Bounds are not valid.");
          }
          var target = this._getBoundsCenterZoom(bounds, options);
          return this.setView(target.center, target.zoom, options);
        },
        fitWorld: function(options) {
          return this.fitBounds([[-90, -180], [90, 180]], options);
        },
        panTo: function(center, options) {
          return this.setView(center, this._zoom, { pan: options });
        },
        panBy: function(offset, options) {
          offset = toPoint2(offset).round();
          options = options || {};
          if (!offset.x && !offset.y) {
            return this.fire("moveend");
          }
          if (options.animate !== true && !this.getSize().contains(offset)) {
            this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
            return this;
          }
          if (!this._panAnim) {
            this._panAnim = new PosAnimation();
            this._panAnim.on({
              "step": this._onPanTransitionStep,
              "end": this._onPanTransitionEnd
            }, this);
          }
          if (!options.noMoveStart) {
            this.fire("movestart");
          }
          if (options.animate !== false) {
            addClass(this._mapPane, "leaflet-pan-anim");
            var newPos = this._getMapPanePos().subtract(offset).round();
            this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
          } else {
            this._rawPanBy(offset);
            this.fire("move").fire("moveend");
          }
          return this;
        },
        flyTo: function(targetCenter, targetZoom, options) {
          options = options || {};
          if (options.animate === false || !Browser2.any3d) {
            return this.setView(targetCenter, targetZoom, options);
          }
          this._stop();
          var from = this.project(this.getCenter()), to = this.project(targetCenter), size = this.getSize(), startZoom = this._zoom;
          targetCenter = toLatLng(targetCenter);
          targetZoom = targetZoom === void 0 ? startZoom : targetZoom;
          var w0 = Math.max(size.x, size.y), w1 = w0 * this.getZoomScale(startZoom, targetZoom), u1 = to.distanceTo(from) || 1, rho = 1.42, rho2 = rho * rho;
          function r(i) {
            var s1 = i ? -1 : 1, s2 = i ? w1 : w0, t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1, b1 = 2 * s2 * rho2 * u1, b = t1 / b1, sq = Math.sqrt(b * b + 1) - b;
            var log2 = sq < 1e-9 ? -18 : Math.log(sq);
            return log2;
          }
          function sinh(n) {
            return (Math.exp(n) - Math.exp(-n)) / 2;
          }
          function cosh(n) {
            return (Math.exp(n) + Math.exp(-n)) / 2;
          }
          function tanh(n) {
            return sinh(n) / cosh(n);
          }
          var r0 = r(0);
          function w(s) {
            return w0 * (cosh(r0) / cosh(r0 + rho * s));
          }
          function u(s) {
            return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2;
          }
          function easeOut(t) {
            return 1 - Math.pow(1 - t, 1.5);
          }
          var start2 = Date.now(), S = (r(1) - r0) / rho, duration = options.duration ? 1e3 * options.duration : 1e3 * S * 0.8;
          function frame() {
            var t = (Date.now() - start2) / duration, s = easeOut(t) * S;
            if (t <= 1) {
              this._flyToFrame = requestAnimFrame(frame, this);
              this._move(
                this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom),
                this.getScaleZoom(w0 / w(s), startZoom),
                { flyTo: true }
              );
            } else {
              this._move(targetCenter, targetZoom)._moveEnd(true);
            }
          }
          this._moveStart(true, options.noMoveStart);
          frame.call(this);
          return this;
        },
        flyToBounds: function(bounds, options) {
          var target = this._getBoundsCenterZoom(bounds, options);
          return this.flyTo(target.center, target.zoom, options);
        },
        setMaxBounds: function(bounds) {
          bounds = toLatLngBounds(bounds);
          if (this.listens("moveend", this._panInsideMaxBounds)) {
            this.off("moveend", this._panInsideMaxBounds);
          }
          if (!bounds.isValid()) {
            this.options.maxBounds = null;
            return this;
          }
          this.options.maxBounds = bounds;
          if (this._loaded) {
            this._panInsideMaxBounds();
          }
          return this.on("moveend", this._panInsideMaxBounds);
        },
        setMinZoom: function(zoom2) {
          var oldZoom = this.options.minZoom;
          this.options.minZoom = zoom2;
          if (this._loaded && oldZoom !== zoom2) {
            this.fire("zoomlevelschange");
            if (this.getZoom() < this.options.minZoom) {
              return this.setZoom(zoom2);
            }
          }
          return this;
        },
        setMaxZoom: function(zoom2) {
          var oldZoom = this.options.maxZoom;
          this.options.maxZoom = zoom2;
          if (this._loaded && oldZoom !== zoom2) {
            this.fire("zoomlevelschange");
            if (this.getZoom() > this.options.maxZoom) {
              return this.setZoom(zoom2);
            }
          }
          return this;
        },
        panInsideBounds: function(bounds, options) {
          this._enforcingBounds = true;
          var center = this.getCenter(), newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));
          if (!center.equals(newCenter)) {
            this.panTo(newCenter, options);
          }
          this._enforcingBounds = false;
          return this;
        },
        panInside: function(latlng, options) {
          options = options || {};
          var paddingTL = toPoint2(options.paddingTopLeft || options.padding || [0, 0]), paddingBR = toPoint2(options.paddingBottomRight || options.padding || [0, 0]), pixelCenter = this.project(this.getCenter()), pixelPoint = this.project(latlng), pixelBounds = this.getPixelBounds(), paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]), paddedSize = paddedBounds.getSize();
          if (!paddedBounds.contains(pixelPoint)) {
            this._enforcingBounds = true;
            var centerOffset = pixelPoint.subtract(paddedBounds.getCenter());
            var offset = paddedBounds.extend(pixelPoint).getSize().subtract(paddedSize);
            pixelCenter.x += centerOffset.x < 0 ? -offset.x : offset.x;
            pixelCenter.y += centerOffset.y < 0 ? -offset.y : offset.y;
            this.panTo(this.unproject(pixelCenter), options);
            this._enforcingBounds = false;
          }
          return this;
        },
        invalidateSize: function(options) {
          if (!this._loaded) {
            return this;
          }
          options = extend({
            animate: false,
            pan: true
          }, options === true ? { animate: true } : options);
          var oldSize = this.getSize();
          this._sizeChanged = true;
          this._lastCenter = null;
          var newSize = this.getSize(), oldCenter = oldSize.divideBy(2).round(), newCenter = newSize.divideBy(2).round(), offset = oldCenter.subtract(newCenter);
          if (!offset.x && !offset.y) {
            return this;
          }
          if (options.animate && options.pan) {
            this.panBy(offset);
          } else {
            if (options.pan) {
              this._rawPanBy(offset);
            }
            this.fire("move");
            if (options.debounceMoveend) {
              clearTimeout(this._sizeTimer);
              this._sizeTimer = setTimeout(bind(this.fire, this, "moveend"), 200);
            } else {
              this.fire("moveend");
            }
          }
          return this.fire("resize", {
            oldSize,
            newSize
          });
        },
        stop: function() {
          this.setZoom(this._limitZoom(this._zoom));
          if (!this.options.zoomSnap) {
            this.fire("viewreset");
          }
          return this._stop();
        },
        locate: function(options) {
          options = this._locateOptions = extend({
            timeout: 1e4,
            watch: false
          }, options);
          if (!("geolocation" in navigator)) {
            this._handleGeolocationError({
              code: 0,
              message: "Geolocation not supported."
            });
            return this;
          }
          var onResponse = bind(this._handleGeolocationResponse, this), onError = bind(this._handleGeolocationError, this);
          if (options.watch) {
            this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options);
          } else {
            navigator.geolocation.getCurrentPosition(onResponse, onError, options);
          }
          return this;
        },
        stopLocate: function() {
          if (navigator.geolocation && navigator.geolocation.clearWatch) {
            navigator.geolocation.clearWatch(this._locationWatchId);
          }
          if (this._locateOptions) {
            this._locateOptions.setView = false;
          }
          return this;
        },
        _handleGeolocationError: function(error) {
          if (!this._container._leaflet_id) {
            return;
          }
          var c = error.code, message = error.message || (c === 1 ? "permission denied" : c === 2 ? "position unavailable" : "timeout");
          if (this._locateOptions.setView && !this._loaded) {
            this.fitWorld();
          }
          this.fire("locationerror", {
            code: c,
            message: "Geolocation error: " + message + "."
          });
        },
        _handleGeolocationResponse: function(pos) {
          if (!this._container._leaflet_id) {
            return;
          }
          var lat = pos.coords.latitude, lng = pos.coords.longitude, latlng = new LatLng(lat, lng), bounds = latlng.toBounds(pos.coords.accuracy * 2), options = this._locateOptions;
          if (options.setView) {
            var zoom2 = this.getBoundsZoom(bounds);
            this.setView(latlng, options.maxZoom ? Math.min(zoom2, options.maxZoom) : zoom2);
          }
          var data = {
            latlng,
            bounds,
            timestamp: pos.timestamp
          };
          for (var i in pos.coords) {
            if (typeof pos.coords[i] === "number") {
              data[i] = pos.coords[i];
            }
          }
          this.fire("locationfound", data);
        },
        addHandler: function(name, HandlerClass) {
          if (!HandlerClass) {
            return this;
          }
          var handler = this[name] = new HandlerClass(this);
          this._handlers.push(handler);
          if (this.options[name]) {
            handler.enable();
          }
          return this;
        },
        remove: function() {
          this._initEvents(true);
          if (this.options.maxBounds) {
            this.off("moveend", this._panInsideMaxBounds);
          }
          if (this._containerId !== this._container._leaflet_id) {
            throw new Error("Map container is being reused by another instance");
          }
          try {
            delete this._container._leaflet_id;
            delete this._containerId;
          } catch (e) {
            this._container._leaflet_id = void 0;
            this._containerId = void 0;
          }
          if (this._locationWatchId !== void 0) {
            this.stopLocate();
          }
          this._stop();
          remove(this._mapPane);
          if (this._clearControlPos) {
            this._clearControlPos();
          }
          if (this._resizeRequest) {
            cancelAnimFrame(this._resizeRequest);
            this._resizeRequest = null;
          }
          this._clearHandlers();
          if (this._loaded) {
            this.fire("unload");
          }
          var i;
          for (i in this._layers) {
            this._layers[i].remove();
          }
          for (i in this._panes) {
            remove(this._panes[i]);
          }
          this._layers = [];
          this._panes = [];
          delete this._mapPane;
          delete this._renderer;
          return this;
        },
        createPane: function(name, container) {
          var className = "leaflet-pane" + (name ? " leaflet-" + name.replace("Pane", "") + "-pane" : ""), pane = create$1("div", className, container || this._mapPane);
          if (name) {
            this._panes[name] = pane;
          }
          return pane;
        },
        getCenter: function() {
          this._checkIfLoaded();
          if (this._lastCenter && !this._moved()) {
            return this._lastCenter.clone();
          }
          return this.layerPointToLatLng(this._getCenterLayerPoint());
        },
        getZoom: function() {
          return this._zoom;
        },
        getBounds: function() {
          var bounds = this.getPixelBounds(), sw = this.unproject(bounds.getBottomLeft()), ne = this.unproject(bounds.getTopRight());
          return new LatLngBounds2(sw, ne);
        },
        getMinZoom: function() {
          return this.options.minZoom === void 0 ? this._layersMinZoom || 0 : this.options.minZoom;
        },
        getMaxZoom: function() {
          return this.options.maxZoom === void 0 ? this._layersMaxZoom === void 0 ? Infinity : this._layersMaxZoom : this.options.maxZoom;
        },
        getBoundsZoom: function(bounds, inside, padding) {
          bounds = toLatLngBounds(bounds);
          padding = toPoint2(padding || [0, 0]);
          var zoom2 = this.getZoom() || 0, min = this.getMinZoom(), max = this.getMaxZoom(), nw = bounds.getNorthWest(), se = bounds.getSouthEast(), size = this.getSize().subtract(padding), boundsSize = toBounds(this.project(se, zoom2), this.project(nw, zoom2)).getSize(), snap2 = Browser2.any3d ? this.options.zoomSnap : 1, scalex = size.x / boundsSize.x, scaley = size.y / boundsSize.y, scale2 = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);
          zoom2 = this.getScaleZoom(scale2, zoom2);
          if (snap2) {
            zoom2 = Math.round(zoom2 / (snap2 / 100)) * (snap2 / 100);
            zoom2 = inside ? Math.ceil(zoom2 / snap2) * snap2 : Math.floor(zoom2 / snap2) * snap2;
          }
          return Math.max(min, Math.min(max, zoom2));
        },
        getSize: function() {
          if (!this._size || this._sizeChanged) {
            this._size = new Point2(
              this._container.clientWidth || 0,
              this._container.clientHeight || 0
            );
            this._sizeChanged = false;
          }
          return this._size.clone();
        },
        getPixelBounds: function(center, zoom2) {
          var topLeftPoint = this._getTopLeftPoint(center, zoom2);
          return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
        },
        getPixelOrigin: function() {
          this._checkIfLoaded();
          return this._pixelOrigin;
        },
        getPixelWorldBounds: function(zoom2) {
          return this.options.crs.getProjectedBounds(zoom2 === void 0 ? this.getZoom() : zoom2);
        },
        getPane: function(pane) {
          return typeof pane === "string" ? this._panes[pane] : pane;
        },
        getPanes: function() {
          return this._panes;
        },
        getContainer: function() {
          return this._container;
        },
        getZoomScale: function(toZoom, fromZoom) {
          var crs = this.options.crs;
          fromZoom = fromZoom === void 0 ? this._zoom : fromZoom;
          return crs.scale(toZoom) / crs.scale(fromZoom);
        },
        getScaleZoom: function(scale2, fromZoom) {
          var crs = this.options.crs;
          fromZoom = fromZoom === void 0 ? this._zoom : fromZoom;
          var zoom2 = crs.zoom(scale2 * crs.scale(fromZoom));
          return isNaN(zoom2) ? Infinity : zoom2;
        },
        project: function(latlng, zoom2) {
          zoom2 = zoom2 === void 0 ? this._zoom : zoom2;
          return this.options.crs.latLngToPoint(toLatLng(latlng), zoom2);
        },
        unproject: function(point3, zoom2) {
          zoom2 = zoom2 === void 0 ? this._zoom : zoom2;
          return this.options.crs.pointToLatLng(toPoint2(point3), zoom2);
        },
        layerPointToLatLng: function(point3) {
          var projectedPoint = toPoint2(point3).add(this.getPixelOrigin());
          return this.unproject(projectedPoint);
        },
        latLngToLayerPoint: function(latlng) {
          var projectedPoint = this.project(toLatLng(latlng))._round();
          return projectedPoint._subtract(this.getPixelOrigin());
        },
        wrapLatLng: function(latlng) {
          return this.options.crs.wrapLatLng(toLatLng(latlng));
        },
        wrapLatLngBounds: function(latlng) {
          return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));
        },
        distance: function(latlng1, latlng2) {
          return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));
        },
        containerPointToLayerPoint: function(point3) {
          return toPoint2(point3).subtract(this._getMapPanePos());
        },
        layerPointToContainerPoint: function(point3) {
          return toPoint2(point3).add(this._getMapPanePos());
        },
        containerPointToLatLng: function(point3) {
          var layerPoint = this.containerPointToLayerPoint(toPoint2(point3));
          return this.layerPointToLatLng(layerPoint);
        },
        latLngToContainerPoint: function(latlng) {
          return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));
        },
        mouseEventToContainerPoint: function(e) {
          return getMousePosition(e, this._container);
        },
        mouseEventToLayerPoint: function(e) {
          return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
        },
        mouseEventToLatLng: function(e) {
          return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
        },
        _initContainer: function(id) {
          var container = this._container = get2(id);
          if (!container) {
            throw new Error("Map container not found.");
          } else if (container._leaflet_id) {
            throw new Error("Map container is already initialized.");
          }
          on(container, "scroll", this._onScroll, this);
          this._containerId = stamp(container);
        },
        _initLayout: function() {
          var container = this._container;
          this._fadeAnimated = this.options.fadeAnimation && Browser2.any3d;
          addClass(container, "leaflet-container" + (Browser2.touch ? " leaflet-touch" : "") + (Browser2.retina ? " leaflet-retina" : "") + (Browser2.ielt9 ? " leaflet-oldie" : "") + (Browser2.safari ? " leaflet-safari" : "") + (this._fadeAnimated ? " leaflet-fade-anim" : ""));
          var position = getStyle(container, "position");
          if (position !== "absolute" && position !== "relative" && position !== "fixed" && position !== "sticky") {
            container.style.position = "relative";
          }
          this._initPanes();
          if (this._initControlPos) {
            this._initControlPos();
          }
        },
        _initPanes: function() {
          var panes = this._panes = {};
          this._paneRenderers = {};
          this._mapPane = this.createPane("mapPane", this._container);
          setPosition(this._mapPane, new Point2(0, 0));
          this.createPane("tilePane");
          this.createPane("overlayPane");
          this.createPane("shadowPane");
          this.createPane("markerPane");
          this.createPane("tooltipPane");
          this.createPane("popupPane");
          if (!this.options.markerZoomAnimation) {
            addClass(panes.markerPane, "leaflet-zoom-hide");
            addClass(panes.shadowPane, "leaflet-zoom-hide");
          }
        },
        _resetView: function(center, zoom2, noMoveStart) {
          setPosition(this._mapPane, new Point2(0, 0));
          var loading = !this._loaded;
          this._loaded = true;
          zoom2 = this._limitZoom(zoom2);
          this.fire("viewprereset");
          var zoomChanged = this._zoom !== zoom2;
          this._moveStart(zoomChanged, noMoveStart)._move(center, zoom2)._moveEnd(zoomChanged);
          this.fire("viewreset");
          if (loading) {
            this.fire("load");
          }
        },
        _moveStart: function(zoomChanged, noMoveStart) {
          if (zoomChanged) {
            this.fire("zoomstart");
          }
          if (!noMoveStart) {
            this.fire("movestart");
          }
          return this;
        },
        _move: function(center, zoom2, data, supressEvent) {
          if (zoom2 === void 0) {
            zoom2 = this._zoom;
          }
          var zoomChanged = this._zoom !== zoom2;
          this._zoom = zoom2;
          this._lastCenter = center;
          this._pixelOrigin = this._getNewPixelOrigin(center);
          if (!supressEvent) {
            if (zoomChanged || data && data.pinch) {
              this.fire("zoom", data);
            }
            this.fire("move", data);
          } else if (data && data.pinch) {
            this.fire("zoom", data);
          }
          return this;
        },
        _moveEnd: function(zoomChanged) {
          if (zoomChanged) {
            this.fire("zoomend");
          }
          return this.fire("moveend");
        },
        _stop: function() {
          cancelAnimFrame(this._flyToFrame);
          if (this._panAnim) {
            this._panAnim.stop();
          }
          return this;
        },
        _rawPanBy: function(offset) {
          setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
        },
        _getZoomSpan: function() {
          return this.getMaxZoom() - this.getMinZoom();
        },
        _panInsideMaxBounds: function() {
          if (!this._enforcingBounds) {
            this.panInsideBounds(this.options.maxBounds);
          }
        },
        _checkIfLoaded: function() {
          if (!this._loaded) {
            throw new Error("Set map center and zoom first.");
          }
        },
        _initEvents: function(remove2) {
          this._targets = {};
          this._targets[stamp(this._container)] = this;
          var onOff = remove2 ? off : on;
          onOff(this._container, "click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress keydown keyup", this._handleDOMEvent, this);
          if (this.options.trackResize) {
            onOff(window, "resize", this._onResize, this);
          }
          if (Browser2.any3d && this.options.transform3DLimit) {
            (remove2 ? this.off : this.on).call(this, "moveend", this._onMoveEnd);
          }
        },
        _onResize: function() {
          cancelAnimFrame(this._resizeRequest);
          this._resizeRequest = requestAnimFrame(
            function() {
              this.invalidateSize({ debounceMoveend: true });
            },
            this
          );
        },
        _onScroll: function() {
          this._container.scrollTop = 0;
          this._container.scrollLeft = 0;
        },
        _onMoveEnd: function() {
          var pos = this._getMapPanePos();
          if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
            this._resetView(this.getCenter(), this.getZoom());
          }
        },
        _findEventTargets: function(e, type) {
          var targets = [], target, isHover = type === "mouseout" || type === "mouseover", src = e.target || e.srcElement, dragging = false;
          while (src) {
            target = this._targets[stamp(src)];
            if (target && (type === "click" || type === "preclick") && this._draggableMoved(target)) {
              dragging = true;
              break;
            }
            if (target && target.listens(type, true)) {
              if (isHover && !isExternalTarget(src, e)) {
                break;
              }
              targets.push(target);
              if (isHover) {
                break;
              }
            }
            if (src === this._container) {
              break;
            }
            src = src.parentNode;
          }
          if (!targets.length && !dragging && !isHover && this.listens(type, true)) {
            targets = [this];
          }
          return targets;
        },
        _isClickDisabled: function(el) {
          while (el && el !== this._container) {
            if (el["_leaflet_disable_click"]) {
              return true;
            }
            el = el.parentNode;
          }
        },
        _handleDOMEvent: function(e) {
          var el = e.target || e.srcElement;
          if (!this._loaded || el["_leaflet_disable_events"] || e.type === "click" && this._isClickDisabled(el)) {
            return;
          }
          var type = e.type;
          if (type === "mousedown") {
            preventOutline(el);
          }
          this._fireDOMEvent(e, type);
        },
        _mouseEvents: ["click", "dblclick", "mouseover", "mouseout", "contextmenu"],
        _fireDOMEvent: function(e, type, canvasTargets) {
          if (e.type === "click") {
            var synth = extend({}, e);
            synth.type = "preclick";
            this._fireDOMEvent(synth, synth.type, canvasTargets);
          }
          var targets = this._findEventTargets(e, type);
          if (canvasTargets) {
            var filtered = [];
            for (var i = 0; i < canvasTargets.length; i++) {
              if (canvasTargets[i].listens(type, true)) {
                filtered.push(canvasTargets[i]);
              }
            }
            targets = filtered.concat(targets);
          }
          if (!targets.length) {
            return;
          }
          if (type === "contextmenu") {
            preventDefault(e);
          }
          var target = targets[0];
          var data = {
            originalEvent: e
          };
          if (e.type !== "keypress" && e.type !== "keydown" && e.type !== "keyup") {
            var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);
            data.containerPoint = isMarker ? this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
            data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
            data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
          }
          for (i = 0; i < targets.length; i++) {
            targets[i].fire(type, data, true);
            if (data.originalEvent._stopped || targets[i].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1) {
              return;
            }
          }
        },
        _draggableMoved: function(obj2) {
          obj2 = obj2.dragging && obj2.dragging.enabled() ? obj2 : this;
          return obj2.dragging && obj2.dragging.moved() || this.boxZoom && this.boxZoom.moved();
        },
        _clearHandlers: function() {
          for (var i = 0, len = this._handlers.length; i < len; i++) {
            this._handlers[i].disable();
          }
        },
        whenReady: function(callback, context) {
          if (this._loaded) {
            callback.call(context || this, { target: this });
          } else {
            this.on("load", callback, context);
          }
          return this;
        },
        _getMapPanePos: function() {
          return getPosition(this._mapPane) || new Point2(0, 0);
        },
        _moved: function() {
          var pos = this._getMapPanePos();
          return pos && !pos.equals([0, 0]);
        },
        _getTopLeftPoint: function(center, zoom2) {
          var pixelOrigin = center && zoom2 !== void 0 ? this._getNewPixelOrigin(center, zoom2) : this.getPixelOrigin();
          return pixelOrigin.subtract(this._getMapPanePos());
        },
        _getNewPixelOrigin: function(center, zoom2) {
          var viewHalf = this.getSize()._divideBy(2);
          return this.project(center, zoom2)._subtract(viewHalf)._add(this._getMapPanePos())._round();
        },
        _latLngToNewLayerPoint: function(latlng, zoom2, center) {
          var topLeft = this._getNewPixelOrigin(center, zoom2);
          return this.project(latlng, zoom2)._subtract(topLeft);
        },
        _latLngBoundsToNewLayerBounds: function(latLngBounds2, zoom2, center) {
          var topLeft = this._getNewPixelOrigin(center, zoom2);
          return toBounds([
            this.project(latLngBounds2.getSouthWest(), zoom2)._subtract(topLeft),
            this.project(latLngBounds2.getNorthWest(), zoom2)._subtract(topLeft),
            this.project(latLngBounds2.getSouthEast(), zoom2)._subtract(topLeft),
            this.project(latLngBounds2.getNorthEast(), zoom2)._subtract(topLeft)
          ]);
        },
        _getCenterLayerPoint: function() {
          return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
        },
        _getCenterOffset: function(latlng) {
          return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
        },
        _limitCenter: function(center, zoom2, bounds) {
          if (!bounds) {
            return center;
          }
          var centerPoint = this.project(center, zoom2), viewHalf = this.getSize().divideBy(2), viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)), offset = this._getBoundsOffset(viewBounds, bounds, zoom2);
          if (Math.abs(offset.x) <= 1 && Math.abs(offset.y) <= 1) {
            return center;
          }
          return this.unproject(centerPoint.add(offset), zoom2);
        },
        _limitOffset: function(offset, bounds) {
          if (!bounds) {
            return offset;
          }
          var viewBounds = this.getPixelBounds(), newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));
          return offset.add(this._getBoundsOffset(newBounds, bounds));
        },
        _getBoundsOffset: function(pxBounds, maxBounds, zoom2) {
          var projectedMaxBounds = toBounds(
            this.project(maxBounds.getNorthEast(), zoom2),
            this.project(maxBounds.getSouthWest(), zoom2)
          ), minOffset = projectedMaxBounds.min.subtract(pxBounds.min), maxOffset = projectedMaxBounds.max.subtract(pxBounds.max), dx = this._rebound(minOffset.x, -maxOffset.x), dy = this._rebound(minOffset.y, -maxOffset.y);
          return new Point2(dx, dy);
        },
        _rebound: function(left, right) {
          return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
        },
        _limitZoom: function(zoom2) {
          var min = this.getMinZoom(), max = this.getMaxZoom(), snap2 = Browser2.any3d ? this.options.zoomSnap : 1;
          if (snap2) {
            zoom2 = Math.round(zoom2 / snap2) * snap2;
          }
          return Math.max(min, Math.min(max, zoom2));
        },
        _onPanTransitionStep: function() {
          this.fire("move");
        },
        _onPanTransitionEnd: function() {
          removeClass(this._mapPane, "leaflet-pan-anim");
          this.fire("moveend");
        },
        _tryAnimatedPan: function(center, options) {
          var offset = this._getCenterOffset(center)._trunc();
          if ((options && options.animate) !== true && !this.getSize().contains(offset)) {
            return false;
          }
          this.panBy(offset, options);
          return true;
        },
        _createAnimProxy: function() {
          var proxy = this._proxy = create$1("div", "leaflet-proxy leaflet-zoom-animated");
          this._panes.mapPane.appendChild(proxy);
          this.on("zoomanim", function(e) {
            var prop = TRANSFORM, transform2 = this._proxy.style[prop];
            setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));
            if (transform2 === this._proxy.style[prop] && this._animatingZoom) {
              this._onZoomTransitionEnd();
            }
          }, this);
          this.on("load moveend", this._animMoveEnd, this);
          this._on("unload", this._destroyAnimProxy, this);
        },
        _destroyAnimProxy: function() {
          remove(this._proxy);
          this.off("load moveend", this._animMoveEnd, this);
          delete this._proxy;
        },
        _animMoveEnd: function() {
          var c = this.getCenter(), z = this.getZoom();
          setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));
        },
        _catchTransitionEnd: function(e) {
          if (this._animatingZoom && e.propertyName.indexOf("transform") >= 0) {
            this._onZoomTransitionEnd();
          }
        },
        _nothingToAnimate: function() {
          return !this._container.getElementsByClassName("leaflet-zoom-animated").length;
        },
        _tryAnimatedZoom: function(center, zoom2, options) {
          if (this._animatingZoom) {
            return true;
          }
          options = options || {};
          if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() || Math.abs(zoom2 - this._zoom) > this.options.zoomAnimationThreshold) {
            return false;
          }
          var scale2 = this.getZoomScale(zoom2), offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale2);
          if (options.animate !== true && !this.getSize().contains(offset)) {
            return false;
          }
          requestAnimFrame(function() {
            this._moveStart(true, options.noMoveStart || false)._animateZoom(center, zoom2, true);
          }, this);
          return true;
        },
        _animateZoom: function(center, zoom2, startAnim, noUpdate) {
          if (!this._mapPane) {
            return;
          }
          if (startAnim) {
            this._animatingZoom = true;
            this._animateToCenter = center;
            this._animateToZoom = zoom2;
            addClass(this._mapPane, "leaflet-zoom-anim");
          }
          this.fire("zoomanim", {
            center,
            zoom: zoom2,
            noUpdate
          });
          if (!this._tempFireZoomEvent) {
            this._tempFireZoomEvent = this._zoom !== this._animateToZoom;
          }
          this._move(this._animateToCenter, this._animateToZoom, void 0, true);
          setTimeout(bind(this._onZoomTransitionEnd, this), 250);
        },
        _onZoomTransitionEnd: function() {
          if (!this._animatingZoom) {
            return;
          }
          if (this._mapPane) {
            removeClass(this._mapPane, "leaflet-zoom-anim");
          }
          this._animatingZoom = false;
          this._move(this._animateToCenter, this._animateToZoom, void 0, true);
          if (this._tempFireZoomEvent) {
            this.fire("zoom");
          }
          delete this._tempFireZoomEvent;
          this.fire("move");
          this._moveEnd(true);
        }
      });
      function createMap(id, options) {
        return new Map(id, options);
      }
      var Control = Class.extend({
        options: {
          position: "topright"
        },
        initialize: function(options) {
          setOptions(this, options);
        },
        getPosition: function() {
          return this.options.position;
        },
        setPosition: function(position) {
          var map = this._map;
          if (map) {
            map.removeControl(this);
          }
          this.options.position = position;
          if (map) {
            map.addControl(this);
          }
          return this;
        },
        getContainer: function() {
          return this._container;
        },
        addTo: function(map) {
          this.remove();
          this._map = map;
          var container = this._container = this.onAdd(map), pos = this.getPosition(), corner = map._controlCorners[pos];
          addClass(container, "leaflet-control");
          if (pos.indexOf("bottom") !== -1) {
            corner.insertBefore(container, corner.firstChild);
          } else {
            corner.appendChild(container);
          }
          this._map.on("unload", this.remove, this);
          return this;
        },
        remove: function() {
          if (!this._map) {
            return this;
          }
          remove(this._container);
          if (this.onRemove) {
            this.onRemove(this._map);
          }
          this._map.off("unload", this.remove, this);
          this._map = null;
          return this;
        },
        _refocusOnMap: function(e) {
          if (this._map && e && e.screenX > 0 && e.screenY > 0) {
            this._map.getContainer().focus();
          }
        }
      });
      var control = function(options) {
        return new Control(options);
      };
      Map.include({
        addControl: function(control2) {
          control2.addTo(this);
          return this;
        },
        removeControl: function(control2) {
          control2.remove();
          return this;
        },
        _initControlPos: function() {
          var corners = this._controlCorners = {}, l = "leaflet-", container = this._controlContainer = create$1("div", l + "control-container", this._container);
          function createCorner(vSide, hSide) {
            var className = l + vSide + " " + l + hSide;
            corners[vSide + hSide] = create$1("div", className, container);
          }
          createCorner("top", "left");
          createCorner("top", "right");
          createCorner("bottom", "left");
          createCorner("bottom", "right");
        },
        _clearControlPos: function() {
          for (var i in this._controlCorners) {
            remove(this._controlCorners[i]);
          }
          remove(this._controlContainer);
          delete this._controlCorners;
          delete this._controlContainer;
        }
      });
      var Layers = Control.extend({
        options: {
          collapsed: true,
          position: "topright",
          autoZIndex: true,
          hideSingleBase: false,
          sortLayers: false,
          sortFunction: function(layerA, layerB, nameA, nameB) {
            return nameA < nameB ? -1 : nameB < nameA ? 1 : 0;
          }
        },
        initialize: function(baseLayers, overlays, options) {
          setOptions(this, options);
          this._layerControlInputs = [];
          this._layers = [];
          this._lastZIndex = 0;
          this._handlingClick = false;
          this._preventClick = false;
          for (var i in baseLayers) {
            this._addLayer(baseLayers[i], i);
          }
          for (i in overlays) {
            this._addLayer(overlays[i], i, true);
          }
        },
        onAdd: function(map) {
          this._initLayout();
          this._update();
          this._map = map;
          map.on("zoomend", this._checkDisabledLayers, this);
          for (var i = 0; i < this._layers.length; i++) {
            this._layers[i].layer.on("add remove", this._onLayerChange, this);
          }
          return this._container;
        },
        addTo: function(map) {
          Control.prototype.addTo.call(this, map);
          return this._expandIfNotCollapsed();
        },
        onRemove: function() {
          this._map.off("zoomend", this._checkDisabledLayers, this);
          for (var i = 0; i < this._layers.length; i++) {
            this._layers[i].layer.off("add remove", this._onLayerChange, this);
          }
        },
        addBaseLayer: function(layer, name) {
          this._addLayer(layer, name);
          return this._map ? this._update() : this;
        },
        addOverlay: function(layer, name) {
          this._addLayer(layer, name, true);
          return this._map ? this._update() : this;
        },
        removeLayer: function(layer) {
          layer.off("add remove", this._onLayerChange, this);
          var obj2 = this._getLayer(stamp(layer));
          if (obj2) {
            this._layers.splice(this._layers.indexOf(obj2), 1);
          }
          return this._map ? this._update() : this;
        },
        expand: function() {
          addClass(this._container, "leaflet-control-layers-expanded");
          this._section.style.height = null;
          var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
          if (acceptableHeight < this._section.clientHeight) {
            addClass(this._section, "leaflet-control-layers-scrollbar");
            this._section.style.height = acceptableHeight + "px";
          } else {
            removeClass(this._section, "leaflet-control-layers-scrollbar");
          }
          this._checkDisabledLayers();
          return this;
        },
        collapse: function() {
          removeClass(this._container, "leaflet-control-layers-expanded");
          return this;
        },
        _initLayout: function() {
          var className = "leaflet-control-layers", container = this._container = create$1("div", className), collapsed = this.options.collapsed;
          container.setAttribute("aria-haspopup", true);
          disableClickPropagation(container);
          disableScrollPropagation(container);
          var section = this._section = create$1("section", className + "-list");
          if (collapsed) {
            this._map.on("click", this.collapse, this);
            on(container, {
              mouseenter: this._expandSafely,
              mouseleave: this.collapse
            }, this);
          }
          var link = this._layersLink = create$1("a", className + "-toggle", container);
          link.href = "#";
          link.title = "Layers";
          link.setAttribute("role", "button");
          on(link, {
            keydown: function(e) {
              if (e.keyCode === 13) {
                this._expandSafely();
              }
            },
            click: function(e) {
              preventDefault(e);
              this._expandSafely();
            }
          }, this);
          if (!collapsed) {
            this.expand();
          }
          this._baseLayersList = create$1("div", className + "-base", section);
          this._separator = create$1("div", className + "-separator", section);
          this._overlaysList = create$1("div", className + "-overlays", section);
          container.appendChild(section);
        },
        _getLayer: function(id) {
          for (var i = 0; i < this._layers.length; i++) {
            if (this._layers[i] && stamp(this._layers[i].layer) === id) {
              return this._layers[i];
            }
          }
        },
        _addLayer: function(layer, name, overlay) {
          if (this._map) {
            layer.on("add remove", this._onLayerChange, this);
          }
          this._layers.push({
            layer,
            name,
            overlay
          });
          if (this.options.sortLayers) {
            this._layers.sort(bind(function(a, b) {
              return this.options.sortFunction(a.layer, b.layer, a.name, b.name);
            }, this));
          }
          if (this.options.autoZIndex && layer.setZIndex) {
            this._lastZIndex++;
            layer.setZIndex(this._lastZIndex);
          }
          this._expandIfNotCollapsed();
        },
        _update: function() {
          if (!this._container) {
            return this;
          }
          empty(this._baseLayersList);
          empty(this._overlaysList);
          this._layerControlInputs = [];
          var baseLayersPresent, overlaysPresent, i, obj2, baseLayersCount = 0;
          for (i = 0; i < this._layers.length; i++) {
            obj2 = this._layers[i];
            this._addItem(obj2);
            overlaysPresent = overlaysPresent || obj2.overlay;
            baseLayersPresent = baseLayersPresent || !obj2.overlay;
            baseLayersCount += !obj2.overlay ? 1 : 0;
          }
          if (this.options.hideSingleBase) {
            baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
            this._baseLayersList.style.display = baseLayersPresent ? "" : "none";
          }
          this._separator.style.display = overlaysPresent && baseLayersPresent ? "" : "none";
          return this;
        },
        _onLayerChange: function(e) {
          if (!this._handlingClick) {
            this._update();
          }
          var obj2 = this._getLayer(stamp(e.target));
          var type = obj2.overlay ? e.type === "add" ? "overlayadd" : "overlayremove" : e.type === "add" ? "baselayerchange" : null;
          if (type) {
            this._map.fire(type, obj2);
          }
        },
        _createRadioElement: function(name, checked) {
          var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' + name + '"' + (checked ? ' checked="checked"' : "") + "/>";
          var radioFragment = document.createElement("div");
          radioFragment.innerHTML = radioHtml;
          return radioFragment.firstChild;
        },
        _addItem: function(obj2) {
          var label = document.createElement("label"), checked = this._map.hasLayer(obj2.layer), input;
          if (obj2.overlay) {
            input = document.createElement("input");
            input.type = "checkbox";
            input.className = "leaflet-control-layers-selector";
            input.defaultChecked = checked;
          } else {
            input = this._createRadioElement("leaflet-base-layers_" + stamp(this), checked);
          }
          this._layerControlInputs.push(input);
          input.layerId = stamp(obj2.layer);
          on(input, "click", this._onInputClick, this);
          var name = document.createElement("span");
          name.innerHTML = " " + obj2.name;
          var holder = document.createElement("span");
          label.appendChild(holder);
          holder.appendChild(input);
          holder.appendChild(name);
          var container = obj2.overlay ? this._overlaysList : this._baseLayersList;
          container.appendChild(label);
          this._checkDisabledLayers();
          return label;
        },
        _onInputClick: function() {
          if (this._preventClick) {
            return;
          }
          var inputs = this._layerControlInputs, input, layer;
          var addedLayers = [], removedLayers = [];
          this._handlingClick = true;
          for (var i = inputs.length - 1; i >= 0; i--) {
            input = inputs[i];
            layer = this._getLayer(input.layerId).layer;
            if (input.checked) {
              addedLayers.push(layer);
            } else if (!input.checked) {
              removedLayers.push(layer);
            }
          }
          for (i = 0; i < removedLayers.length; i++) {
            if (this._map.hasLayer(removedLayers[i])) {
              this._map.removeLayer(removedLayers[i]);
            }
          }
          for (i = 0; i < addedLayers.length; i++) {
            if (!this._map.hasLayer(addedLayers[i])) {
              this._map.addLayer(addedLayers[i]);
            }
          }
          this._handlingClick = false;
          this._refocusOnMap();
        },
        _checkDisabledLayers: function() {
          var inputs = this._layerControlInputs, input, layer, zoom2 = this._map.getZoom();
          for (var i = inputs.length - 1; i >= 0; i--) {
            input = inputs[i];
            layer = this._getLayer(input.layerId).layer;
            input.disabled = layer.options.minZoom !== void 0 && zoom2 < layer.options.minZoom || layer.options.maxZoom !== void 0 && zoom2 > layer.options.maxZoom;
          }
        },
        _expandIfNotCollapsed: function() {
          if (this._map && !this.options.collapsed) {
            this.expand();
          }
          return this;
        },
        _expandSafely: function() {
          var section = this._section;
          this._preventClick = true;
          on(section, "click", preventDefault);
          this.expand();
          var that = this;
          setTimeout(function() {
            off(section, "click", preventDefault);
            that._preventClick = false;
          });
        }
      });
      var layers = function(baseLayers, overlays, options) {
        return new Layers(baseLayers, overlays, options);
      };
      var Zoom = Control.extend({
        options: {
          position: "topleft",
          zoomInText: '<span aria-hidden="true">+</span>',
          zoomInTitle: "Zoom in",
          zoomOutText: '<span aria-hidden="true">&#x2212;</span>',
          zoomOutTitle: "Zoom out"
        },
        onAdd: function(map) {
          var zoomName = "leaflet-control-zoom", container = create$1("div", zoomName + " leaflet-bar"), options = this.options;
          this._zoomInButton = this._createButton(
            options.zoomInText,
            options.zoomInTitle,
            zoomName + "-in",
            container,
            this._zoomIn
          );
          this._zoomOutButton = this._createButton(
            options.zoomOutText,
            options.zoomOutTitle,
            zoomName + "-out",
            container,
            this._zoomOut
          );
          this._updateDisabled();
          map.on("zoomend zoomlevelschange", this._updateDisabled, this);
          return container;
        },
        onRemove: function(map) {
          map.off("zoomend zoomlevelschange", this._updateDisabled, this);
        },
        disable: function() {
          this._disabled = true;
          this._updateDisabled();
          return this;
        },
        enable: function() {
          this._disabled = false;
          this._updateDisabled();
          return this;
        },
        _zoomIn: function(e) {
          if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
            this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
          }
        },
        _zoomOut: function(e) {
          if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
            this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
          }
        },
        _createButton: function(html, title, className, container, fn) {
          var link = create$1("a", className, container);
          link.innerHTML = html;
          link.href = "#";
          link.title = title;
          link.setAttribute("role", "button");
          link.setAttribute("aria-label", title);
          disableClickPropagation(link);
          on(link, "click", stop);
          on(link, "click", fn, this);
          on(link, "click", this._refocusOnMap, this);
          return link;
        },
        _updateDisabled: function() {
          var map = this._map, className = "leaflet-disabled";
          removeClass(this._zoomInButton, className);
          removeClass(this._zoomOutButton, className);
          this._zoomInButton.setAttribute("aria-disabled", "false");
          this._zoomOutButton.setAttribute("aria-disabled", "false");
          if (this._disabled || map._zoom === map.getMinZoom()) {
            addClass(this._zoomOutButton, className);
            this._zoomOutButton.setAttribute("aria-disabled", "true");
          }
          if (this._disabled || map._zoom === map.getMaxZoom()) {
            addClass(this._zoomInButton, className);
            this._zoomInButton.setAttribute("aria-disabled", "true");
          }
        }
      });
      Map.mergeOptions({
        zoomControl: true
      });
      Map.addInitHook(function() {
        if (this.options.zoomControl) {
          this.zoomControl = new Zoom();
          this.addControl(this.zoomControl);
        }
      });
      var zoom = function(options) {
        return new Zoom(options);
      };
      var Scale = Control.extend({
        options: {
          position: "bottomleft",
          maxWidth: 100,
          metric: true,
          imperial: true
        },
        onAdd: function(map) {
          var className = "leaflet-control-scale", container = create$1("div", className), options = this.options;
          this._addScales(options, className + "-line", container);
          map.on(options.updateWhenIdle ? "moveend" : "move", this._update, this);
          map.whenReady(this._update, this);
          return container;
        },
        onRemove: function(map) {
          map.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this);
        },
        _addScales: function(options, className, container) {
          if (options.metric) {
            this._mScale = create$1("div", className, container);
          }
          if (options.imperial) {
            this._iScale = create$1("div", className, container);
          }
        },
        _update: function() {
          var map = this._map, y = map.getSize().y / 2;
          var maxMeters = map.distance(
            map.containerPointToLatLng([0, y]),
            map.containerPointToLatLng([this.options.maxWidth, y])
          );
          this._updateScales(maxMeters);
        },
        _updateScales: function(maxMeters) {
          if (this.options.metric && maxMeters) {
            this._updateMetric(maxMeters);
          }
          if (this.options.imperial && maxMeters) {
            this._updateImperial(maxMeters);
          }
        },
        _updateMetric: function(maxMeters) {
          var meters = this._getRoundNum(maxMeters), label = meters < 1e3 ? meters + " m" : meters / 1e3 + " km";
          this._updateScale(this._mScale, label, meters / maxMeters);
        },
        _updateImperial: function(maxMeters) {
          var maxFeet = maxMeters * 3.2808399, maxMiles, miles, feet;
          if (maxFeet > 5280) {
            maxMiles = maxFeet / 5280;
            miles = this._getRoundNum(maxMiles);
            this._updateScale(this._iScale, miles + " mi", miles / maxMiles);
          } else {
            feet = this._getRoundNum(maxFeet);
            this._updateScale(this._iScale, feet + " ft", feet / maxFeet);
          }
        },
        _updateScale: function(scale2, text, ratio) {
          scale2.style.width = Math.round(this.options.maxWidth * ratio) + "px";
          scale2.innerHTML = text;
        },
        _getRoundNum: function(num) {
          var pow10 = Math.pow(10, (Math.floor(num) + "").length - 1), d = num / pow10;
          d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;
          return pow10 * d;
        }
      });
      var scale = function(options) {
        return new Scale(options);
      };
      var ukrainianFlag = '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8" class="leaflet-attribution-flag"><path fill="#4C7BE1" d="M0 0h12v4H0z"/><path fill="#FFD500" d="M0 4h12v3H0z"/><path fill="#E0BC00" d="M0 7h12v1H0z"/></svg>';
      var Attribution = Control.extend({
        options: {
          position: "bottomright",
          prefix: '<a href="https://leafletjs.com" title="A JavaScript library for interactive maps">' + (Browser2.inlineSvg ? ukrainianFlag + " " : "") + "Leaflet</a>"
        },
        initialize: function(options) {
          setOptions(this, options);
          this._attributions = {};
        },
        onAdd: function(map) {
          map.attributionControl = this;
          this._container = create$1("div", "leaflet-control-attribution");
          disableClickPropagation(this._container);
          for (var i in map._layers) {
            if (map._layers[i].getAttribution) {
              this.addAttribution(map._layers[i].getAttribution());
            }
          }
          this._update();
          map.on("layeradd", this._addAttribution, this);
          return this._container;
        },
        onRemove: function(map) {
          map.off("layeradd", this._addAttribution, this);
        },
        _addAttribution: function(ev) {
          if (ev.layer.getAttribution) {
            this.addAttribution(ev.layer.getAttribution());
            ev.layer.once("remove", function() {
              this.removeAttribution(ev.layer.getAttribution());
            }, this);
          }
        },
        setPrefix: function(prefix) {
          this.options.prefix = prefix;
          this._update();
          return this;
        },
        addAttribution: function(text) {
          if (!text) {
            return this;
          }
          if (!this._attributions[text]) {
            this._attributions[text] = 0;
          }
          this._attributions[text]++;
          this._update();
          return this;
        },
        removeAttribution: function(text) {
          if (!text) {
            return this;
          }
          if (this._attributions[text]) {
            this._attributions[text]--;
            this._update();
          }
          return this;
        },
        _update: function() {
          if (!this._map) {
            return;
          }
          var attribs = [];
          for (var i in this._attributions) {
            if (this._attributions[i]) {
              attribs.push(i);
            }
          }
          var prefixAndAttribs = [];
          if (this.options.prefix) {
            prefixAndAttribs.push(this.options.prefix);
          }
          if (attribs.length) {
            prefixAndAttribs.push(attribs.join(", "));
          }
          this._container.innerHTML = prefixAndAttribs.join(' <span aria-hidden="true">|</span> ');
        }
      });
      Map.mergeOptions({
        attributionControl: true
      });
      Map.addInitHook(function() {
        if (this.options.attributionControl) {
          new Attribution().addTo(this);
        }
      });
      var attribution = function(options) {
        return new Attribution(options);
      };
      Control.Layers = Layers;
      Control.Zoom = Zoom;
      Control.Scale = Scale;
      Control.Attribution = Attribution;
      control.layers = layers;
      control.zoom = zoom;
      control.scale = scale;
      control.attribution = attribution;
      var Handler = Class.extend({
        initialize: function(map) {
          this._map = map;
        },
        enable: function() {
          if (this._enabled) {
            return this;
          }
          this._enabled = true;
          this.addHooks();
          return this;
        },
        disable: function() {
          if (!this._enabled) {
            return this;
          }
          this._enabled = false;
          this.removeHooks();
          return this;
        },
        enabled: function() {
          return !!this._enabled;
        }
      });
      Handler.addTo = function(map, name) {
        map.addHandler(name, this);
        return this;
      };
      var Mixin = { Events };
      var START = Browser2.touch ? "touchstart mousedown" : "mousedown";
      var Draggable = Evented.extend({
        options: {
          clickTolerance: 3
        },
        initialize: function(element, dragStartTarget, preventOutline2, options) {
          setOptions(this, options);
          this._element = element;
          this._dragStartTarget = dragStartTarget || element;
          this._preventOutline = preventOutline2;
        },
        enable: function() {
          if (this._enabled) {
            return;
          }
          on(this._dragStartTarget, START, this._onDown, this);
          this._enabled = true;
        },
        disable: function() {
          if (!this._enabled) {
            return;
          }
          if (Draggable._dragging === this) {
            this.finishDrag(true);
          }
          off(this._dragStartTarget, START, this._onDown, this);
          this._enabled = false;
          this._moved = false;
        },
        _onDown: function(e) {
          if (!this._enabled) {
            return;
          }
          this._moved = false;
          if (hasClass(this._element, "leaflet-zoom-anim")) {
            return;
          }
          if (e.touches && e.touches.length !== 1) {
            if (Draggable._dragging === this) {
              this.finishDrag();
            }
            return;
          }
          if (Draggable._dragging || e.shiftKey || e.which !== 1 && e.button !== 1 && !e.touches) {
            return;
          }
          Draggable._dragging = this;
          if (this._preventOutline) {
            preventOutline(this._element);
          }
          disableImageDrag();
          disableTextSelection();
          if (this._moving) {
            return;
          }
          this.fire("down");
          var first = e.touches ? e.touches[0] : e, sizedParent = getSizedParentNode(this._element);
          this._startPoint = new Point2(first.clientX, first.clientY);
          this._startPos = getPosition(this._element);
          this._parentScale = getScale(sizedParent);
          var mouseevent = e.type === "mousedown";
          on(document, mouseevent ? "mousemove" : "touchmove", this._onMove, this);
          on(document, mouseevent ? "mouseup" : "touchend touchcancel", this._onUp, this);
        },
        _onMove: function(e) {
          if (!this._enabled) {
            return;
          }
          if (e.touches && e.touches.length > 1) {
            this._moved = true;
            return;
          }
          var first = e.touches && e.touches.length === 1 ? e.touches[0] : e, offset = new Point2(first.clientX, first.clientY)._subtract(this._startPoint);
          if (!offset.x && !offset.y) {
            return;
          }
          if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) {
            return;
          }
          offset.x /= this._parentScale.x;
          offset.y /= this._parentScale.y;
          preventDefault(e);
          if (!this._moved) {
            this.fire("dragstart");
            this._moved = true;
            addClass(document.body, "leaflet-dragging");
            this._lastTarget = e.target || e.srcElement;
            if (window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance) {
              this._lastTarget = this._lastTarget.correspondingUseElement;
            }
            addClass(this._lastTarget, "leaflet-drag-target");
          }
          this._newPos = this._startPos.add(offset);
          this._moving = true;
          this._lastEvent = e;
          this._updatePosition();
        },
        _updatePosition: function() {
          var e = { originalEvent: this._lastEvent };
          this.fire("predrag", e);
          setPosition(this._element, this._newPos);
          this.fire("drag", e);
        },
        _onUp: function() {
          if (!this._enabled) {
            return;
          }
          this.finishDrag();
        },
        finishDrag: function(noInertia) {
          removeClass(document.body, "leaflet-dragging");
          if (this._lastTarget) {
            removeClass(this._lastTarget, "leaflet-drag-target");
            this._lastTarget = null;
          }
          off(document, "mousemove touchmove", this._onMove, this);
          off(document, "mouseup touchend touchcancel", this._onUp, this);
          enableImageDrag();
          enableTextSelection();
          var fireDragend = this._moved && this._moving;
          this._moving = false;
          Draggable._dragging = false;
          if (fireDragend) {
            this.fire("dragend", {
              noInertia,
              distance: this._newPos.distanceTo(this._startPos)
            });
          }
        }
      });
      function clipPolygon(points, bounds, round) {
        var clippedPoints, edges = [1, 4, 2, 8], i, j, k, a, b, len, edge2, p;
        for (i = 0, len = points.length; i < len; i++) {
          points[i]._code = _getBitCode(points[i], bounds);
        }
        for (k = 0; k < 4; k++) {
          edge2 = edges[k];
          clippedPoints = [];
          for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
            a = points[i];
            b = points[j];
            if (!(a._code & edge2)) {
              if (b._code & edge2) {
                p = _getEdgeIntersection(b, a, edge2, bounds, round);
                p._code = _getBitCode(p, bounds);
                clippedPoints.push(p);
              }
              clippedPoints.push(a);
            } else if (!(b._code & edge2)) {
              p = _getEdgeIntersection(b, a, edge2, bounds, round);
              p._code = _getBitCode(p, bounds);
              clippedPoints.push(p);
            }
          }
          points = clippedPoints;
        }
        return points;
      }
      function polygonCenter(latlngs, crs) {
        var i, j, p1, p2, f, area, x, y, center;
        if (!latlngs || latlngs.length === 0) {
          throw new Error("latlngs not passed");
        }
        if (!isFlat(latlngs)) {
          console.warn("latlngs are not flat! Only the first ring will be used");
          latlngs = latlngs[0];
        }
        var centroidLatLng = toLatLng([0, 0]);
        var bounds = toLatLngBounds(latlngs);
        var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());
        if (areaBounds < 1700) {
          centroidLatLng = centroid(latlngs);
        }
        var len = latlngs.length;
        var points = [];
        for (i = 0; i < len; i++) {
          var latlng = toLatLng(latlngs[i]);
          points.push(crs.project(toLatLng([latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng])));
        }
        area = x = y = 0;
        for (i = 0, j = len - 1; i < len; j = i++) {
          p1 = points[i];
          p2 = points[j];
          f = p1.y * p2.x - p2.y * p1.x;
          x += (p1.x + p2.x) * f;
          y += (p1.y + p2.y) * f;
          area += f * 3;
        }
        if (area === 0) {
          center = points[0];
        } else {
          center = [x / area, y / area];
        }
        var latlngCenter = crs.unproject(toPoint2(center));
        return toLatLng([latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng]);
      }
      function centroid(coords) {
        var latSum = 0;
        var lngSum = 0;
        var len = 0;
        for (var i = 0; i < coords.length; i++) {
          var latlng = toLatLng(coords[i]);
          latSum += latlng.lat;
          lngSum += latlng.lng;
          len++;
        }
        return toLatLng([latSum / len, lngSum / len]);
      }
      var PolyUtil = {
        __proto__: null,
        clipPolygon,
        polygonCenter,
        centroid
      };
      function simplify(points, tolerance) {
        if (!tolerance || !points.length) {
          return points.slice();
        }
        var sqTolerance = tolerance * tolerance;
        points = _reducePoints(points, sqTolerance);
        points = _simplifyDP(points, sqTolerance);
        return points;
      }
      function pointToSegmentDistance(p, p1, p2) {
        return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));
      }
      function closestPointOnSegment(p, p1, p2) {
        return _sqClosestPointOnSegment(p, p1, p2);
      }
      function _simplifyDP(points, sqTolerance) {
        var len = points.length, ArrayConstructor = typeof Uint8Array !== void 0 + "" ? Uint8Array : Array, markers = new ArrayConstructor(len);
        markers[0] = markers[len - 1] = 1;
        _simplifyDPStep(points, markers, sqTolerance, 0, len - 1);
        var i, newPoints = [];
        for (i = 0; i < len; i++) {
          if (markers[i]) {
            newPoints.push(points[i]);
          }
        }
        return newPoints;
      }
      function _simplifyDPStep(points, markers, sqTolerance, first, last) {
        var maxSqDist = 0, index2, i, sqDist;
        for (i = first + 1; i <= last - 1; i++) {
          sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);
          if (sqDist > maxSqDist) {
            index2 = i;
            maxSqDist = sqDist;
          }
        }
        if (maxSqDist > sqTolerance) {
          markers[index2] = 1;
          _simplifyDPStep(points, markers, sqTolerance, first, index2);
          _simplifyDPStep(points, markers, sqTolerance, index2, last);
        }
      }
      function _reducePoints(points, sqTolerance) {
        var reducedPoints = [points[0]];
        for (var i = 1, prev = 0, len = points.length; i < len; i++) {
          if (_sqDist(points[i], points[prev]) > sqTolerance) {
            reducedPoints.push(points[i]);
            prev = i;
          }
        }
        if (prev < len - 1) {
          reducedPoints.push(points[len - 1]);
        }
        return reducedPoints;
      }
      var _lastCode;
      function clipSegment(a, b, bounds, useLastCode, round) {
        var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds), codeB = _getBitCode(b, bounds), codeOut, p, newCode;
        _lastCode = codeB;
        while (true) {
          if (!(codeA | codeB)) {
            return [a, b];
          }
          if (codeA & codeB) {
            return false;
          }
          codeOut = codeA || codeB;
          p = _getEdgeIntersection(a, b, codeOut, bounds, round);
          newCode = _getBitCode(p, bounds);
          if (codeOut === codeA) {
            a = p;
            codeA = newCode;
          } else {
            b = p;
            codeB = newCode;
          }
        }
      }
      function _getEdgeIntersection(a, b, code, bounds, round) {
        var dx = b.x - a.x, dy = b.y - a.y, min = bounds.min, max = bounds.max, x, y;
        if (code & 8) {
          x = a.x + dx * (max.y - a.y) / dy;
          y = max.y;
        } else if (code & 4) {
          x = a.x + dx * (min.y - a.y) / dy;
          y = min.y;
        } else if (code & 2) {
          x = max.x;
          y = a.y + dy * (max.x - a.x) / dx;
        } else if (code & 1) {
          x = min.x;
          y = a.y + dy * (min.x - a.x) / dx;
        }
        return new Point2(x, y, round);
      }
      function _getBitCode(p, bounds) {
        var code = 0;
        if (p.x < bounds.min.x) {
          code |= 1;
        } else if (p.x > bounds.max.x) {
          code |= 2;
        }
        if (p.y < bounds.min.y) {
          code |= 4;
        } else if (p.y > bounds.max.y) {
          code |= 8;
        }
        return code;
      }
      function _sqDist(p1, p2) {
        var dx = p2.x - p1.x, dy = p2.y - p1.y;
        return dx * dx + dy * dy;
      }
      function _sqClosestPointOnSegment(p, p1, p2, sqDist) {
        var x = p1.x, y = p1.y, dx = p2.x - x, dy = p2.y - y, dot = dx * dx + dy * dy, t;
        if (dot > 0) {
          t = ((p.x - x) * dx + (p.y - y) * dy) / dot;
          if (t > 1) {
            x = p2.x;
            y = p2.y;
          } else if (t > 0) {
            x += dx * t;
            y += dy * t;
          }
        }
        dx = p.x - x;
        dy = p.y - y;
        return sqDist ? dx * dx + dy * dy : new Point2(x, y);
      }
      function isFlat(latlngs) {
        return !isArray(latlngs[0]) || typeof latlngs[0][0] !== "object" && typeof latlngs[0][0] !== "undefined";
      }
      function _flat(latlngs) {
        console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead.");
        return isFlat(latlngs);
      }
      function polylineCenter(latlngs, crs) {
        var i, halfDist, segDist, dist, p1, p2, ratio, center;
        if (!latlngs || latlngs.length === 0) {
          throw new Error("latlngs not passed");
        }
        if (!isFlat(latlngs)) {
          console.warn("latlngs are not flat! Only the first ring will be used");
          latlngs = latlngs[0];
        }
        var centroidLatLng = toLatLng([0, 0]);
        var bounds = toLatLngBounds(latlngs);
        var areaBounds = bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest());
        if (areaBounds < 1700) {
          centroidLatLng = centroid(latlngs);
        }
        var len = latlngs.length;
        var points = [];
        for (i = 0; i < len; i++) {
          var latlng = toLatLng(latlngs[i]);
          points.push(crs.project(toLatLng([latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng])));
        }
        for (i = 0, halfDist = 0; i < len - 1; i++) {
          halfDist += points[i].distanceTo(points[i + 1]) / 2;
        }
        if (halfDist === 0) {
          center = points[0];
        } else {
          for (i = 0, dist = 0; i < len - 1; i++) {
            p1 = points[i];
            p2 = points[i + 1];
            segDist = p1.distanceTo(p2);
            dist += segDist;
            if (dist > halfDist) {
              ratio = (dist - halfDist) / segDist;
              center = [
                p2.x - ratio * (p2.x - p1.x),
                p2.y - ratio * (p2.y - p1.y)
              ];
              break;
            }
          }
        }
        var latlngCenter = crs.unproject(toPoint2(center));
        return toLatLng([latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng]);
      }
      var LineUtil = {
        __proto__: null,
        simplify,
        pointToSegmentDistance,
        closestPointOnSegment,
        clipSegment,
        _getEdgeIntersection,
        _getBitCode,
        _sqClosestPointOnSegment,
        isFlat,
        _flat,
        polylineCenter
      };
      var LonLat = {
        project: function(latlng) {
          return new Point2(latlng.lng, latlng.lat);
        },
        unproject: function(point3) {
          return new LatLng(point3.y, point3.x);
        },
        bounds: new Bounds([-180, -90], [180, 90])
      };
      var Mercator = {
        R: 6378137,
        R_MINOR: 6356752314245179e-9,
        bounds: new Bounds([-2003750834279e-5, -1549657073972e-5], [2003750834279e-5, 1876465623138e-5]),
        project: function(latlng) {
          var d = Math.PI / 180, r = this.R, y = latlng.lat * d, tmp = this.R_MINOR / r, e = Math.sqrt(1 - tmp * tmp), con = e * Math.sin(y);
          var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
          y = -r * Math.log(Math.max(ts, 1e-10));
          return new Point2(latlng.lng * d * r, y);
        },
        unproject: function(point3) {
          var d = 180 / Math.PI, r = this.R, tmp = this.R_MINOR / r, e = Math.sqrt(1 - tmp * tmp), ts = Math.exp(-point3.y / r), phi = Math.PI / 2 - 2 * Math.atan(ts);
          for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
            con = e * Math.sin(phi);
            con = Math.pow((1 - con) / (1 + con), e / 2);
            dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
            phi += dphi;
          }
          return new LatLng(phi * d, point3.x * d / r);
        }
      };
      var index = {
        __proto__: null,
        LonLat,
        Mercator,
        SphericalMercator
      };
      var EPSG3395 = extend({}, Earth, {
        code: "EPSG:3395",
        projection: Mercator,
        transformation: function() {
          var scale2 = 0.5 / (Math.PI * Mercator.R);
          return toTransformation(scale2, 0.5, -scale2, 0.5);
        }()
      });
      var EPSG43262 = extend({}, Earth, {
        code: "EPSG:4326",
        projection: LonLat,
        transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)
      });
      var Simple = extend({}, CRS2, {
        projection: LonLat,
        transformation: toTransformation(1, 0, -1, 0),
        scale: function(zoom2) {
          return Math.pow(2, zoom2);
        },
        zoom: function(scale2) {
          return Math.log(scale2) / Math.LN2;
        },
        distance: function(latlng1, latlng2) {
          var dx = latlng2.lng - latlng1.lng, dy = latlng2.lat - latlng1.lat;
          return Math.sqrt(dx * dx + dy * dy);
        },
        infinite: true
      });
      CRS2.Earth = Earth;
      CRS2.EPSG3395 = EPSG3395;
      CRS2.EPSG3857 = EPSG3857;
      CRS2.EPSG900913 = EPSG900913;
      CRS2.EPSG4326 = EPSG43262;
      CRS2.Simple = Simple;
      var Layer = Evented.extend({
        options: {
          pane: "overlayPane",
          attribution: null,
          bubblingMouseEvents: true
        },
        addTo: function(map) {
          map.addLayer(this);
          return this;
        },
        remove: function() {
          return this.removeFrom(this._map || this._mapToAdd);
        },
        removeFrom: function(obj2) {
          if (obj2) {
            obj2.removeLayer(this);
          }
          return this;
        },
        getPane: function(name) {
          return this._map.getPane(name ? this.options[name] || name : this.options.pane);
        },
        addInteractiveTarget: function(targetEl) {
          this._map._targets[stamp(targetEl)] = this;
          return this;
        },
        removeInteractiveTarget: function(targetEl) {
          delete this._map._targets[stamp(targetEl)];
          return this;
        },
        getAttribution: function() {
          return this.options.attribution;
        },
        _layerAdd: function(e) {
          var map = e.target;
          if (!map.hasLayer(this)) {
            return;
          }
          this._map = map;
          this._zoomAnimated = map._zoomAnimated;
          if (this.getEvents) {
            var events = this.getEvents();
            map.on(events, this);
            this.once("remove", function() {
              map.off(events, this);
            }, this);
          }
          this.onAdd(map);
          this.fire("add");
          map.fire("layeradd", { layer: this });
        }
      });
      Map.include({
        addLayer: function(layer) {
          if (!layer._layerAdd) {
            throw new Error("The provided object is not a Layer.");
          }
          var id = stamp(layer);
          if (this._layers[id]) {
            return this;
          }
          this._layers[id] = layer;
          layer._mapToAdd = this;
          if (layer.beforeAdd) {
            layer.beforeAdd(this);
          }
          this.whenReady(layer._layerAdd, layer);
          return this;
        },
        removeLayer: function(layer) {
          var id = stamp(layer);
          if (!this._layers[id]) {
            return this;
          }
          if (this._loaded) {
            layer.onRemove(this);
          }
          delete this._layers[id];
          if (this._loaded) {
            this.fire("layerremove", { layer });
            layer.fire("remove");
          }
          layer._map = layer._mapToAdd = null;
          return this;
        },
        hasLayer: function(layer) {
          return stamp(layer) in this._layers;
        },
        eachLayer: function(method, context) {
          for (var i in this._layers) {
            method.call(context, this._layers[i]);
          }
          return this;
        },
        _addLayers: function(layers2) {
          layers2 = layers2 ? isArray(layers2) ? layers2 : [layers2] : [];
          for (var i = 0, len = layers2.length; i < len; i++) {
            this.addLayer(layers2[i]);
          }
        },
        _addZoomLimit: function(layer) {
          if (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
            this._zoomBoundLayers[stamp(layer)] = layer;
            this._updateZoomLevels();
          }
        },
        _removeZoomLimit: function(layer) {
          var id = stamp(layer);
          if (this._zoomBoundLayers[id]) {
            delete this._zoomBoundLayers[id];
            this._updateZoomLevels();
          }
        },
        _updateZoomLevels: function() {
          var minZoom = Infinity, maxZoom = -Infinity, oldZoomSpan = this._getZoomSpan();
          for (var i in this._zoomBoundLayers) {
            var options = this._zoomBoundLayers[i].options;
            minZoom = options.minZoom === void 0 ? minZoom : Math.min(minZoom, options.minZoom);
            maxZoom = options.maxZoom === void 0 ? maxZoom : Math.max(maxZoom, options.maxZoom);
          }
          this._layersMaxZoom = maxZoom === -Infinity ? void 0 : maxZoom;
          this._layersMinZoom = minZoom === Infinity ? void 0 : minZoom;
          if (oldZoomSpan !== this._getZoomSpan()) {
            this.fire("zoomlevelschange");
          }
          if (this.options.maxZoom === void 0 && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {
            this.setZoom(this._layersMaxZoom);
          }
          if (this.options.minZoom === void 0 && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {
            this.setZoom(this._layersMinZoom);
          }
        }
      });
      var LayerGroup = Layer.extend({
        initialize: function(layers2, options) {
          setOptions(this, options);
          this._layers = {};
          var i, len;
          if (layers2) {
            for (i = 0, len = layers2.length; i < len; i++) {
              this.addLayer(layers2[i]);
            }
          }
        },
        addLayer: function(layer) {
          var id = this.getLayerId(layer);
          this._layers[id] = layer;
          if (this._map) {
            this._map.addLayer(layer);
          }
          return this;
        },
        removeLayer: function(layer) {
          var id = layer in this._layers ? layer : this.getLayerId(layer);
          if (this._map && this._layers[id]) {
            this._map.removeLayer(this._layers[id]);
          }
          delete this._layers[id];
          return this;
        },
        hasLayer: function(layer) {
          var layerId = typeof layer === "number" ? layer : this.getLayerId(layer);
          return layerId in this._layers;
        },
        clearLayers: function() {
          return this.eachLayer(this.removeLayer, this);
        },
        invoke: function(methodName) {
          var args = Array.prototype.slice.call(arguments, 1), i, layer;
          for (i in this._layers) {
            layer = this._layers[i];
            if (layer[methodName]) {
              layer[methodName].apply(layer, args);
            }
          }
          return this;
        },
        onAdd: function(map) {
          this.eachLayer(map.addLayer, map);
        },
        onRemove: function(map) {
          this.eachLayer(map.removeLayer, map);
        },
        eachLayer: function(method, context) {
          for (var i in this._layers) {
            method.call(context, this._layers[i]);
          }
          return this;
        },
        getLayer: function(id) {
          return this._layers[id];
        },
        getLayers: function() {
          var layers2 = [];
          this.eachLayer(layers2.push, layers2);
          return layers2;
        },
        setZIndex: function(zIndex) {
          return this.invoke("setZIndex", zIndex);
        },
        getLayerId: function(layer) {
          return stamp(layer);
        }
      });
      var layerGroup = function(layers2, options) {
        return new LayerGroup(layers2, options);
      };
      var FeatureGroup = LayerGroup.extend({
        addLayer: function(layer) {
          if (this.hasLayer(layer)) {
            return this;
          }
          layer.addEventParent(this);
          LayerGroup.prototype.addLayer.call(this, layer);
          return this.fire("layeradd", { layer });
        },
        removeLayer: function(layer) {
          if (!this.hasLayer(layer)) {
            return this;
          }
          if (layer in this._layers) {
            layer = this._layers[layer];
          }
          layer.removeEventParent(this);
          LayerGroup.prototype.removeLayer.call(this, layer);
          return this.fire("layerremove", { layer });
        },
        setStyle: function(style2) {
          return this.invoke("setStyle", style2);
        },
        bringToFront: function() {
          return this.invoke("bringToFront");
        },
        bringToBack: function() {
          return this.invoke("bringToBack");
        },
        getBounds: function() {
          var bounds = new LatLngBounds2();
          for (var id in this._layers) {
            var layer = this._layers[id];
            bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
          }
          return bounds;
        }
      });
      var featureGroup = function(layers2, options) {
        return new FeatureGroup(layers2, options);
      };
      var Icon = Class.extend({
        options: {
          popupAnchor: [0, 0],
          tooltipAnchor: [0, 0],
          crossOrigin: false
        },
        initialize: function(options) {
          setOptions(this, options);
        },
        createIcon: function(oldIcon) {
          return this._createIcon("icon", oldIcon);
        },
        createShadow: function(oldIcon) {
          return this._createIcon("shadow", oldIcon);
        },
        _createIcon: function(name, oldIcon) {
          var src = this._getIconUrl(name);
          if (!src) {
            if (name === "icon") {
              throw new Error("iconUrl not set in Icon options (see the docs).");
            }
            return null;
          }
          var img = this._createImg(src, oldIcon && oldIcon.tagName === "IMG" ? oldIcon : null);
          this._setIconStyles(img, name);
          if (this.options.crossOrigin || this.options.crossOrigin === "") {
            img.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
          }
          return img;
        },
        _setIconStyles: function(img, name) {
          var options = this.options;
          var sizeOption = options[name + "Size"];
          if (typeof sizeOption === "number") {
            sizeOption = [sizeOption, sizeOption];
          }
          var size = toPoint2(sizeOption), anchor = toPoint2(name === "shadow" && options.shadowAnchor || options.iconAnchor || size && size.divideBy(2, true));
          img.className = "leaflet-marker-" + name + " " + (options.className || "");
          if (anchor) {
            img.style.marginLeft = -anchor.x + "px";
            img.style.marginTop = -anchor.y + "px";
          }
          if (size) {
            img.style.width = size.x + "px";
            img.style.height = size.y + "px";
          }
        },
        _createImg: function(src, el) {
          el = el || document.createElement("img");
          el.src = src;
          return el;
        },
        _getIconUrl: function(name) {
          return Browser2.retina && this.options[name + "RetinaUrl"] || this.options[name + "Url"];
        }
      });
      function icon(options) {
        return new Icon(options);
      }
      var IconDefault = Icon.extend({
        options: {
          iconUrl: "marker-icon.png",
          iconRetinaUrl: "marker-icon-2x.png",
          shadowUrl: "marker-shadow.png",
          iconSize: [25, 41],
          iconAnchor: [12, 41],
          popupAnchor: [1, -34],
          tooltipAnchor: [16, -28],
          shadowSize: [41, 41]
        },
        _getIconUrl: function(name) {
          if (typeof IconDefault.imagePath !== "string") {
            IconDefault.imagePath = this._detectIconPath();
          }
          return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);
        },
        _stripUrl: function(path) {
          var strip = function(str, re, idx) {
            var match2 = re.exec(str);
            return match2 && match2[idx];
          };
          path = strip(path, /^url\((['"])?(.+)\1\)$/, 2);
          return path && strip(path, /^(.*)marker-icon\.png$/, 1);
        },
        _detectIconPath: function() {
          var el = create$1("div", "leaflet-default-icon-path", document.body);
          var path = getStyle(el, "background-image") || getStyle(el, "backgroundImage");
          document.body.removeChild(el);
          path = this._stripUrl(path);
          if (path) {
            return path;
          }
          var link = document.querySelector('link[href$="leaflet.css"]');
          if (!link) {
            return "";
          }
          return link.href.substring(0, link.href.length - "leaflet.css".length - 1);
        }
      });
      var MarkerDrag = Handler.extend({
        initialize: function(marker2) {
          this._marker = marker2;
        },
        addHooks: function() {
          var icon2 = this._marker._icon;
          if (!this._draggable) {
            this._draggable = new Draggable(icon2, icon2, true);
          }
          this._draggable.on({
            dragstart: this._onDragStart,
            predrag: this._onPreDrag,
            drag: this._onDrag,
            dragend: this._onDragEnd
          }, this).enable();
          addClass(icon2, "leaflet-marker-draggable");
        },
        removeHooks: function() {
          this._draggable.off({
            dragstart: this._onDragStart,
            predrag: this._onPreDrag,
            drag: this._onDrag,
            dragend: this._onDragEnd
          }, this).disable();
          if (this._marker._icon) {
            removeClass(this._marker._icon, "leaflet-marker-draggable");
          }
        },
        moved: function() {
          return this._draggable && this._draggable._moved;
        },
        _adjustPan: function(e) {
          var marker2 = this._marker, map = marker2._map, speed = this._marker.options.autoPanSpeed, padding = this._marker.options.autoPanPadding, iconPos = getPosition(marker2._icon), bounds = map.getPixelBounds(), origin = map.getPixelOrigin();
          var panBounds = toBounds(
            bounds.min._subtract(origin).add(padding),
            bounds.max._subtract(origin).subtract(padding)
          );
          if (!panBounds.contains(iconPos)) {
            var movement = toPoint2(
              (Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) - (Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x),
              (Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) - (Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)
            ).multiplyBy(speed);
            map.panBy(movement, { animate: false });
            this._draggable._newPos._add(movement);
            this._draggable._startPos._add(movement);
            setPosition(marker2._icon, this._draggable._newPos);
            this._onDrag(e);
            this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
          }
        },
        _onDragStart: function() {
          this._oldLatLng = this._marker.getLatLng();
          this._marker.closePopup && this._marker.closePopup();
          this._marker.fire("movestart").fire("dragstart");
        },
        _onPreDrag: function(e) {
          if (this._marker.options.autoPan) {
            cancelAnimFrame(this._panRequest);
            this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
          }
        },
        _onDrag: function(e) {
          var marker2 = this._marker, shadow = marker2._shadow, iconPos = getPosition(marker2._icon), latlng = marker2._map.layerPointToLatLng(iconPos);
          if (shadow) {
            setPosition(shadow, iconPos);
          }
          marker2._latlng = latlng;
          e.latlng = latlng;
          e.oldLatLng = this._oldLatLng;
          marker2.fire("move", e).fire("drag", e);
        },
        _onDragEnd: function(e) {
          cancelAnimFrame(this._panRequest);
          delete this._oldLatLng;
          this._marker.fire("moveend").fire("dragend", e);
        }
      });
      var Marker = Layer.extend({
        options: {
          icon: new IconDefault(),
          interactive: true,
          keyboard: true,
          title: "",
          alt: "Marker",
          zIndexOffset: 0,
          opacity: 1,
          riseOnHover: false,
          riseOffset: 250,
          pane: "markerPane",
          shadowPane: "shadowPane",
          bubblingMouseEvents: false,
          autoPanOnFocus: true,
          draggable: false,
          autoPan: false,
          autoPanPadding: [50, 50],
          autoPanSpeed: 10
        },
        initialize: function(latlng, options) {
          setOptions(this, options);
          this._latlng = toLatLng(latlng);
        },
        onAdd: function(map) {
          this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;
          if (this._zoomAnimated) {
            map.on("zoomanim", this._animateZoom, this);
          }
          this._initIcon();
          this.update();
        },
        onRemove: function(map) {
          if (this.dragging && this.dragging.enabled()) {
            this.options.draggable = true;
            this.dragging.removeHooks();
          }
          delete this.dragging;
          if (this._zoomAnimated) {
            map.off("zoomanim", this._animateZoom, this);
          }
          this._removeIcon();
          this._removeShadow();
        },
        getEvents: function() {
          return {
            zoom: this.update,
            viewreset: this.update
          };
        },
        getLatLng: function() {
          return this._latlng;
        },
        setLatLng: function(latlng) {
          var oldLatLng = this._latlng;
          this._latlng = toLatLng(latlng);
          this.update();
          return this.fire("move", { oldLatLng, latlng: this._latlng });
        },
        setZIndexOffset: function(offset) {
          this.options.zIndexOffset = offset;
          return this.update();
        },
        getIcon: function() {
          return this.options.icon;
        },
        setIcon: function(icon2) {
          this.options.icon = icon2;
          if (this._map) {
            this._initIcon();
            this.update();
          }
          if (this._popup) {
            this.bindPopup(this._popup, this._popup.options);
          }
          return this;
        },
        getElement: function() {
          return this._icon;
        },
        update: function() {
          if (this._icon && this._map) {
            var pos = this._map.latLngToLayerPoint(this._latlng).round();
            this._setPos(pos);
          }
          return this;
        },
        _initIcon: function() {
          var options = this.options, classToAdd = "leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
          var icon2 = options.icon.createIcon(this._icon), addIcon = false;
          if (icon2 !== this._icon) {
            if (this._icon) {
              this._removeIcon();
            }
            addIcon = true;
            if (options.title) {
              icon2.title = options.title;
            }
            if (icon2.tagName === "IMG") {
              icon2.alt = options.alt || "";
            }
          }
          addClass(icon2, classToAdd);
          if (options.keyboard) {
            icon2.tabIndex = "0";
            icon2.setAttribute("role", "button");
          }
          this._icon = icon2;
          if (options.riseOnHover) {
            this.on({
              mouseover: this._bringToFront,
              mouseout: this._resetZIndex
            });
          }
          if (this.options.autoPanOnFocus) {
            on(icon2, "focus", this._panOnFocus, this);
          }
          var newShadow = options.icon.createShadow(this._shadow), addShadow = false;
          if (newShadow !== this._shadow) {
            this._removeShadow();
            addShadow = true;
          }
          if (newShadow) {
            addClass(newShadow, classToAdd);
            newShadow.alt = "";
          }
          this._shadow = newShadow;
          if (options.opacity < 1) {
            this._updateOpacity();
          }
          if (addIcon) {
            this.getPane().appendChild(this._icon);
          }
          this._initInteraction();
          if (newShadow && addShadow) {
            this.getPane(options.shadowPane).appendChild(this._shadow);
          }
        },
        _removeIcon: function() {
          if (this.options.riseOnHover) {
            this.off({
              mouseover: this._bringToFront,
              mouseout: this._resetZIndex
            });
          }
          if (this.options.autoPanOnFocus) {
            off(this._icon, "focus", this._panOnFocus, this);
          }
          remove(this._icon);
          this.removeInteractiveTarget(this._icon);
          this._icon = null;
        },
        _removeShadow: function() {
          if (this._shadow) {
            remove(this._shadow);
          }
          this._shadow = null;
        },
        _setPos: function(pos) {
          if (this._icon) {
            setPosition(this._icon, pos);
          }
          if (this._shadow) {
            setPosition(this._shadow, pos);
          }
          this._zIndex = pos.y + this.options.zIndexOffset;
          this._resetZIndex();
        },
        _updateZIndex: function(offset) {
          if (this._icon) {
            this._icon.style.zIndex = this._zIndex + offset;
          }
        },
        _animateZoom: function(opt) {
          var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();
          this._setPos(pos);
        },
        _initInteraction: function() {
          if (!this.options.interactive) {
            return;
          }
          addClass(this._icon, "leaflet-interactive");
          this.addInteractiveTarget(this._icon);
          if (MarkerDrag) {
            var draggable = this.options.draggable;
            if (this.dragging) {
              draggable = this.dragging.enabled();
              this.dragging.disable();
            }
            this.dragging = new MarkerDrag(this);
            if (draggable) {
              this.dragging.enable();
            }
          }
        },
        setOpacity: function(opacity) {
          this.options.opacity = opacity;
          if (this._map) {
            this._updateOpacity();
          }
          return this;
        },
        _updateOpacity: function() {
          var opacity = this.options.opacity;
          if (this._icon) {
            setOpacity(this._icon, opacity);
          }
          if (this._shadow) {
            setOpacity(this._shadow, opacity);
          }
        },
        _bringToFront: function() {
          this._updateZIndex(this.options.riseOffset);
        },
        _resetZIndex: function() {
          this._updateZIndex(0);
        },
        _panOnFocus: function() {
          var map = this._map;
          if (!map) {
            return;
          }
          var iconOpts = this.options.icon.options;
          var size = iconOpts.iconSize ? toPoint2(iconOpts.iconSize) : toPoint2(0, 0);
          var anchor = iconOpts.iconAnchor ? toPoint2(iconOpts.iconAnchor) : toPoint2(0, 0);
          map.panInside(this._latlng, {
            paddingTopLeft: anchor,
            paddingBottomRight: size.subtract(anchor)
          });
        },
        _getPopupAnchor: function() {
          return this.options.icon.options.popupAnchor;
        },
        _getTooltipAnchor: function() {
          return this.options.icon.options.tooltipAnchor;
        }
      });
      function marker(latlng, options) {
        return new Marker(latlng, options);
      }
      var Path = Layer.extend({
        options: {
          stroke: true,
          color: "#3388ff",
          weight: 3,
          opacity: 1,
          lineCap: "round",
          lineJoin: "round",
          dashArray: null,
          dashOffset: null,
          fill: false,
          fillColor: null,
          fillOpacity: 0.2,
          fillRule: "evenodd",
          interactive: true,
          bubblingMouseEvents: true
        },
        beforeAdd: function(map) {
          this._renderer = map.getRenderer(this);
        },
        onAdd: function() {
          this._renderer._initPath(this);
          this._reset();
          this._renderer._addPath(this);
        },
        onRemove: function() {
          this._renderer._removePath(this);
        },
        redraw: function() {
          if (this._map) {
            this._renderer._updatePath(this);
          }
          return this;
        },
        setStyle: function(style2) {
          setOptions(this, style2);
          if (this._renderer) {
            this._renderer._updateStyle(this);
            if (this.options.stroke && style2 && Object.prototype.hasOwnProperty.call(style2, "weight")) {
              this._updateBounds();
            }
          }
          return this;
        },
        bringToFront: function() {
          if (this._renderer) {
            this._renderer._bringToFront(this);
          }
          return this;
        },
        bringToBack: function() {
          if (this._renderer) {
            this._renderer._bringToBack(this);
          }
          return this;
        },
        getElement: function() {
          return this._path;
        },
        _reset: function() {
          this._project();
          this._update();
        },
        _clickTolerance: function() {
          return (this.options.stroke ? this.options.weight / 2 : 0) + (this._renderer.options.tolerance || 0);
        }
      });
      var CircleMarker = Path.extend({
        options: {
          fill: true,
          radius: 10
        },
        initialize: function(latlng, options) {
          setOptions(this, options);
          this._latlng = toLatLng(latlng);
          this._radius = this.options.radius;
        },
        setLatLng: function(latlng) {
          var oldLatLng = this._latlng;
          this._latlng = toLatLng(latlng);
          this.redraw();
          return this.fire("move", { oldLatLng, latlng: this._latlng });
        },
        getLatLng: function() {
          return this._latlng;
        },
        setRadius: function(radius) {
          this.options.radius = this._radius = radius;
          return this.redraw();
        },
        getRadius: function() {
          return this._radius;
        },
        setStyle: function(options) {
          var radius = options && options.radius || this._radius;
          Path.prototype.setStyle.call(this, options);
          this.setRadius(radius);
          return this;
        },
        _project: function() {
          this._point = this._map.latLngToLayerPoint(this._latlng);
          this._updateBounds();
        },
        _updateBounds: function() {
          var r = this._radius, r2 = this._radiusY || r, w = this._clickTolerance(), p = [r + w, r2 + w];
          this._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));
        },
        _update: function() {
          if (this._map) {
            this._updatePath();
          }
        },
        _updatePath: function() {
          this._renderer._updateCircle(this);
        },
        _empty: function() {
          return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
        },
        _containsPoint: function(p) {
          return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
        }
      });
      function circleMarker(latlng, options) {
        return new CircleMarker(latlng, options);
      }
      var Circle = CircleMarker.extend({
        initialize: function(latlng, options, legacyOptions) {
          if (typeof options === "number") {
            options = extend({}, legacyOptions, { radius: options });
          }
          setOptions(this, options);
          this._latlng = toLatLng(latlng);
          if (isNaN(this.options.radius)) {
            throw new Error("Circle radius cannot be NaN");
          }
          this._mRadius = this.options.radius;
        },
        setRadius: function(radius) {
          this._mRadius = radius;
          return this.redraw();
        },
        getRadius: function() {
          return this._mRadius;
        },
        getBounds: function() {
          var half = [this._radius, this._radiusY || this._radius];
          return new LatLngBounds2(
            this._map.layerPointToLatLng(this._point.subtract(half)),
            this._map.layerPointToLatLng(this._point.add(half))
          );
        },
        setStyle: Path.prototype.setStyle,
        _project: function() {
          var lng = this._latlng.lng, lat = this._latlng.lat, map = this._map, crs = map.options.crs;
          if (crs.distance === Earth.distance) {
            var d = Math.PI / 180, latR = this._mRadius / Earth.R / d, top = map.project([lat + latR, lng]), bottom = map.project([lat - latR, lng]), p = top.add(bottom).divideBy(2), lat2 = map.unproject(p).lat, lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) / (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;
            if (isNaN(lngR) || lngR === 0) {
              lngR = latR / Math.cos(Math.PI / 180 * lat);
            }
            this._point = p.subtract(map.getPixelOrigin());
            this._radius = isNaN(lngR) ? 0 : p.x - map.project([lat2, lng - lngR]).x;
            this._radiusY = p.y - top.y;
          } else {
            var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));
            this._point = map.latLngToLayerPoint(this._latlng);
            this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;
          }
          this._updateBounds();
        }
      });
      function circle(latlng, options, legacyOptions) {
        return new Circle(latlng, options, legacyOptions);
      }
      var Polyline = Path.extend({
        options: {
          smoothFactor: 1,
          noClip: false
        },
        initialize: function(latlngs, options) {
          setOptions(this, options);
          this._setLatLngs(latlngs);
        },
        getLatLngs: function() {
          return this._latlngs;
        },
        setLatLngs: function(latlngs) {
          this._setLatLngs(latlngs);
          return this.redraw();
        },
        isEmpty: function() {
          return !this._latlngs.length;
        },
        closestLayerPoint: function(p) {
          var minDistance = Infinity, minPoint = null, closest = _sqClosestPointOnSegment, p1, p2;
          for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
            var points = this._parts[j];
            for (var i = 1, len = points.length; i < len; i++) {
              p1 = points[i - 1];
              p2 = points[i];
              var sqDist = closest(p, p1, p2, true);
              if (sqDist < minDistance) {
                minDistance = sqDist;
                minPoint = closest(p, p1, p2);
              }
            }
          }
          if (minPoint) {
            minPoint.distance = Math.sqrt(minDistance);
          }
          return minPoint;
        },
        getCenter: function() {
          if (!this._map) {
            throw new Error("Must add layer to map before using getCenter()");
          }
          return polylineCenter(this._defaultShape(), this._map.options.crs);
        },
        getBounds: function() {
          return this._bounds;
        },
        addLatLng: function(latlng, latlngs) {
          latlngs = latlngs || this._defaultShape();
          latlng = toLatLng(latlng);
          latlngs.push(latlng);
          this._bounds.extend(latlng);
          return this.redraw();
        },
        _setLatLngs: function(latlngs) {
          this._bounds = new LatLngBounds2();
          this._latlngs = this._convertLatLngs(latlngs);
        },
        _defaultShape: function() {
          return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];
        },
        _convertLatLngs: function(latlngs) {
          var result2 = [], flat = isFlat(latlngs);
          for (var i = 0, len = latlngs.length; i < len; i++) {
            if (flat) {
              result2[i] = toLatLng(latlngs[i]);
              this._bounds.extend(result2[i]);
            } else {
              result2[i] = this._convertLatLngs(latlngs[i]);
            }
          }
          return result2;
        },
        _project: function() {
          var pxBounds = new Bounds();
          this._rings = [];
          this._projectLatlngs(this._latlngs, this._rings, pxBounds);
          if (this._bounds.isValid() && pxBounds.isValid()) {
            this._rawPxBounds = pxBounds;
            this._updateBounds();
          }
        },
        _updateBounds: function() {
          var w = this._clickTolerance(), p = new Point2(w, w);
          if (!this._rawPxBounds) {
            return;
          }
          this._pxBounds = new Bounds([
            this._rawPxBounds.min.subtract(p),
            this._rawPxBounds.max.add(p)
          ]);
        },
        _projectLatlngs: function(latlngs, result2, projectedBounds) {
          var flat = latlngs[0] instanceof LatLng, len = latlngs.length, i, ring;
          if (flat) {
            ring = [];
            for (i = 0; i < len; i++) {
              ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
              projectedBounds.extend(ring[i]);
            }
            result2.push(ring);
          } else {
            for (i = 0; i < len; i++) {
              this._projectLatlngs(latlngs[i], result2, projectedBounds);
            }
          }
        },
        _clipPoints: function() {
          var bounds = this._renderer._bounds;
          this._parts = [];
          if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
            return;
          }
          if (this.options.noClip) {
            this._parts = this._rings;
            return;
          }
          var parts = this._parts, i, j, k, len, len2, segment, points;
          for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
            points = this._rings[i];
            for (j = 0, len2 = points.length; j < len2 - 1; j++) {
              segment = clipSegment(points[j], points[j + 1], bounds, j, true);
              if (!segment) {
                continue;
              }
              parts[k] = parts[k] || [];
              parts[k].push(segment[0]);
              if (segment[1] !== points[j + 1] || j === len2 - 2) {
                parts[k].push(segment[1]);
                k++;
              }
            }
          }
        },
        _simplifyPoints: function() {
          var parts = this._parts, tolerance = this.options.smoothFactor;
          for (var i = 0, len = parts.length; i < len; i++) {
            parts[i] = simplify(parts[i], tolerance);
          }
        },
        _update: function() {
          if (!this._map) {
            return;
          }
          this._clipPoints();
          this._simplifyPoints();
          this._updatePath();
        },
        _updatePath: function() {
          this._renderer._updatePoly(this);
        },
        _containsPoint: function(p, closed) {
          var i, j, k, len, len2, part, w = this._clickTolerance();
          if (!this._pxBounds || !this._pxBounds.contains(p)) {
            return false;
          }
          for (i = 0, len = this._parts.length; i < len; i++) {
            part = this._parts[i];
            for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
              if (!closed && j === 0) {
                continue;
              }
              if (pointToSegmentDistance(p, part[k], part[j]) <= w) {
                return true;
              }
            }
          }
          return false;
        }
      });
      function polyline(latlngs, options) {
        return new Polyline(latlngs, options);
      }
      Polyline._flat = _flat;
      var Polygon = Polyline.extend({
        options: {
          fill: true
        },
        isEmpty: function() {
          return !this._latlngs.length || !this._latlngs[0].length;
        },
        getCenter: function() {
          if (!this._map) {
            throw new Error("Must add layer to map before using getCenter()");
          }
          return polygonCenter(this._defaultShape(), this._map.options.crs);
        },
        _convertLatLngs: function(latlngs) {
          var result2 = Polyline.prototype._convertLatLngs.call(this, latlngs), len = result2.length;
          if (len >= 2 && result2[0] instanceof LatLng && result2[0].equals(result2[len - 1])) {
            result2.pop();
          }
          return result2;
        },
        _setLatLngs: function(latlngs) {
          Polyline.prototype._setLatLngs.call(this, latlngs);
          if (isFlat(this._latlngs)) {
            this._latlngs = [this._latlngs];
          }
        },
        _defaultShape: function() {
          return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
        },
        _clipPoints: function() {
          var bounds = this._renderer._bounds, w = this.options.weight, p = new Point2(w, w);
          bounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));
          this._parts = [];
          if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
            return;
          }
          if (this.options.noClip) {
            this._parts = this._rings;
            return;
          }
          for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
            clipped = clipPolygon(this._rings[i], bounds, true);
            if (clipped.length) {
              this._parts.push(clipped);
            }
          }
        },
        _updatePath: function() {
          this._renderer._updatePoly(this, true);
        },
        _containsPoint: function(p) {
          var inside = false, part, p1, p2, i, j, k, len, len2;
          if (!this._pxBounds || !this._pxBounds.contains(p)) {
            return false;
          }
          for (i = 0, len = this._parts.length; i < len; i++) {
            part = this._parts[i];
            for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
              p1 = part[j];
              p2 = part[k];
              if (p1.y > p.y !== p2.y > p.y && p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x) {
                inside = !inside;
              }
            }
          }
          return inside || Polyline.prototype._containsPoint.call(this, p, true);
        }
      });
      function polygon(latlngs, options) {
        return new Polygon(latlngs, options);
      }
      var GeoJSON = FeatureGroup.extend({
        initialize: function(geojson, options) {
          setOptions(this, options);
          this._layers = {};
          if (geojson) {
            this.addData(geojson);
          }
        },
        addData: function(geojson) {
          var features = isArray(geojson) ? geojson : geojson.features, i, len, feature;
          if (features) {
            for (i = 0, len = features.length; i < len; i++) {
              feature = features[i];
              if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
                this.addData(feature);
              }
            }
            return this;
          }
          var options = this.options;
          if (options.filter && !options.filter(geojson)) {
            return this;
          }
          var layer = geometryToLayer(geojson, options);
          if (!layer) {
            return this;
          }
          layer.feature = asFeature(geojson);
          layer.defaultOptions = layer.options;
          this.resetStyle(layer);
          if (options.onEachFeature) {
            options.onEachFeature(geojson, layer);
          }
          return this.addLayer(layer);
        },
        resetStyle: function(layer) {
          if (layer === void 0) {
            return this.eachLayer(this.resetStyle, this);
          }
          layer.options = extend({}, layer.defaultOptions);
          this._setLayerStyle(layer, this.options.style);
          return this;
        },
        setStyle: function(style2) {
          return this.eachLayer(function(layer) {
            this._setLayerStyle(layer, style2);
          }, this);
        },
        _setLayerStyle: function(layer, style2) {
          if (layer.setStyle) {
            if (typeof style2 === "function") {
              style2 = style2(layer.feature);
            }
            layer.setStyle(style2);
          }
        }
      });
      function geometryToLayer(geojson, options) {
        var geometry = geojson.type === "Feature" ? geojson.geometry : geojson, coords = geometry ? geometry.coordinates : null, layers2 = [], pointToLayer = options && options.pointToLayer, _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng, latlng, latlngs, i, len;
        if (!coords && !geometry) {
          return null;
        }
        switch (geometry.type) {
          case "Point":
            latlng = _coordsToLatLng(coords);
            return _pointToLayer(pointToLayer, geojson, latlng, options);
          case "MultiPoint":
            for (i = 0, len = coords.length; i < len; i++) {
              latlng = _coordsToLatLng(coords[i]);
              layers2.push(_pointToLayer(pointToLayer, geojson, latlng, options));
            }
            return new FeatureGroup(layers2);
          case "LineString":
          case "MultiLineString":
            latlngs = coordsToLatLngs(coords, geometry.type === "LineString" ? 0 : 1, _coordsToLatLng);
            return new Polyline(latlngs, options);
          case "Polygon":
          case "MultiPolygon":
            latlngs = coordsToLatLngs(coords, geometry.type === "Polygon" ? 1 : 2, _coordsToLatLng);
            return new Polygon(latlngs, options);
          case "GeometryCollection":
            for (i = 0, len = geometry.geometries.length; i < len; i++) {
              var geoLayer = geometryToLayer({
                geometry: geometry.geometries[i],
                type: "Feature",
                properties: geojson.properties
              }, options);
              if (geoLayer) {
                layers2.push(geoLayer);
              }
            }
            return new FeatureGroup(layers2);
          case "FeatureCollection":
            for (i = 0, len = geometry.features.length; i < len; i++) {
              var featureLayer = geometryToLayer(geometry.features[i], options);
              if (featureLayer) {
                layers2.push(featureLayer);
              }
            }
            return new FeatureGroup(layers2);
          default:
            throw new Error("Invalid GeoJSON object.");
        }
      }
      function _pointToLayer(pointToLayerFn, geojson, latlng, options) {
        return pointToLayerFn ? pointToLayerFn(geojson, latlng) : new Marker(latlng, options && options.markersInheritOptions && options);
      }
      function coordsToLatLng(coords) {
        return new LatLng(coords[1], coords[0], coords[2]);
      }
      function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {
        var latlngs = [];
        for (var i = 0, len = coords.length, latlng; i < len; i++) {
          latlng = levelsDeep ? coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) : (_coordsToLatLng || coordsToLatLng)(coords[i]);
          latlngs.push(latlng);
        }
        return latlngs;
      }
      function latLngToCoords(latlng, precision) {
        latlng = toLatLng(latlng);
        return latlng.alt !== void 0 ? [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] : [formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];
      }
      function latLngsToCoords(latlngs, levelsDeep, closed, precision) {
        var coords = [];
        for (var i = 0, len = latlngs.length; i < len; i++) {
          coords.push(levelsDeep ? latLngsToCoords(latlngs[i], isFlat(latlngs[i]) ? 0 : levelsDeep - 1, closed, precision) : latLngToCoords(latlngs[i], precision));
        }
        if (!levelsDeep && closed && coords.length > 0) {
          coords.push(coords[0].slice());
        }
        return coords;
      }
      function getFeature(layer, newGeometry) {
        return layer.feature ? extend({}, layer.feature, { geometry: newGeometry }) : asFeature(newGeometry);
      }
      function asFeature(geojson) {
        if (geojson.type === "Feature" || geojson.type === "FeatureCollection") {
          return geojson;
        }
        return {
          type: "Feature",
          properties: {},
          geometry: geojson
        };
      }
      var PointToGeoJSON = {
        toGeoJSON: function(precision) {
          return getFeature(this, {
            type: "Point",
            coordinates: latLngToCoords(this.getLatLng(), precision)
          });
        }
      };
      Marker.include(PointToGeoJSON);
      Circle.include(PointToGeoJSON);
      CircleMarker.include(PointToGeoJSON);
      Polyline.include({
        toGeoJSON: function(precision) {
          var multi = !isFlat(this._latlngs);
          var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);
          return getFeature(this, {
            type: (multi ? "Multi" : "") + "LineString",
            coordinates: coords
          });
        }
      });
      Polygon.include({
        toGeoJSON: function(precision) {
          var holes = !isFlat(this._latlngs), multi = holes && !isFlat(this._latlngs[0]);
          var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);
          if (!holes) {
            coords = [coords];
          }
          return getFeature(this, {
            type: (multi ? "Multi" : "") + "Polygon",
            coordinates: coords
          });
        }
      });
      LayerGroup.include({
        toMultiPoint: function(precision) {
          var coords = [];
          this.eachLayer(function(layer) {
            coords.push(layer.toGeoJSON(precision).geometry.coordinates);
          });
          return getFeature(this, {
            type: "MultiPoint",
            coordinates: coords
          });
        },
        toGeoJSON: function(precision) {
          var type = this.feature && this.feature.geometry && this.feature.geometry.type;
          if (type === "MultiPoint") {
            return this.toMultiPoint(precision);
          }
          var isGeometryCollection = type === "GeometryCollection", jsons = [];
          this.eachLayer(function(layer) {
            if (layer.toGeoJSON) {
              var json = layer.toGeoJSON(precision);
              if (isGeometryCollection) {
                jsons.push(json.geometry);
              } else {
                var feature = asFeature(json);
                if (feature.type === "FeatureCollection") {
                  jsons.push.apply(jsons, feature.features);
                } else {
                  jsons.push(feature);
                }
              }
            }
          });
          if (isGeometryCollection) {
            return getFeature(this, {
              geometries: jsons,
              type: "GeometryCollection"
            });
          }
          return {
            type: "FeatureCollection",
            features: jsons
          };
        }
      });
      function geoJSON(geojson, options) {
        return new GeoJSON(geojson, options);
      }
      var geoJson = geoJSON;
      var ImageOverlay = Layer.extend({
        options: {
          opacity: 1,
          alt: "",
          interactive: false,
          crossOrigin: false,
          errorOverlayUrl: "",
          zIndex: 1,
          className: ""
        },
        initialize: function(url, bounds, options) {
          this._url = url;
          this._bounds = toLatLngBounds(bounds);
          setOptions(this, options);
        },
        onAdd: function() {
          if (!this._image) {
            this._initImage();
            if (this.options.opacity < 1) {
              this._updateOpacity();
            }
          }
          if (this.options.interactive) {
            addClass(this._image, "leaflet-interactive");
            this.addInteractiveTarget(this._image);
          }
          this.getPane().appendChild(this._image);
          this._reset();
        },
        onRemove: function() {
          remove(this._image);
          if (this.options.interactive) {
            this.removeInteractiveTarget(this._image);
          }
        },
        setOpacity: function(opacity) {
          this.options.opacity = opacity;
          if (this._image) {
            this._updateOpacity();
          }
          return this;
        },
        setStyle: function(styleOpts) {
          if (styleOpts.opacity) {
            this.setOpacity(styleOpts.opacity);
          }
          return this;
        },
        bringToFront: function() {
          if (this._map) {
            toFront(this._image);
          }
          return this;
        },
        bringToBack: function() {
          if (this._map) {
            toBack(this._image);
          }
          return this;
        },
        setUrl: function(url) {
          this._url = url;
          if (this._image) {
            this._image.src = url;
          }
          return this;
        },
        setBounds: function(bounds) {
          this._bounds = toLatLngBounds(bounds);
          if (this._map) {
            this._reset();
          }
          return this;
        },
        getEvents: function() {
          var events = {
            zoom: this._reset,
            viewreset: this._reset
          };
          if (this._zoomAnimated) {
            events.zoomanim = this._animateZoom;
          }
          return events;
        },
        setZIndex: function(value) {
          this.options.zIndex = value;
          this._updateZIndex();
          return this;
        },
        getBounds: function() {
          return this._bounds;
        },
        getElement: function() {
          return this._image;
        },
        _initImage: function() {
          var wasElementSupplied = this._url.tagName === "IMG";
          var img = this._image = wasElementSupplied ? this._url : create$1("img");
          addClass(img, "leaflet-image-layer");
          if (this._zoomAnimated) {
            addClass(img, "leaflet-zoom-animated");
          }
          if (this.options.className) {
            addClass(img, this.options.className);
          }
          img.onselectstart = falseFn;
          img.onmousemove = falseFn;
          img.onload = bind(this.fire, this, "load");
          img.onerror = bind(this._overlayOnError, this, "error");
          if (this.options.crossOrigin || this.options.crossOrigin === "") {
            img.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
          }
          if (this.options.zIndex) {
            this._updateZIndex();
          }
          if (wasElementSupplied) {
            this._url = img.src;
            return;
          }
          img.src = this._url;
          img.alt = this.options.alt;
        },
        _animateZoom: function(e) {
          var scale2 = this._map.getZoomScale(e.zoom), offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;
          setTransform(this._image, offset, scale2);
        },
        _reset: function() {
          var image = this._image, bounds = new Bounds(
            this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
            this._map.latLngToLayerPoint(this._bounds.getSouthEast())
          ), size = bounds.getSize();
          setPosition(image, bounds.min);
          image.style.width = size.x + "px";
          image.style.height = size.y + "px";
        },
        _updateOpacity: function() {
          setOpacity(this._image, this.options.opacity);
        },
        _updateZIndex: function() {
          if (this._image && this.options.zIndex !== void 0 && this.options.zIndex !== null) {
            this._image.style.zIndex = this.options.zIndex;
          }
        },
        _overlayOnError: function() {
          this.fire("error");
          var errorUrl = this.options.errorOverlayUrl;
          if (errorUrl && this._url !== errorUrl) {
            this._url = errorUrl;
            this._image.src = errorUrl;
          }
        },
        getCenter: function() {
          return this._bounds.getCenter();
        }
      });
      var imageOverlay = function(url, bounds, options) {
        return new ImageOverlay(url, bounds, options);
      };
      var VideoOverlay = ImageOverlay.extend({
        options: {
          autoplay: true,
          loop: true,
          keepAspectRatio: true,
          muted: false,
          playsInline: true
        },
        _initImage: function() {
          var wasElementSupplied = this._url.tagName === "VIDEO";
          var vid = this._image = wasElementSupplied ? this._url : create$1("video");
          addClass(vid, "leaflet-image-layer");
          if (this._zoomAnimated) {
            addClass(vid, "leaflet-zoom-animated");
          }
          if (this.options.className) {
            addClass(vid, this.options.className);
          }
          vid.onselectstart = falseFn;
          vid.onmousemove = falseFn;
          vid.onloadeddata = bind(this.fire, this, "load");
          if (wasElementSupplied) {
            var sourceElements = vid.getElementsByTagName("source");
            var sources = [];
            for (var j = 0; j < sourceElements.length; j++) {
              sources.push(sourceElements[j].src);
            }
            this._url = sourceElements.length > 0 ? sources : [vid.src];
            return;
          }
          if (!isArray(this._url)) {
            this._url = [this._url];
          }
          if (!this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(vid.style, "objectFit")) {
            vid.style["objectFit"] = "fill";
          }
          vid.autoplay = !!this.options.autoplay;
          vid.loop = !!this.options.loop;
          vid.muted = !!this.options.muted;
          vid.playsInline = !!this.options.playsInline;
          for (var i = 0; i < this._url.length; i++) {
            var source = create$1("source");
            source.src = this._url[i];
            vid.appendChild(source);
          }
        }
      });
      function videoOverlay(video, bounds, options) {
        return new VideoOverlay(video, bounds, options);
      }
      var SVGOverlay = ImageOverlay.extend({
        _initImage: function() {
          var el = this._image = this._url;
          addClass(el, "leaflet-image-layer");
          if (this._zoomAnimated) {
            addClass(el, "leaflet-zoom-animated");
          }
          if (this.options.className) {
            addClass(el, this.options.className);
          }
          el.onselectstart = falseFn;
          el.onmousemove = falseFn;
        }
      });
      function svgOverlay(el, bounds, options) {
        return new SVGOverlay(el, bounds, options);
      }
      var DivOverlay = Layer.extend({
        options: {
          interactive: false,
          offset: [0, 0],
          className: "",
          pane: void 0,
          content: ""
        },
        initialize: function(options, source) {
          if (options && (options instanceof LatLng || isArray(options))) {
            this._latlng = toLatLng(options);
            setOptions(this, source);
          } else {
            setOptions(this, options);
            this._source = source;
          }
          if (this.options.content) {
            this._content = this.options.content;
          }
        },
        openOn: function(map) {
          map = arguments.length ? map : this._source._map;
          if (!map.hasLayer(this)) {
            map.addLayer(this);
          }
          return this;
        },
        close: function() {
          if (this._map) {
            this._map.removeLayer(this);
          }
          return this;
        },
        toggle: function(layer) {
          if (this._map) {
            this.close();
          } else {
            if (arguments.length) {
              this._source = layer;
            } else {
              layer = this._source;
            }
            this._prepareOpen();
            this.openOn(layer._map);
          }
          return this;
        },
        onAdd: function(map) {
          this._zoomAnimated = map._zoomAnimated;
          if (!this._container) {
            this._initLayout();
          }
          if (map._fadeAnimated) {
            setOpacity(this._container, 0);
          }
          clearTimeout(this._removeTimeout);
          this.getPane().appendChild(this._container);
          this.update();
          if (map._fadeAnimated) {
            setOpacity(this._container, 1);
          }
          this.bringToFront();
          if (this.options.interactive) {
            addClass(this._container, "leaflet-interactive");
            this.addInteractiveTarget(this._container);
          }
        },
        onRemove: function(map) {
          if (map._fadeAnimated) {
            setOpacity(this._container, 0);
            this._removeTimeout = setTimeout(bind(remove, void 0, this._container), 200);
          } else {
            remove(this._container);
          }
          if (this.options.interactive) {
            removeClass(this._container, "leaflet-interactive");
            this.removeInteractiveTarget(this._container);
          }
        },
        getLatLng: function() {
          return this._latlng;
        },
        setLatLng: function(latlng) {
          this._latlng = toLatLng(latlng);
          if (this._map) {
            this._updatePosition();
            this._adjustPan();
          }
          return this;
        },
        getContent: function() {
          return this._content;
        },
        setContent: function(content) {
          this._content = content;
          this.update();
          return this;
        },
        getElement: function() {
          return this._container;
        },
        update: function() {
          if (!this._map) {
            return;
          }
          this._container.style.visibility = "hidden";
          this._updateContent();
          this._updateLayout();
          this._updatePosition();
          this._container.style.visibility = "";
          this._adjustPan();
        },
        getEvents: function() {
          var events = {
            zoom: this._updatePosition,
            viewreset: this._updatePosition
          };
          if (this._zoomAnimated) {
            events.zoomanim = this._animateZoom;
          }
          return events;
        },
        isOpen: function() {
          return !!this._map && this._map.hasLayer(this);
        },
        bringToFront: function() {
          if (this._map) {
            toFront(this._container);
          }
          return this;
        },
        bringToBack: function() {
          if (this._map) {
            toBack(this._container);
          }
          return this;
        },
        _prepareOpen: function(latlng) {
          var source = this._source;
          if (!source._map) {
            return false;
          }
          if (source instanceof FeatureGroup) {
            source = null;
            var layers2 = this._source._layers;
            for (var id in layers2) {
              if (layers2[id]._map) {
                source = layers2[id];
                break;
              }
            }
            if (!source) {
              return false;
            }
            this._source = source;
          }
          if (!latlng) {
            if (source.getCenter) {
              latlng = source.getCenter();
            } else if (source.getLatLng) {
              latlng = source.getLatLng();
            } else if (source.getBounds) {
              latlng = source.getBounds().getCenter();
            } else {
              throw new Error("Unable to get source layer LatLng.");
            }
          }
          this.setLatLng(latlng);
          if (this._map) {
            this.update();
          }
          return true;
        },
        _updateContent: function() {
          if (!this._content) {
            return;
          }
          var node = this._contentNode;
          var content = typeof this._content === "function" ? this._content(this._source || this) : this._content;
          if (typeof content === "string") {
            node.innerHTML = content;
          } else {
            while (node.hasChildNodes()) {
              node.removeChild(node.firstChild);
            }
            node.appendChild(content);
          }
          this.fire("contentupdate");
        },
        _updatePosition: function() {
          if (!this._map) {
            return;
          }
          var pos = this._map.latLngToLayerPoint(this._latlng), offset = toPoint2(this.options.offset), anchor = this._getAnchor();
          if (this._zoomAnimated) {
            setPosition(this._container, pos.add(anchor));
          } else {
            offset = offset.add(pos).add(anchor);
          }
          var bottom = this._containerBottom = -offset.y, left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;
          this._container.style.bottom = bottom + "px";
          this._container.style.left = left + "px";
        },
        _getAnchor: function() {
          return [0, 0];
        }
      });
      Map.include({
        _initOverlay: function(OverlayClass, content, latlng, options) {
          var overlay = content;
          if (!(overlay instanceof OverlayClass)) {
            overlay = new OverlayClass(options).setContent(content);
          }
          if (latlng) {
            overlay.setLatLng(latlng);
          }
          return overlay;
        }
      });
      Layer.include({
        _initOverlay: function(OverlayClass, old, content, options) {
          var overlay = content;
          if (overlay instanceof OverlayClass) {
            setOptions(overlay, options);
            overlay._source = this;
          } else {
            overlay = old && !options ? old : new OverlayClass(options, this);
            overlay.setContent(content);
          }
          return overlay;
        }
      });
      var Popup = DivOverlay.extend({
        options: {
          pane: "popupPane",
          offset: [0, 7],
          maxWidth: 300,
          minWidth: 50,
          maxHeight: null,
          autoPan: true,
          autoPanPaddingTopLeft: null,
          autoPanPaddingBottomRight: null,
          autoPanPadding: [5, 5],
          keepInView: false,
          closeButton: true,
          autoClose: true,
          closeOnEscapeKey: true,
          className: ""
        },
        openOn: function(map) {
          map = arguments.length ? map : this._source._map;
          if (!map.hasLayer(this) && map._popup && map._popup.options.autoClose) {
            map.removeLayer(map._popup);
          }
          map._popup = this;
          return DivOverlay.prototype.openOn.call(this, map);
        },
        onAdd: function(map) {
          DivOverlay.prototype.onAdd.call(this, map);
          map.fire("popupopen", { popup: this });
          if (this._source) {
            this._source.fire("popupopen", { popup: this }, true);
            if (!(this._source instanceof Path)) {
              this._source.on("preclick", stopPropagation);
            }
          }
        },
        onRemove: function(map) {
          DivOverlay.prototype.onRemove.call(this, map);
          map.fire("popupclose", { popup: this });
          if (this._source) {
            this._source.fire("popupclose", { popup: this }, true);
            if (!(this._source instanceof Path)) {
              this._source.off("preclick", stopPropagation);
            }
          }
        },
        getEvents: function() {
          var events = DivOverlay.prototype.getEvents.call(this);
          if (this.options.closeOnClick !== void 0 ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
            events.preclick = this.close;
          }
          if (this.options.keepInView) {
            events.moveend = this._adjustPan;
          }
          return events;
        },
        _initLayout: function() {
          var prefix = "leaflet-popup", container = this._container = create$1(
            "div",
            prefix + " " + (this.options.className || "") + " leaflet-zoom-animated"
          );
          var wrapper = this._wrapper = create$1("div", prefix + "-content-wrapper", container);
          this._contentNode = create$1("div", prefix + "-content", wrapper);
          disableClickPropagation(container);
          disableScrollPropagation(this._contentNode);
          on(container, "contextmenu", stopPropagation);
          this._tipContainer = create$1("div", prefix + "-tip-container", container);
          this._tip = create$1("div", prefix + "-tip", this._tipContainer);
          if (this.options.closeButton) {
            var closeButton = this._closeButton = create$1("a", prefix + "-close-button", container);
            closeButton.setAttribute("role", "button");
            closeButton.setAttribute("aria-label", "Close popup");
            closeButton.href = "#close";
            closeButton.innerHTML = '<span aria-hidden="true">&#215;</span>';
            on(closeButton, "click", function(ev) {
              preventDefault(ev);
              this.close();
            }, this);
          }
        },
        _updateLayout: function() {
          var container = this._contentNode, style2 = container.style;
          style2.width = "";
          style2.whiteSpace = "nowrap";
          var width = container.offsetWidth;
          width = Math.min(width, this.options.maxWidth);
          width = Math.max(width, this.options.minWidth);
          style2.width = width + 1 + "px";
          style2.whiteSpace = "";
          style2.height = "";
          var height = container.offsetHeight, maxHeight = this.options.maxHeight, scrolledClass = "leaflet-popup-scrolled";
          if (maxHeight && height > maxHeight) {
            style2.height = maxHeight + "px";
            addClass(container, scrolledClass);
          } else {
            removeClass(container, scrolledClass);
          }
          this._containerWidth = this._container.offsetWidth;
        },
        _animateZoom: function(e) {
          var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center), anchor = this._getAnchor();
          setPosition(this._container, pos.add(anchor));
        },
        _adjustPan: function() {
          if (!this.options.autoPan) {
            return;
          }
          if (this._map._panAnim) {
            this._map._panAnim.stop();
          }
          if (this._autopanning) {
            this._autopanning = false;
            return;
          }
          var map = this._map, marginBottom = parseInt(getStyle(this._container, "marginBottom"), 10) || 0, containerHeight = this._container.offsetHeight + marginBottom, containerWidth = this._containerWidth, layerPos = new Point2(this._containerLeft, -containerHeight - this._containerBottom);
          layerPos._add(getPosition(this._container));
          var containerPos = map.layerPointToContainerPoint(layerPos), padding = toPoint2(this.options.autoPanPadding), paddingTL = toPoint2(this.options.autoPanPaddingTopLeft || padding), paddingBR = toPoint2(this.options.autoPanPaddingBottomRight || padding), size = map.getSize(), dx = 0, dy = 0;
          if (containerPos.x + containerWidth + paddingBR.x > size.x) {
            dx = containerPos.x + containerWidth - size.x + paddingBR.x;
          }
          if (containerPos.x - dx - paddingTL.x < 0) {
            dx = containerPos.x - paddingTL.x;
          }
          if (containerPos.y + containerHeight + paddingBR.y > size.y) {
            dy = containerPos.y + containerHeight - size.y + paddingBR.y;
          }
          if (containerPos.y - dy - paddingTL.y < 0) {
            dy = containerPos.y - paddingTL.y;
          }
          if (dx || dy) {
            if (this.options.keepInView) {
              this._autopanning = true;
            }
            map.fire("autopanstart").panBy([dx, dy]);
          }
        },
        _getAnchor: function() {
          return toPoint2(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
        }
      });
      var popup = function(options, source) {
        return new Popup(options, source);
      };
      Map.mergeOptions({
        closePopupOnClick: true
      });
      Map.include({
        openPopup: function(popup2, latlng, options) {
          this._initOverlay(Popup, popup2, latlng, options).openOn(this);
          return this;
        },
        closePopup: function(popup2) {
          popup2 = arguments.length ? popup2 : this._popup;
          if (popup2) {
            popup2.close();
          }
          return this;
        }
      });
      Layer.include({
        bindPopup: function(content, options) {
          this._popup = this._initOverlay(Popup, this._popup, content, options);
          if (!this._popupHandlersAdded) {
            this.on({
              click: this._openPopup,
              keypress: this._onKeyPress,
              remove: this.closePopup,
              move: this._movePopup
            });
            this._popupHandlersAdded = true;
          }
          return this;
        },
        unbindPopup: function() {
          if (this._popup) {
            this.off({
              click: this._openPopup,
              keypress: this._onKeyPress,
              remove: this.closePopup,
              move: this._movePopup
            });
            this._popupHandlersAdded = false;
            this._popup = null;
          }
          return this;
        },
        openPopup: function(latlng) {
          if (this._popup) {
            if (!(this instanceof FeatureGroup)) {
              this._popup._source = this;
            }
            if (this._popup._prepareOpen(latlng || this._latlng)) {
              this._popup.openOn(this._map);
            }
          }
          return this;
        },
        closePopup: function() {
          if (this._popup) {
            this._popup.close();
          }
          return this;
        },
        togglePopup: function() {
          if (this._popup) {
            this._popup.toggle(this);
          }
          return this;
        },
        isPopupOpen: function() {
          return this._popup ? this._popup.isOpen() : false;
        },
        setPopupContent: function(content) {
          if (this._popup) {
            this._popup.setContent(content);
          }
          return this;
        },
        getPopup: function() {
          return this._popup;
        },
        _openPopup: function(e) {
          if (!this._popup || !this._map) {
            return;
          }
          stop(e);
          var target = e.layer || e.target;
          if (this._popup._source === target && !(target instanceof Path)) {
            if (this._map.hasLayer(this._popup)) {
              this.closePopup();
            } else {
              this.openPopup(e.latlng);
            }
            return;
          }
          this._popup._source = target;
          this.openPopup(e.latlng);
        },
        _movePopup: function(e) {
          this._popup.setLatLng(e.latlng);
        },
        _onKeyPress: function(e) {
          if (e.originalEvent.keyCode === 13) {
            this._openPopup(e);
          }
        }
      });
      var Tooltip = DivOverlay.extend({
        options: {
          pane: "tooltipPane",
          offset: [0, 0],
          direction: "auto",
          permanent: false,
          sticky: false,
          opacity: 0.9
        },
        onAdd: function(map) {
          DivOverlay.prototype.onAdd.call(this, map);
          this.setOpacity(this.options.opacity);
          map.fire("tooltipopen", { tooltip: this });
          if (this._source) {
            this.addEventParent(this._source);
            this._source.fire("tooltipopen", { tooltip: this }, true);
          }
        },
        onRemove: function(map) {
          DivOverlay.prototype.onRemove.call(this, map);
          map.fire("tooltipclose", { tooltip: this });
          if (this._source) {
            this.removeEventParent(this._source);
            this._source.fire("tooltipclose", { tooltip: this }, true);
          }
        },
        getEvents: function() {
          var events = DivOverlay.prototype.getEvents.call(this);
          if (!this.options.permanent) {
            events.preclick = this.close;
          }
          return events;
        },
        _initLayout: function() {
          var prefix = "leaflet-tooltip", className = prefix + " " + (this.options.className || "") + " leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
          this._contentNode = this._container = create$1("div", className);
          this._container.setAttribute("role", "tooltip");
          this._container.setAttribute("id", "leaflet-tooltip-" + stamp(this));
        },
        _updateLayout: function() {
        },
        _adjustPan: function() {
        },
        _setPosition: function(pos) {
          var subX, subY, map = this._map, container = this._container, centerPoint = map.latLngToContainerPoint(map.getCenter()), tooltipPoint = map.layerPointToContainerPoint(pos), direction = this.options.direction, tooltipWidth = container.offsetWidth, tooltipHeight = container.offsetHeight, offset = toPoint2(this.options.offset), anchor = this._getAnchor();
          if (direction === "top") {
            subX = tooltipWidth / 2;
            subY = tooltipHeight;
          } else if (direction === "bottom") {
            subX = tooltipWidth / 2;
            subY = 0;
          } else if (direction === "center") {
            subX = tooltipWidth / 2;
            subY = tooltipHeight / 2;
          } else if (direction === "right") {
            subX = 0;
            subY = tooltipHeight / 2;
          } else if (direction === "left") {
            subX = tooltipWidth;
            subY = tooltipHeight / 2;
          } else if (tooltipPoint.x < centerPoint.x) {
            direction = "right";
            subX = 0;
            subY = tooltipHeight / 2;
          } else {
            direction = "left";
            subX = tooltipWidth + (offset.x + anchor.x) * 2;
            subY = tooltipHeight / 2;
          }
          pos = pos.subtract(toPoint2(subX, subY, true)).add(offset).add(anchor);
          removeClass(container, "leaflet-tooltip-right");
          removeClass(container, "leaflet-tooltip-left");
          removeClass(container, "leaflet-tooltip-top");
          removeClass(container, "leaflet-tooltip-bottom");
          addClass(container, "leaflet-tooltip-" + direction);
          setPosition(container, pos);
        },
        _updatePosition: function() {
          var pos = this._map.latLngToLayerPoint(this._latlng);
          this._setPosition(pos);
        },
        setOpacity: function(opacity) {
          this.options.opacity = opacity;
          if (this._container) {
            setOpacity(this._container, opacity);
          }
        },
        _animateZoom: function(e) {
          var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);
          this._setPosition(pos);
        },
        _getAnchor: function() {
          return toPoint2(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
        }
      });
      var tooltip = function(options, source) {
        return new Tooltip(options, source);
      };
      Map.include({
        openTooltip: function(tooltip2, latlng, options) {
          this._initOverlay(Tooltip, tooltip2, latlng, options).openOn(this);
          return this;
        },
        closeTooltip: function(tooltip2) {
          tooltip2.close();
          return this;
        }
      });
      Layer.include({
        bindTooltip: function(content, options) {
          if (this._tooltip && this.isTooltipOpen()) {
            this.unbindTooltip();
          }
          this._tooltip = this._initOverlay(Tooltip, this._tooltip, content, options);
          this._initTooltipInteractions();
          if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {
            this.openTooltip();
          }
          return this;
        },
        unbindTooltip: function() {
          if (this._tooltip) {
            this._initTooltipInteractions(true);
            this.closeTooltip();
            this._tooltip = null;
          }
          return this;
        },
        _initTooltipInteractions: function(remove2) {
          if (!remove2 && this._tooltipHandlersAdded) {
            return;
          }
          var onOff = remove2 ? "off" : "on", events = {
            remove: this.closeTooltip,
            move: this._moveTooltip
          };
          if (!this._tooltip.options.permanent) {
            events.mouseover = this._openTooltip;
            events.mouseout = this.closeTooltip;
            events.click = this._openTooltip;
            if (this._map) {
              this._addFocusListeners();
            } else {
              events.add = this._addFocusListeners;
            }
          } else {
            events.add = this._openTooltip;
          }
          if (this._tooltip.options.sticky) {
            events.mousemove = this._moveTooltip;
          }
          this[onOff](events);
          this._tooltipHandlersAdded = !remove2;
        },
        openTooltip: function(latlng) {
          if (this._tooltip) {
            if (!(this instanceof FeatureGroup)) {
              this._tooltip._source = this;
            }
            if (this._tooltip._prepareOpen(latlng)) {
              this._tooltip.openOn(this._map);
              if (this.getElement) {
                this._setAriaDescribedByOnLayer(this);
              } else if (this.eachLayer) {
                this.eachLayer(this._setAriaDescribedByOnLayer, this);
              }
            }
          }
          return this;
        },
        closeTooltip: function() {
          if (this._tooltip) {
            return this._tooltip.close();
          }
        },
        toggleTooltip: function() {
          if (this._tooltip) {
            this._tooltip.toggle(this);
          }
          return this;
        },
        isTooltipOpen: function() {
          return this._tooltip.isOpen();
        },
        setTooltipContent: function(content) {
          if (this._tooltip) {
            this._tooltip.setContent(content);
          }
          return this;
        },
        getTooltip: function() {
          return this._tooltip;
        },
        _addFocusListeners: function() {
          if (this.getElement) {
            this._addFocusListenersOnLayer(this);
          } else if (this.eachLayer) {
            this.eachLayer(this._addFocusListenersOnLayer, this);
          }
        },
        _addFocusListenersOnLayer: function(layer) {
          var el = typeof layer.getElement === "function" && layer.getElement();
          if (el) {
            on(el, "focus", function() {
              this._tooltip._source = layer;
              this.openTooltip();
            }, this);
            on(el, "blur", this.closeTooltip, this);
          }
        },
        _setAriaDescribedByOnLayer: function(layer) {
          var el = typeof layer.getElement === "function" && layer.getElement();
          if (el) {
            el.setAttribute("aria-describedby", this._tooltip._container.id);
          }
        },
        _openTooltip: function(e) {
          if (!this._tooltip || !this._map) {
            return;
          }
          if (this._map.dragging && this._map.dragging.moving() && !this._openOnceFlag) {
            this._openOnceFlag = true;
            var that = this;
            this._map.once("moveend", function() {
              that._openOnceFlag = false;
              that._openTooltip(e);
            });
            return;
          }
          this._tooltip._source = e.layer || e.target;
          this.openTooltip(this._tooltip.options.sticky ? e.latlng : void 0);
        },
        _moveTooltip: function(e) {
          var latlng = e.latlng, containerPoint, layerPoint;
          if (this._tooltip.options.sticky && e.originalEvent) {
            containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);
            layerPoint = this._map.containerPointToLayerPoint(containerPoint);
            latlng = this._map.layerPointToLatLng(layerPoint);
          }
          this._tooltip.setLatLng(latlng);
        }
      });
      var DivIcon = Icon.extend({
        options: {
          iconSize: [12, 12],
          html: false,
          bgPos: null,
          className: "leaflet-div-icon"
        },
        createIcon: function(oldIcon) {
          var div = oldIcon && oldIcon.tagName === "DIV" ? oldIcon : document.createElement("div"), options = this.options;
          if (options.html instanceof Element) {
            empty(div);
            div.appendChild(options.html);
          } else {
            div.innerHTML = options.html !== false ? options.html : "";
          }
          if (options.bgPos) {
            var bgPos = toPoint2(options.bgPos);
            div.style.backgroundPosition = -bgPos.x + "px " + -bgPos.y + "px";
          }
          this._setIconStyles(div, "icon");
          return div;
        },
        createShadow: function() {
          return null;
        }
      });
      function divIcon(options) {
        return new DivIcon(options);
      }
      Icon.Default = IconDefault;
      var GridLayer2 = Layer.extend({
        options: {
          tileSize: 256,
          opacity: 1,
          updateWhenIdle: Browser2.mobile,
          updateWhenZooming: true,
          updateInterval: 200,
          zIndex: 1,
          bounds: null,
          minZoom: 0,
          maxZoom: void 0,
          maxNativeZoom: void 0,
          minNativeZoom: void 0,
          noWrap: false,
          pane: "tilePane",
          className: "",
          keepBuffer: 2
        },
        initialize: function(options) {
          setOptions(this, options);
        },
        onAdd: function() {
          this._initContainer();
          this._levels = {};
          this._tiles = {};
          this._resetView();
        },
        beforeAdd: function(map) {
          map._addZoomLimit(this);
        },
        onRemove: function(map) {
          this._removeAllTiles();
          remove(this._container);
          map._removeZoomLimit(this);
          this._container = null;
          this._tileZoom = void 0;
        },
        bringToFront: function() {
          if (this._map) {
            toFront(this._container);
            this._setAutoZIndex(Math.max);
          }
          return this;
        },
        bringToBack: function() {
          if (this._map) {
            toBack(this._container);
            this._setAutoZIndex(Math.min);
          }
          return this;
        },
        getContainer: function() {
          return this._container;
        },
        setOpacity: function(opacity) {
          this.options.opacity = opacity;
          this._updateOpacity();
          return this;
        },
        setZIndex: function(zIndex) {
          this.options.zIndex = zIndex;
          this._updateZIndex();
          return this;
        },
        isLoading: function() {
          return this._loading;
        },
        redraw: function() {
          if (this._map) {
            this._removeAllTiles();
            var tileZoom = this._clampZoom(this._map.getZoom());
            if (tileZoom !== this._tileZoom) {
              this._tileZoom = tileZoom;
              this._updateLevels();
            }
            this._update();
          }
          return this;
        },
        getEvents: function() {
          var events = {
            viewprereset: this._invalidateAll,
            viewreset: this._resetView,
            zoom: this._resetView,
            moveend: this._onMoveEnd
          };
          if (!this.options.updateWhenIdle) {
            if (!this._onMove) {
              this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);
            }
            events.move = this._onMove;
          }
          if (this._zoomAnimated) {
            events.zoomanim = this._animateZoom;
          }
          return events;
        },
        createTile: function() {
          return document.createElement("div");
        },
        getTileSize: function() {
          var s = this.options.tileSize;
          return s instanceof Point2 ? s : new Point2(s, s);
        },
        _updateZIndex: function() {
          if (this._container && this.options.zIndex !== void 0 && this.options.zIndex !== null) {
            this._container.style.zIndex = this.options.zIndex;
          }
        },
        _setAutoZIndex: function(compare) {
          var layers2 = this.getPane().children, edgeZIndex = -compare(-Infinity, Infinity);
          for (var i = 0, len = layers2.length, zIndex; i < len; i++) {
            zIndex = layers2[i].style.zIndex;
            if (layers2[i] !== this._container && zIndex) {
              edgeZIndex = compare(edgeZIndex, +zIndex);
            }
          }
          if (isFinite(edgeZIndex)) {
            this.options.zIndex = edgeZIndex + compare(-1, 1);
            this._updateZIndex();
          }
        },
        _updateOpacity: function() {
          if (!this._map) {
            return;
          }
          if (Browser2.ielt9) {
            return;
          }
          setOpacity(this._container, this.options.opacity);
          var now = +new Date(), nextFrame = false, willPrune = false;
          for (var key in this._tiles) {
            var tile = this._tiles[key];
            if (!tile.current || !tile.loaded) {
              continue;
            }
            var fade = Math.min(1, (now - tile.loaded) / 200);
            setOpacity(tile.el, fade);
            if (fade < 1) {
              nextFrame = true;
            } else {
              if (tile.active) {
                willPrune = true;
              } else {
                this._onOpaqueTile(tile);
              }
              tile.active = true;
            }
          }
          if (willPrune && !this._noPrune) {
            this._pruneTiles();
          }
          if (nextFrame) {
            cancelAnimFrame(this._fadeFrame);
            this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
          }
        },
        _onOpaqueTile: falseFn,
        _initContainer: function() {
          if (this._container) {
            return;
          }
          this._container = create$1("div", "leaflet-layer " + (this.options.className || ""));
          this._updateZIndex();
          if (this.options.opacity < 1) {
            this._updateOpacity();
          }
          this.getPane().appendChild(this._container);
        },
        _updateLevels: function() {
          var zoom2 = this._tileZoom, maxZoom = this.options.maxZoom;
          if (zoom2 === void 0) {
            return void 0;
          }
          for (var z in this._levels) {
            z = Number(z);
            if (this._levels[z].el.children.length || z === zoom2) {
              this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom2 - z);
              this._onUpdateLevel(z);
            } else {
              remove(this._levels[z].el);
              this._removeTilesAtZoom(z);
              this._onRemoveLevel(z);
              delete this._levels[z];
            }
          }
          var level = this._levels[zoom2], map = this._map;
          if (!level) {
            level = this._levels[zoom2] = {};
            level.el = create$1("div", "leaflet-tile-container leaflet-zoom-animated", this._container);
            level.el.style.zIndex = maxZoom;
            level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom2).round();
            level.zoom = zoom2;
            this._setZoomTransform(level, map.getCenter(), map.getZoom());
            falseFn(level.el.offsetWidth);
            this._onCreateLevel(level);
          }
          this._level = level;
          return level;
        },
        _onUpdateLevel: falseFn,
        _onRemoveLevel: falseFn,
        _onCreateLevel: falseFn,
        _pruneTiles: function() {
          if (!this._map) {
            return;
          }
          var key, tile;
          var zoom2 = this._map.getZoom();
          if (zoom2 > this.options.maxZoom || zoom2 < this.options.minZoom) {
            this._removeAllTiles();
            return;
          }
          for (key in this._tiles) {
            tile = this._tiles[key];
            tile.retain = tile.current;
          }
          for (key in this._tiles) {
            tile = this._tiles[key];
            if (tile.current && !tile.active) {
              var coords = tile.coords;
              if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
                this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
              }
            }
          }
          for (key in this._tiles) {
            if (!this._tiles[key].retain) {
              this._removeTile(key);
            }
          }
        },
        _removeTilesAtZoom: function(zoom2) {
          for (var key in this._tiles) {
            if (this._tiles[key].coords.z !== zoom2) {
              continue;
            }
            this._removeTile(key);
          }
        },
        _removeAllTiles: function() {
          for (var key in this._tiles) {
            this._removeTile(key);
          }
        },
        _invalidateAll: function() {
          for (var z in this._levels) {
            remove(this._levels[z].el);
            this._onRemoveLevel(Number(z));
            delete this._levels[z];
          }
          this._removeAllTiles();
          this._tileZoom = void 0;
        },
        _retainParent: function(x, y, z, minZoom) {
          var x2 = Math.floor(x / 2), y2 = Math.floor(y / 2), z2 = z - 1, coords2 = new Point2(+x2, +y2);
          coords2.z = +z2;
          var key = this._tileCoordsToKey(coords2), tile = this._tiles[key];
          if (tile && tile.active) {
            tile.retain = true;
            return true;
          } else if (tile && tile.loaded) {
            tile.retain = true;
          }
          if (z2 > minZoom) {
            return this._retainParent(x2, y2, z2, minZoom);
          }
          return false;
        },
        _retainChildren: function(x, y, z, maxZoom) {
          for (var i = 2 * x; i < 2 * x + 2; i++) {
            for (var j = 2 * y; j < 2 * y + 2; j++) {
              var coords = new Point2(i, j);
              coords.z = z + 1;
              var key = this._tileCoordsToKey(coords), tile = this._tiles[key];
              if (tile && tile.active) {
                tile.retain = true;
                continue;
              } else if (tile && tile.loaded) {
                tile.retain = true;
              }
              if (z + 1 < maxZoom) {
                this._retainChildren(i, j, z + 1, maxZoom);
              }
            }
          }
        },
        _resetView: function(e) {
          var animating = e && (e.pinch || e.flyTo);
          this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
        },
        _animateZoom: function(e) {
          this._setView(e.center, e.zoom, true, e.noUpdate);
        },
        _clampZoom: function(zoom2) {
          var options = this.options;
          if (void 0 !== options.minNativeZoom && zoom2 < options.minNativeZoom) {
            return options.minNativeZoom;
          }
          if (void 0 !== options.maxNativeZoom && options.maxNativeZoom < zoom2) {
            return options.maxNativeZoom;
          }
          return zoom2;
        },
        _setView: function(center, zoom2, noPrune, noUpdate) {
          var tileZoom = Math.round(zoom2);
          if (this.options.maxZoom !== void 0 && tileZoom > this.options.maxZoom || this.options.minZoom !== void 0 && tileZoom < this.options.minZoom) {
            tileZoom = void 0;
          } else {
            tileZoom = this._clampZoom(tileZoom);
          }
          var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;
          if (!noUpdate || tileZoomChanged) {
            this._tileZoom = tileZoom;
            if (this._abortLoading) {
              this._abortLoading();
            }
            this._updateLevels();
            this._resetGrid();
            if (tileZoom !== void 0) {
              this._update(center);
            }
            if (!noPrune) {
              this._pruneTiles();
            }
            this._noPrune = !!noPrune;
          }
          this._setZoomTransforms(center, zoom2);
        },
        _setZoomTransforms: function(center, zoom2) {
          for (var i in this._levels) {
            this._setZoomTransform(this._levels[i], center, zoom2);
          }
        },
        _setZoomTransform: function(level, center, zoom2) {
          var scale2 = this._map.getZoomScale(zoom2, level.zoom), translate = level.origin.multiplyBy(scale2).subtract(this._map._getNewPixelOrigin(center, zoom2)).round();
          if (Browser2.any3d) {
            setTransform(level.el, translate, scale2);
          } else {
            setPosition(level.el, translate);
          }
        },
        _resetGrid: function() {
          var map = this._map, crs = map.options.crs, tileSize = this._tileSize = this.getTileSize(), tileZoom = this._tileZoom;
          var bounds = this._map.getPixelWorldBounds(this._tileZoom);
          if (bounds) {
            this._globalTileRange = this._pxBoundsToTileRange(bounds);
          }
          this._wrapX = crs.wrapLng && !this.options.noWrap && [
            Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x),
            Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)
          ];
          this._wrapY = crs.wrapLat && !this.options.noWrap && [
            Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x),
            Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)
          ];
        },
        _onMoveEnd: function() {
          if (!this._map || this._map._animatingZoom) {
            return;
          }
          this._update();
        },
        _getTiledPixelBounds: function(center) {
          var map = this._map, mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(), scale2 = map.getZoomScale(mapZoom, this._tileZoom), pixelCenter = map.project(center, this._tileZoom).floor(), halfSize = map.getSize().divideBy(scale2 * 2);
          return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
        },
        _update: function(center) {
          var map = this._map;
          if (!map) {
            return;
          }
          var zoom2 = this._clampZoom(map.getZoom());
          if (center === void 0) {
            center = map.getCenter();
          }
          if (this._tileZoom === void 0) {
            return;
          }
          var pixelBounds = this._getTiledPixelBounds(center), tileRange = this._pxBoundsToTileRange(pixelBounds), tileCenter = tileRange.getCenter(), queue = [], margin = this.options.keepBuffer, noPruneRange = new Bounds(
            tileRange.getBottomLeft().subtract([margin, -margin]),
            tileRange.getTopRight().add([margin, -margin])
          );
          if (!(isFinite(tileRange.min.x) && isFinite(tileRange.min.y) && isFinite(tileRange.max.x) && isFinite(tileRange.max.y))) {
            throw new Error("Attempted to load an infinite number of tiles");
          }
          for (var key in this._tiles) {
            var c = this._tiles[key].coords;
            if (c.z !== this._tileZoom || !noPruneRange.contains(new Point2(c.x, c.y))) {
              this._tiles[key].current = false;
            }
          }
          if (Math.abs(zoom2 - this._tileZoom) > 1) {
            this._setView(center, zoom2);
            return;
          }
          for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
            for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
              var coords = new Point2(i, j);
              coords.z = this._tileZoom;
              if (!this._isValidTile(coords)) {
                continue;
              }
              var tile = this._tiles[this._tileCoordsToKey(coords)];
              if (tile) {
                tile.current = true;
              } else {
                queue.push(coords);
              }
            }
          }
          queue.sort(function(a, b) {
            return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
          });
          if (queue.length !== 0) {
            if (!this._loading) {
              this._loading = true;
              this.fire("loading");
            }
            var fragment = document.createDocumentFragment();
            for (i = 0; i < queue.length; i++) {
              this._addTile(queue[i], fragment);
            }
            this._level.el.appendChild(fragment);
          }
        },
        _isValidTile: function(coords) {
          var crs = this._map.options.crs;
          if (!crs.infinite) {
            var bounds = this._globalTileRange;
            if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {
              return false;
            }
          }
          if (!this.options.bounds) {
            return true;
          }
          var tileBounds = this._tileCoordsToBounds(coords);
          return toLatLngBounds(this.options.bounds).overlaps(tileBounds);
        },
        _keyToBounds: function(key) {
          return this._tileCoordsToBounds(this._keyToTileCoords(key));
        },
        _tileCoordsToNwSe: function(coords) {
          var map = this._map, tileSize = this.getTileSize(), nwPoint = coords.scaleBy(tileSize), sePoint = nwPoint.add(tileSize), nw = map.unproject(nwPoint, coords.z), se = map.unproject(sePoint, coords.z);
          return [nw, se];
        },
        _tileCoordsToBounds: function(coords) {
          var bp = this._tileCoordsToNwSe(coords), bounds = new LatLngBounds2(bp[0], bp[1]);
          if (!this.options.noWrap) {
            bounds = this._map.wrapLatLngBounds(bounds);
          }
          return bounds;
        },
        _tileCoordsToKey: function(coords) {
          return coords.x + ":" + coords.y + ":" + coords.z;
        },
        _keyToTileCoords: function(key) {
          var k = key.split(":"), coords = new Point2(+k[0], +k[1]);
          coords.z = +k[2];
          return coords;
        },
        _removeTile: function(key) {
          var tile = this._tiles[key];
          if (!tile) {
            return;
          }
          remove(tile.el);
          delete this._tiles[key];
          this.fire("tileunload", {
            tile: tile.el,
            coords: this._keyToTileCoords(key)
          });
        },
        _initTile: function(tile) {
          addClass(tile, "leaflet-tile");
          var tileSize = this.getTileSize();
          tile.style.width = tileSize.x + "px";
          tile.style.height = tileSize.y + "px";
          tile.onselectstart = falseFn;
          tile.onmousemove = falseFn;
          if (Browser2.ielt9 && this.options.opacity < 1) {
            setOpacity(tile, this.options.opacity);
          }
        },
        _addTile: function(coords, container) {
          var tilePos = this._getTilePos(coords), key = this._tileCoordsToKey(coords);
          var tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));
          this._initTile(tile);
          if (this.createTile.length < 2) {
            requestAnimFrame(bind(this._tileReady, this, coords, null, tile));
          }
          setPosition(tile, tilePos);
          this._tiles[key] = {
            el: tile,
            coords,
            current: true
          };
          container.appendChild(tile);
          this.fire("tileloadstart", {
            tile,
            coords
          });
        },
        _tileReady: function(coords, err, tile) {
          if (err) {
            this.fire("tileerror", {
              error: err,
              tile,
              coords
            });
          }
          var key = this._tileCoordsToKey(coords);
          tile = this._tiles[key];
          if (!tile) {
            return;
          }
          tile.loaded = +new Date();
          if (this._map._fadeAnimated) {
            setOpacity(tile.el, 0);
            cancelAnimFrame(this._fadeFrame);
            this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
          } else {
            tile.active = true;
            this._pruneTiles();
          }
          if (!err) {
            addClass(tile.el, "leaflet-tile-loaded");
            this.fire("tileload", {
              tile: tile.el,
              coords
            });
          }
          if (this._noTilesToLoad()) {
            this._loading = false;
            this.fire("load");
            if (Browser2.ielt9 || !this._map._fadeAnimated) {
              requestAnimFrame(this._pruneTiles, this);
            } else {
              setTimeout(bind(this._pruneTiles, this), 250);
            }
          }
        },
        _getTilePos: function(coords) {
          return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
        },
        _wrapCoords: function(coords) {
          var newCoords = new Point2(
            this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x,
            this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y
          );
          newCoords.z = coords.z;
          return newCoords;
        },
        _pxBoundsToTileRange: function(bounds) {
          var tileSize = this.getTileSize();
          return new Bounds(
            bounds.min.unscaleBy(tileSize).floor(),
            bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1])
          );
        },
        _noTilesToLoad: function() {
          for (var key in this._tiles) {
            if (!this._tiles[key].loaded) {
              return false;
            }
          }
          return true;
        }
      });
      function gridLayer(options) {
        return new GridLayer2(options);
      }
      var TileLayer = GridLayer2.extend({
        options: {
          minZoom: 0,
          maxZoom: 18,
          subdomains: "abc",
          errorTileUrl: "",
          zoomOffset: 0,
          tms: false,
          zoomReverse: false,
          detectRetina: false,
          crossOrigin: false,
          referrerPolicy: false
        },
        initialize: function(url, options) {
          this._url = url;
          options = setOptions(this, options);
          if (options.detectRetina && Browser2.retina && options.maxZoom > 0) {
            options.tileSize = Math.floor(options.tileSize / 2);
            if (!options.zoomReverse) {
              options.zoomOffset++;
              options.maxZoom = Math.max(options.minZoom, options.maxZoom - 1);
            } else {
              options.zoomOffset--;
              options.minZoom = Math.min(options.maxZoom, options.minZoom + 1);
            }
            options.minZoom = Math.max(0, options.minZoom);
          } else if (!options.zoomReverse) {
            options.maxZoom = Math.max(options.minZoom, options.maxZoom);
          } else {
            options.minZoom = Math.min(options.maxZoom, options.minZoom);
          }
          if (typeof options.subdomains === "string") {
            options.subdomains = options.subdomains.split("");
          }
          this.on("tileunload", this._onTileRemove);
        },
        setUrl: function(url, noRedraw) {
          if (this._url === url && noRedraw === void 0) {
            noRedraw = true;
          }
          this._url = url;
          if (!noRedraw) {
            this.redraw();
          }
          return this;
        },
        createTile: function(coords, done) {
          var tile = document.createElement("img");
          on(tile, "load", bind(this._tileOnLoad, this, done, tile));
          on(tile, "error", bind(this._tileOnError, this, done, tile));
          if (this.options.crossOrigin || this.options.crossOrigin === "") {
            tile.crossOrigin = this.options.crossOrigin === true ? "" : this.options.crossOrigin;
          }
          if (typeof this.options.referrerPolicy === "string") {
            tile.referrerPolicy = this.options.referrerPolicy;
          }
          tile.alt = "";
          tile.src = this.getTileUrl(coords);
          return tile;
        },
        getTileUrl: function(coords) {
          var data = {
            r: Browser2.retina ? "@2x" : "",
            s: this._getSubdomain(coords),
            x: coords.x,
            y: coords.y,
            z: this._getZoomForUrl()
          };
          if (this._map && !this._map.options.crs.infinite) {
            var invertedY = this._globalTileRange.max.y - coords.y;
            if (this.options.tms) {
              data["y"] = invertedY;
            }
            data["-y"] = invertedY;
          }
          return template(this._url, extend(data, this.options));
        },
        _tileOnLoad: function(done, tile) {
          if (Browser2.ielt9) {
            setTimeout(bind(done, this, null, tile), 0);
          } else {
            done(null, tile);
          }
        },
        _tileOnError: function(done, tile, e) {
          var errorUrl = this.options.errorTileUrl;
          if (errorUrl && tile.getAttribute("src") !== errorUrl) {
            tile.src = errorUrl;
          }
          done(e, tile);
        },
        _onTileRemove: function(e) {
          e.tile.onload = null;
        },
        _getZoomForUrl: function() {
          var zoom2 = this._tileZoom, maxZoom = this.options.maxZoom, zoomReverse = this.options.zoomReverse, zoomOffset = this.options.zoomOffset;
          if (zoomReverse) {
            zoom2 = maxZoom - zoom2;
          }
          return zoom2 + zoomOffset;
        },
        _getSubdomain: function(tilePoint) {
          var index2 = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
          return this.options.subdomains[index2];
        },
        _abortLoading: function() {
          var i, tile;
          for (i in this._tiles) {
            if (this._tiles[i].coords.z !== this._tileZoom) {
              tile = this._tiles[i].el;
              tile.onload = falseFn;
              tile.onerror = falseFn;
              if (!tile.complete) {
                tile.src = emptyImageUrl;
                var coords = this._tiles[i].coords;
                remove(tile);
                delete this._tiles[i];
                this.fire("tileabort", {
                  tile,
                  coords
                });
              }
            }
          }
        },
        _removeTile: function(key) {
          var tile = this._tiles[key];
          if (!tile) {
            return;
          }
          tile.el.setAttribute("src", emptyImageUrl);
          return GridLayer2.prototype._removeTile.call(this, key);
        },
        _tileReady: function(coords, err, tile) {
          if (!this._map || tile && tile.getAttribute("src") === emptyImageUrl) {
            return;
          }
          return GridLayer2.prototype._tileReady.call(this, coords, err, tile);
        }
      });
      function tileLayer(url, options) {
        return new TileLayer(url, options);
      }
      var TileLayerWMS = TileLayer.extend({
        defaultWmsParams: {
          service: "WMS",
          request: "GetMap",
          layers: "",
          styles: "",
          format: "image/jpeg",
          transparent: false,
          version: "1.1.1"
        },
        options: {
          crs: null,
          uppercase: false
        },
        initialize: function(url, options) {
          this._url = url;
          var wmsParams = extend({}, this.defaultWmsParams);
          for (var i in options) {
            if (!(i in this.options)) {
              wmsParams[i] = options[i];
            }
          }
          options = setOptions(this, options);
          var realRetina = options.detectRetina && Browser2.retina ? 2 : 1;
          var tileSize = this.getTileSize();
          wmsParams.width = tileSize.x * realRetina;
          wmsParams.height = tileSize.y * realRetina;
          this.wmsParams = wmsParams;
        },
        onAdd: function(map) {
          this._crs = this.options.crs || map.options.crs;
          this._wmsVersion = parseFloat(this.wmsParams.version);
          var projectionKey = this._wmsVersion >= 1.3 ? "crs" : "srs";
          this.wmsParams[projectionKey] = this._crs.code;
          TileLayer.prototype.onAdd.call(this, map);
        },
        getTileUrl: function(coords) {
          var tileBounds = this._tileCoordsToNwSe(coords), crs = this._crs, bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])), min = bounds.min, max = bounds.max, bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG43262 ? [min.y, min.x, max.y, max.x] : [min.x, min.y, max.x, max.y]).join(","), url = TileLayer.prototype.getTileUrl.call(this, coords);
          return url + getParamString(this.wmsParams, url, this.options.uppercase) + (this.options.uppercase ? "&BBOX=" : "&bbox=") + bbox;
        },
        setParams: function(params2, noRedraw) {
          extend(this.wmsParams, params2);
          if (!noRedraw) {
            this.redraw();
          }
          return this;
        }
      });
      function tileLayerWMS(url, options) {
        return new TileLayerWMS(url, options);
      }
      TileLayer.WMS = TileLayerWMS;
      tileLayer.wms = tileLayerWMS;
      var Renderer = Layer.extend({
        options: {
          padding: 0.1
        },
        initialize: function(options) {
          setOptions(this, options);
          stamp(this);
          this._layers = this._layers || {};
        },
        onAdd: function() {
          if (!this._container) {
            this._initContainer();
            addClass(this._container, "leaflet-zoom-animated");
          }
          this.getPane().appendChild(this._container);
          this._update();
          this.on("update", this._updatePaths, this);
        },
        onRemove: function() {
          this.off("update", this._updatePaths, this);
          this._destroyContainer();
        },
        getEvents: function() {
          var events = {
            viewreset: this._reset,
            zoom: this._onZoom,
            moveend: this._update,
            zoomend: this._onZoomEnd
          };
          if (this._zoomAnimated) {
            events.zoomanim = this._onAnimZoom;
          }
          return events;
        },
        _onAnimZoom: function(ev) {
          this._updateTransform(ev.center, ev.zoom);
        },
        _onZoom: function() {
          this._updateTransform(this._map.getCenter(), this._map.getZoom());
        },
        _updateTransform: function(center, zoom2) {
          var scale2 = this._map.getZoomScale(zoom2, this._zoom), viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding), currentCenterPoint = this._map.project(this._center, zoom2), topLeftOffset = viewHalf.multiplyBy(-scale2).add(currentCenterPoint).subtract(this._map._getNewPixelOrigin(center, zoom2));
          if (Browser2.any3d) {
            setTransform(this._container, topLeftOffset, scale2);
          } else {
            setPosition(this._container, topLeftOffset);
          }
        },
        _reset: function() {
          this._update();
          this._updateTransform(this._center, this._zoom);
          for (var id in this._layers) {
            this._layers[id]._reset();
          }
        },
        _onZoomEnd: function() {
          for (var id in this._layers) {
            this._layers[id]._project();
          }
        },
        _updatePaths: function() {
          for (var id in this._layers) {
            this._layers[id]._update();
          }
        },
        _update: function() {
          var p = this.options.padding, size = this._map.getSize(), min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();
          this._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());
          this._center = this._map.getCenter();
          this._zoom = this._map.getZoom();
        }
      });
      var Canvas = Renderer.extend({
        options: {
          tolerance: 0
        },
        getEvents: function() {
          var events = Renderer.prototype.getEvents.call(this);
          events.viewprereset = this._onViewPreReset;
          return events;
        },
        _onViewPreReset: function() {
          this._postponeUpdatePaths = true;
        },
        onAdd: function() {
          Renderer.prototype.onAdd.call(this);
          this._draw();
        },
        _initContainer: function() {
          var container = this._container = document.createElement("canvas");
          on(container, "mousemove", this._onMouseMove, this);
          on(container, "click dblclick mousedown mouseup contextmenu", this._onClick, this);
          on(container, "mouseout", this._handleMouseOut, this);
          container["_leaflet_disable_events"] = true;
          this._ctx = container.getContext("2d");
        },
        _destroyContainer: function() {
          cancelAnimFrame(this._redrawRequest);
          delete this._ctx;
          remove(this._container);
          off(this._container);
          delete this._container;
        },
        _updatePaths: function() {
          if (this._postponeUpdatePaths) {
            return;
          }
          var layer;
          this._redrawBounds = null;
          for (var id in this._layers) {
            layer = this._layers[id];
            layer._update();
          }
          this._redraw();
        },
        _update: function() {
          if (this._map._animatingZoom && this._bounds) {
            return;
          }
          Renderer.prototype._update.call(this);
          var b = this._bounds, container = this._container, size = b.getSize(), m = Browser2.retina ? 2 : 1;
          setPosition(container, b.min);
          container.width = m * size.x;
          container.height = m * size.y;
          container.style.width = size.x + "px";
          container.style.height = size.y + "px";
          if (Browser2.retina) {
            this._ctx.scale(2, 2);
          }
          this._ctx.translate(-b.min.x, -b.min.y);
          this.fire("update");
        },
        _reset: function() {
          Renderer.prototype._reset.call(this);
          if (this._postponeUpdatePaths) {
            this._postponeUpdatePaths = false;
            this._updatePaths();
          }
        },
        _initPath: function(layer) {
          this._updateDashArray(layer);
          this._layers[stamp(layer)] = layer;
          var order = layer._order = {
            layer,
            prev: this._drawLast,
            next: null
          };
          if (this._drawLast) {
            this._drawLast.next = order;
          }
          this._drawLast = order;
          this._drawFirst = this._drawFirst || this._drawLast;
        },
        _addPath: function(layer) {
          this._requestRedraw(layer);
        },
        _removePath: function(layer) {
          var order = layer._order;
          var next = order.next;
          var prev = order.prev;
          if (next) {
            next.prev = prev;
          } else {
            this._drawLast = prev;
          }
          if (prev) {
            prev.next = next;
          } else {
            this._drawFirst = next;
          }
          delete layer._order;
          delete this._layers[stamp(layer)];
          this._requestRedraw(layer);
        },
        _updatePath: function(layer) {
          this._extendRedrawBounds(layer);
          layer._project();
          layer._update();
          this._requestRedraw(layer);
        },
        _updateStyle: function(layer) {
          this._updateDashArray(layer);
          this._requestRedraw(layer);
        },
        _updateDashArray: function(layer) {
          if (typeof layer.options.dashArray === "string") {
            var parts = layer.options.dashArray.split(/[, ]+/), dashArray = [], dashValue, i;
            for (i = 0; i < parts.length; i++) {
              dashValue = Number(parts[i]);
              if (isNaN(dashValue)) {
                return;
              }
              dashArray.push(dashValue);
            }
            layer.options._dashArray = dashArray;
          } else {
            layer.options._dashArray = layer.options.dashArray;
          }
        },
        _requestRedraw: function(layer) {
          if (!this._map) {
            return;
          }
          this._extendRedrawBounds(layer);
          this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);
        },
        _extendRedrawBounds: function(layer) {
          if (layer._pxBounds) {
            var padding = (layer.options.weight || 0) + 1;
            this._redrawBounds = this._redrawBounds || new Bounds();
            this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));
            this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));
          }
        },
        _redraw: function() {
          this._redrawRequest = null;
          if (this._redrawBounds) {
            this._redrawBounds.min._floor();
            this._redrawBounds.max._ceil();
          }
          this._clear();
          this._draw();
          this._redrawBounds = null;
        },
        _clear: function() {
          var bounds = this._redrawBounds;
          if (bounds) {
            var size = bounds.getSize();
            this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);
          } else {
            this._ctx.save();
            this._ctx.setTransform(1, 0, 0, 1, 0, 0);
            this._ctx.clearRect(0, 0, this._container.width, this._container.height);
            this._ctx.restore();
          }
        },
        _draw: function() {
          var layer, bounds = this._redrawBounds;
          this._ctx.save();
          if (bounds) {
            var size = bounds.getSize();
            this._ctx.beginPath();
            this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);
            this._ctx.clip();
          }
          this._drawing = true;
          for (var order = this._drawFirst; order; order = order.next) {
            layer = order.layer;
            if (!bounds || layer._pxBounds && layer._pxBounds.intersects(bounds)) {
              layer._updatePath();
            }
          }
          this._drawing = false;
          this._ctx.restore();
        },
        _updatePoly: function(layer, closed) {
          if (!this._drawing) {
            return;
          }
          var i, j, len2, p, parts = layer._parts, len = parts.length, ctx = this._ctx;
          if (!len) {
            return;
          }
          ctx.beginPath();
          for (i = 0; i < len; i++) {
            for (j = 0, len2 = parts[i].length; j < len2; j++) {
              p = parts[i][j];
              ctx[j ? "lineTo" : "moveTo"](p.x, p.y);
            }
            if (closed) {
              ctx.closePath();
            }
          }
          this._fillStroke(ctx, layer);
        },
        _updateCircle: function(layer) {
          if (!this._drawing || layer._empty()) {
            return;
          }
          var p = layer._point, ctx = this._ctx, r = Math.max(Math.round(layer._radius), 1), s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;
          if (s !== 1) {
            ctx.save();
            ctx.scale(1, s);
          }
          ctx.beginPath();
          ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);
          if (s !== 1) {
            ctx.restore();
          }
          this._fillStroke(ctx, layer);
        },
        _fillStroke: function(ctx, layer) {
          var options = layer.options;
          if (options.fill) {
            ctx.globalAlpha = options.fillOpacity;
            ctx.fillStyle = options.fillColor || options.color;
            ctx.fill(options.fillRule || "evenodd");
          }
          if (options.stroke && options.weight !== 0) {
            if (ctx.setLineDash) {
              ctx.setLineDash(layer.options && layer.options._dashArray || []);
            }
            ctx.globalAlpha = options.opacity;
            ctx.lineWidth = options.weight;
            ctx.strokeStyle = options.color;
            ctx.lineCap = options.lineCap;
            ctx.lineJoin = options.lineJoin;
            ctx.stroke();
          }
        },
        _onClick: function(e) {
          var point3 = this._map.mouseEventToLayerPoint(e), layer, clickedLayer;
          for (var order = this._drawFirst; order; order = order.next) {
            layer = order.layer;
            if (layer.options.interactive && layer._containsPoint(point3)) {
              if (!(e.type === "click" || e.type === "preclick") || !this._map._draggableMoved(layer)) {
                clickedLayer = layer;
              }
            }
          }
          this._fireEvent(clickedLayer ? [clickedLayer] : false, e);
        },
        _onMouseMove: function(e) {
          if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) {
            return;
          }
          var point3 = this._map.mouseEventToLayerPoint(e);
          this._handleMouseHover(e, point3);
        },
        _handleMouseOut: function(e) {
          var layer = this._hoveredLayer;
          if (layer) {
            removeClass(this._container, "leaflet-interactive");
            this._fireEvent([layer], e, "mouseout");
            this._hoveredLayer = null;
            this._mouseHoverThrottled = false;
          }
        },
        _handleMouseHover: function(e, point3) {
          if (this._mouseHoverThrottled) {
            return;
          }
          var layer, candidateHoveredLayer;
          for (var order = this._drawFirst; order; order = order.next) {
            layer = order.layer;
            if (layer.options.interactive && layer._containsPoint(point3)) {
              candidateHoveredLayer = layer;
            }
          }
          if (candidateHoveredLayer !== this._hoveredLayer) {
            this._handleMouseOut(e);
            if (candidateHoveredLayer) {
              addClass(this._container, "leaflet-interactive");
              this._fireEvent([candidateHoveredLayer], e, "mouseover");
              this._hoveredLayer = candidateHoveredLayer;
            }
          }
          this._fireEvent(this._hoveredLayer ? [this._hoveredLayer] : false, e);
          this._mouseHoverThrottled = true;
          setTimeout(bind(function() {
            this._mouseHoverThrottled = false;
          }, this), 32);
        },
        _fireEvent: function(layers2, e, type) {
          this._map._fireDOMEvent(e, type || e.type, layers2);
        },
        _bringToFront: function(layer) {
          var order = layer._order;
          if (!order) {
            return;
          }
          var next = order.next;
          var prev = order.prev;
          if (next) {
            next.prev = prev;
          } else {
            return;
          }
          if (prev) {
            prev.next = next;
          } else if (next) {
            this._drawFirst = next;
          }
          order.prev = this._drawLast;
          this._drawLast.next = order;
          order.next = null;
          this._drawLast = order;
          this._requestRedraw(layer);
        },
        _bringToBack: function(layer) {
          var order = layer._order;
          if (!order) {
            return;
          }
          var next = order.next;
          var prev = order.prev;
          if (prev) {
            prev.next = next;
          } else {
            return;
          }
          if (next) {
            next.prev = prev;
          } else if (prev) {
            this._drawLast = prev;
          }
          order.prev = null;
          order.next = this._drawFirst;
          this._drawFirst.prev = order;
          this._drawFirst = order;
          this._requestRedraw(layer);
        }
      });
      function canvas(options) {
        return Browser2.canvas ? new Canvas(options) : null;
      }
      var vmlCreate = function() {
        try {
          document.namespaces.add("lvml", "urn:schemas-microsoft-com:vml");
          return function(name) {
            return document.createElement("<lvml:" + name + ' class="lvml">');
          };
        } catch (e) {
        }
        return function(name) {
          return document.createElement("<" + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
        };
      }();
      var vmlMixin = {
        _initContainer: function() {
          this._container = create$1("div", "leaflet-vml-container");
        },
        _update: function() {
          if (this._map._animatingZoom) {
            return;
          }
          Renderer.prototype._update.call(this);
          this.fire("update");
        },
        _initPath: function(layer) {
          var container = layer._container = vmlCreate("shape");
          addClass(container, "leaflet-vml-shape " + (this.options.className || ""));
          container.coordsize = "1 1";
          layer._path = vmlCreate("path");
          container.appendChild(layer._path);
          this._updateStyle(layer);
          this._layers[stamp(layer)] = layer;
        },
        _addPath: function(layer) {
          var container = layer._container;
          this._container.appendChild(container);
          if (layer.options.interactive) {
            layer.addInteractiveTarget(container);
          }
        },
        _removePath: function(layer) {
          var container = layer._container;
          remove(container);
          layer.removeInteractiveTarget(container);
          delete this._layers[stamp(layer)];
        },
        _updateStyle: function(layer) {
          var stroke = layer._stroke, fill = layer._fill, options = layer.options, container = layer._container;
          container.stroked = !!options.stroke;
          container.filled = !!options.fill;
          if (options.stroke) {
            if (!stroke) {
              stroke = layer._stroke = vmlCreate("stroke");
            }
            container.appendChild(stroke);
            stroke.weight = options.weight + "px";
            stroke.color = options.color;
            stroke.opacity = options.opacity;
            if (options.dashArray) {
              stroke.dashStyle = isArray(options.dashArray) ? options.dashArray.join(" ") : options.dashArray.replace(/( *, *)/g, " ");
            } else {
              stroke.dashStyle = "";
            }
            stroke.endcap = options.lineCap.replace("butt", "flat");
            stroke.joinstyle = options.lineJoin;
          } else if (stroke) {
            container.removeChild(stroke);
            layer._stroke = null;
          }
          if (options.fill) {
            if (!fill) {
              fill = layer._fill = vmlCreate("fill");
            }
            container.appendChild(fill);
            fill.color = options.fillColor || options.color;
            fill.opacity = options.fillOpacity;
          } else if (fill) {
            container.removeChild(fill);
            layer._fill = null;
          }
        },
        _updateCircle: function(layer) {
          var p = layer._point.round(), r = Math.round(layer._radius), r2 = Math.round(layer._radiusY || r);
          this._setPath(layer, layer._empty() ? "M0 0" : "AL " + p.x + "," + p.y + " " + r + "," + r2 + " 0," + 65535 * 360);
        },
        _setPath: function(layer, path) {
          layer._path.v = path;
        },
        _bringToFront: function(layer) {
          toFront(layer._container);
        },
        _bringToBack: function(layer) {
          toBack(layer._container);
        }
      };
      var create2 = Browser2.vml ? vmlCreate : svgCreate;
      var SVG = Renderer.extend({
        _initContainer: function() {
          this._container = create2("svg");
          this._container.setAttribute("pointer-events", "none");
          this._rootGroup = create2("g");
          this._container.appendChild(this._rootGroup);
        },
        _destroyContainer: function() {
          remove(this._container);
          off(this._container);
          delete this._container;
          delete this._rootGroup;
          delete this._svgSize;
        },
        _update: function() {
          if (this._map._animatingZoom && this._bounds) {
            return;
          }
          Renderer.prototype._update.call(this);
          var b = this._bounds, size = b.getSize(), container = this._container;
          if (!this._svgSize || !this._svgSize.equals(size)) {
            this._svgSize = size;
            container.setAttribute("width", size.x);
            container.setAttribute("height", size.y);
          }
          setPosition(container, b.min);
          container.setAttribute("viewBox", [b.min.x, b.min.y, size.x, size.y].join(" "));
          this.fire("update");
        },
        _initPath: function(layer) {
          var path = layer._path = create2("path");
          if (layer.options.className) {
            addClass(path, layer.options.className);
          }
          if (layer.options.interactive) {
            addClass(path, "leaflet-interactive");
          }
          this._updateStyle(layer);
          this._layers[stamp(layer)] = layer;
        },
        _addPath: function(layer) {
          if (!this._rootGroup) {
            this._initContainer();
          }
          this._rootGroup.appendChild(layer._path);
          layer.addInteractiveTarget(layer._path);
        },
        _removePath: function(layer) {
          remove(layer._path);
          layer.removeInteractiveTarget(layer._path);
          delete this._layers[stamp(layer)];
        },
        _updatePath: function(layer) {
          layer._project();
          layer._update();
        },
        _updateStyle: function(layer) {
          var path = layer._path, options = layer.options;
          if (!path) {
            return;
          }
          if (options.stroke) {
            path.setAttribute("stroke", options.color);
            path.setAttribute("stroke-opacity", options.opacity);
            path.setAttribute("stroke-width", options.weight);
            path.setAttribute("stroke-linecap", options.lineCap);
            path.setAttribute("stroke-linejoin", options.lineJoin);
            if (options.dashArray) {
              path.setAttribute("stroke-dasharray", options.dashArray);
            } else {
              path.removeAttribute("stroke-dasharray");
            }
            if (options.dashOffset) {
              path.setAttribute("stroke-dashoffset", options.dashOffset);
            } else {
              path.removeAttribute("stroke-dashoffset");
            }
          } else {
            path.setAttribute("stroke", "none");
          }
          if (options.fill) {
            path.setAttribute("fill", options.fillColor || options.color);
            path.setAttribute("fill-opacity", options.fillOpacity);
            path.setAttribute("fill-rule", options.fillRule || "evenodd");
          } else {
            path.setAttribute("fill", "none");
          }
        },
        _updatePoly: function(layer, closed) {
          this._setPath(layer, pointsToPath(layer._parts, closed));
        },
        _updateCircle: function(layer) {
          var p = layer._point, r = Math.max(Math.round(layer._radius), 1), r2 = Math.max(Math.round(layer._radiusY), 1) || r, arc = "a" + r + "," + r2 + " 0 1,0 ";
          var d = layer._empty() ? "M0 0" : "M" + (p.x - r) + "," + p.y + arc + r * 2 + ",0 " + arc + -r * 2 + ",0 ";
          this._setPath(layer, d);
        },
        _setPath: function(layer, path) {
          layer._path.setAttribute("d", path);
        },
        _bringToFront: function(layer) {
          toFront(layer._path);
        },
        _bringToBack: function(layer) {
          toBack(layer._path);
        }
      });
      if (Browser2.vml) {
        SVG.include(vmlMixin);
      }
      function svg(options) {
        return Browser2.svg || Browser2.vml ? new SVG(options) : null;
      }
      Map.include({
        getRenderer: function(layer) {
          var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;
          if (!renderer) {
            renderer = this._renderer = this._createRenderer();
          }
          if (!this.hasLayer(renderer)) {
            this.addLayer(renderer);
          }
          return renderer;
        },
        _getPaneRenderer: function(name) {
          if (name === "overlayPane" || name === void 0) {
            return false;
          }
          var renderer = this._paneRenderers[name];
          if (renderer === void 0) {
            renderer = this._createRenderer({ pane: name });
            this._paneRenderers[name] = renderer;
          }
          return renderer;
        },
        _createRenderer: function(options) {
          return this.options.preferCanvas && canvas(options) || svg(options);
        }
      });
      var Rectangle = Polygon.extend({
        initialize: function(latLngBounds2, options) {
          Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds2), options);
        },
        setBounds: function(latLngBounds2) {
          return this.setLatLngs(this._boundsToLatLngs(latLngBounds2));
        },
        _boundsToLatLngs: function(latLngBounds2) {
          latLngBounds2 = toLatLngBounds(latLngBounds2);
          return [
            latLngBounds2.getSouthWest(),
            latLngBounds2.getNorthWest(),
            latLngBounds2.getNorthEast(),
            latLngBounds2.getSouthEast()
          ];
        }
      });
      function rectangle2(latLngBounds2, options) {
        return new Rectangle(latLngBounds2, options);
      }
      SVG.create = create2;
      SVG.pointsToPath = pointsToPath;
      GeoJSON.geometryToLayer = geometryToLayer;
      GeoJSON.coordsToLatLng = coordsToLatLng;
      GeoJSON.coordsToLatLngs = coordsToLatLngs;
      GeoJSON.latLngToCoords = latLngToCoords;
      GeoJSON.latLngsToCoords = latLngsToCoords;
      GeoJSON.getFeature = getFeature;
      GeoJSON.asFeature = asFeature;
      Map.mergeOptions({
        boxZoom: true
      });
      var BoxZoom = Handler.extend({
        initialize: function(map) {
          this._map = map;
          this._container = map._container;
          this._pane = map._panes.overlayPane;
          this._resetStateTimeout = 0;
          map.on("unload", this._destroy, this);
        },
        addHooks: function() {
          on(this._container, "mousedown", this._onMouseDown, this);
        },
        removeHooks: function() {
          off(this._container, "mousedown", this._onMouseDown, this);
        },
        moved: function() {
          return this._moved;
        },
        _destroy: function() {
          remove(this._pane);
          delete this._pane;
        },
        _resetState: function() {
          this._resetStateTimeout = 0;
          this._moved = false;
        },
        _clearDeferredResetState: function() {
          if (this._resetStateTimeout !== 0) {
            clearTimeout(this._resetStateTimeout);
            this._resetStateTimeout = 0;
          }
        },
        _onMouseDown: function(e) {
          if (!e.shiftKey || e.which !== 1 && e.button !== 1) {
            return false;
          }
          this._clearDeferredResetState();
          this._resetState();
          disableTextSelection();
          disableImageDrag();
          this._startPoint = this._map.mouseEventToContainerPoint(e);
          on(document, {
            contextmenu: stop,
            mousemove: this._onMouseMove,
            mouseup: this._onMouseUp,
            keydown: this._onKeyDown
          }, this);
        },
        _onMouseMove: function(e) {
          if (!this._moved) {
            this._moved = true;
            this._box = create$1("div", "leaflet-zoom-box", this._container);
            addClass(this._container, "leaflet-crosshair");
            this._map.fire("boxzoomstart");
          }
          this._point = this._map.mouseEventToContainerPoint(e);
          var bounds = new Bounds(this._point, this._startPoint), size = bounds.getSize();
          setPosition(this._box, bounds.min);
          this._box.style.width = size.x + "px";
          this._box.style.height = size.y + "px";
        },
        _finish: function() {
          if (this._moved) {
            remove(this._box);
            removeClass(this._container, "leaflet-crosshair");
          }
          enableTextSelection();
          enableImageDrag();
          off(document, {
            contextmenu: stop,
            mousemove: this._onMouseMove,
            mouseup: this._onMouseUp,
            keydown: this._onKeyDown
          }, this);
        },
        _onMouseUp: function(e) {
          if (e.which !== 1 && e.button !== 1) {
            return;
          }
          this._finish();
          if (!this._moved) {
            return;
          }
          this._clearDeferredResetState();
          this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);
          var bounds = new LatLngBounds2(
            this._map.containerPointToLatLng(this._startPoint),
            this._map.containerPointToLatLng(this._point)
          );
          this._map.fitBounds(bounds).fire("boxzoomend", { boxZoomBounds: bounds });
        },
        _onKeyDown: function(e) {
          if (e.keyCode === 27) {
            this._finish();
            this._clearDeferredResetState();
            this._resetState();
          }
        }
      });
      Map.addInitHook("addHandler", "boxZoom", BoxZoom);
      Map.mergeOptions({
        doubleClickZoom: true
      });
      var DoubleClickZoom = Handler.extend({
        addHooks: function() {
          this._map.on("dblclick", this._onDoubleClick, this);
        },
        removeHooks: function() {
          this._map.off("dblclick", this._onDoubleClick, this);
        },
        _onDoubleClick: function(e) {
          var map = this._map, oldZoom = map.getZoom(), delta = map.options.zoomDelta, zoom2 = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;
          if (map.options.doubleClickZoom === "center") {
            map.setZoom(zoom2);
          } else {
            map.setZoomAround(e.containerPoint, zoom2);
          }
        }
      });
      Map.addInitHook("addHandler", "doubleClickZoom", DoubleClickZoom);
      Map.mergeOptions({
        dragging: true,
        inertia: true,
        inertiaDeceleration: 3400,
        inertiaMaxSpeed: Infinity,
        easeLinearity: 0.2,
        worldCopyJump: false,
        maxBoundsViscosity: 0
      });
      var Drag = Handler.extend({
        addHooks: function() {
          if (!this._draggable) {
            var map = this._map;
            this._draggable = new Draggable(map._mapPane, map._container);
            this._draggable.on({
              dragstart: this._onDragStart,
              drag: this._onDrag,
              dragend: this._onDragEnd
            }, this);
            this._draggable.on("predrag", this._onPreDragLimit, this);
            if (map.options.worldCopyJump) {
              this._draggable.on("predrag", this._onPreDragWrap, this);
              map.on("zoomend", this._onZoomEnd, this);
              map.whenReady(this._onZoomEnd, this);
            }
          }
          addClass(this._map._container, "leaflet-grab leaflet-touch-drag");
          this._draggable.enable();
          this._positions = [];
          this._times = [];
        },
        removeHooks: function() {
          removeClass(this._map._container, "leaflet-grab");
          removeClass(this._map._container, "leaflet-touch-drag");
          this._draggable.disable();
        },
        moved: function() {
          return this._draggable && this._draggable._moved;
        },
        moving: function() {
          return this._draggable && this._draggable._moving;
        },
        _onDragStart: function() {
          var map = this._map;
          map._stop();
          if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
            var bounds = toLatLngBounds(this._map.options.maxBounds);
            this._offsetLimit = toBounds(
              this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1),
              this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1).add(this._map.getSize())
            );
            this._viscosity = Math.min(1, Math.max(0, this._map.options.maxBoundsViscosity));
          } else {
            this._offsetLimit = null;
          }
          map.fire("movestart").fire("dragstart");
          if (map.options.inertia) {
            this._positions = [];
            this._times = [];
          }
        },
        _onDrag: function(e) {
          if (this._map.options.inertia) {
            var time = this._lastTime = +new Date(), pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;
            this._positions.push(pos);
            this._times.push(time);
            this._prunePositions(time);
          }
          this._map.fire("move", e).fire("drag", e);
        },
        _prunePositions: function(time) {
          while (this._positions.length > 1 && time - this._times[0] > 50) {
            this._positions.shift();
            this._times.shift();
          }
        },
        _onZoomEnd: function() {
          var pxCenter = this._map.getSize().divideBy(2), pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);
          this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
          this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
        },
        _viscousLimit: function(value, threshold) {
          return value - (value - threshold) * this._viscosity;
        },
        _onPreDragLimit: function() {
          if (!this._viscosity || !this._offsetLimit) {
            return;
          }
          var offset = this._draggable._newPos.subtract(this._draggable._startPos);
          var limit = this._offsetLimit;
          if (offset.x < limit.min.x) {
            offset.x = this._viscousLimit(offset.x, limit.min.x);
          }
          if (offset.y < limit.min.y) {
            offset.y = this._viscousLimit(offset.y, limit.min.y);
          }
          if (offset.x > limit.max.x) {
            offset.x = this._viscousLimit(offset.x, limit.max.x);
          }
          if (offset.y > limit.max.y) {
            offset.y = this._viscousLimit(offset.y, limit.max.y);
          }
          this._draggable._newPos = this._draggable._startPos.add(offset);
        },
        _onPreDragWrap: function() {
          var worldWidth = this._worldWidth, halfWidth = Math.round(worldWidth / 2), dx = this._initialWorldOffset, x = this._draggable._newPos.x, newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx, newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx, newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;
          this._draggable._absPos = this._draggable._newPos.clone();
          this._draggable._newPos.x = newX;
        },
        _onDragEnd: function(e) {
          var map = this._map, options = map.options, noInertia = !options.inertia || e.noInertia || this._times.length < 2;
          map.fire("dragend", e);
          if (noInertia) {
            map.fire("moveend");
          } else {
            this._prunePositions(+new Date());
            var direction = this._lastPos.subtract(this._positions[0]), duration = (this._lastTime - this._times[0]) / 1e3, ease = options.easeLinearity, speedVector = direction.multiplyBy(ease / duration), speed = speedVector.distanceTo([0, 0]), limitedSpeed = Math.min(options.inertiaMaxSpeed, speed), limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed), decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease), offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();
            if (!offset.x && !offset.y) {
              map.fire("moveend");
            } else {
              offset = map._limitOffset(offset, map.options.maxBounds);
              requestAnimFrame(function() {
                map.panBy(offset, {
                  duration: decelerationDuration,
                  easeLinearity: ease,
                  noMoveStart: true,
                  animate: true
                });
              });
            }
          }
        }
      });
      Map.addInitHook("addHandler", "dragging", Drag);
      Map.mergeOptions({
        keyboard: true,
        keyboardPanDelta: 80
      });
      var Keyboard = Handler.extend({
        keyCodes: {
          left: [37],
          right: [39],
          down: [40],
          up: [38],
          zoomIn: [187, 107, 61, 171],
          zoomOut: [189, 109, 54, 173]
        },
        initialize: function(map) {
          this._map = map;
          this._setPanDelta(map.options.keyboardPanDelta);
          this._setZoomDelta(map.options.zoomDelta);
        },
        addHooks: function() {
          var container = this._map._container;
          if (container.tabIndex <= 0) {
            container.tabIndex = "0";
          }
          on(container, {
            focus: this._onFocus,
            blur: this._onBlur,
            mousedown: this._onMouseDown
          }, this);
          this._map.on({
            focus: this._addHooks,
            blur: this._removeHooks
          }, this);
        },
        removeHooks: function() {
          this._removeHooks();
          off(this._map._container, {
            focus: this._onFocus,
            blur: this._onBlur,
            mousedown: this._onMouseDown
          }, this);
          this._map.off({
            focus: this._addHooks,
            blur: this._removeHooks
          }, this);
        },
        _onMouseDown: function() {
          if (this._focused) {
            return;
          }
          var body = document.body, docEl = document.documentElement, top = body.scrollTop || docEl.scrollTop, left = body.scrollLeft || docEl.scrollLeft;
          this._map._container.focus();
          window.scrollTo(left, top);
        },
        _onFocus: function() {
          this._focused = true;
          this._map.fire("focus");
        },
        _onBlur: function() {
          this._focused = false;
          this._map.fire("blur");
        },
        _setPanDelta: function(panDelta) {
          var keys = this._panKeys = {}, codes2 = this.keyCodes, i, len;
          for (i = 0, len = codes2.left.length; i < len; i++) {
            keys[codes2.left[i]] = [-1 * panDelta, 0];
          }
          for (i = 0, len = codes2.right.length; i < len; i++) {
            keys[codes2.right[i]] = [panDelta, 0];
          }
          for (i = 0, len = codes2.down.length; i < len; i++) {
            keys[codes2.down[i]] = [0, panDelta];
          }
          for (i = 0, len = codes2.up.length; i < len; i++) {
            keys[codes2.up[i]] = [0, -1 * panDelta];
          }
        },
        _setZoomDelta: function(zoomDelta) {
          var keys = this._zoomKeys = {}, codes2 = this.keyCodes, i, len;
          for (i = 0, len = codes2.zoomIn.length; i < len; i++) {
            keys[codes2.zoomIn[i]] = zoomDelta;
          }
          for (i = 0, len = codes2.zoomOut.length; i < len; i++) {
            keys[codes2.zoomOut[i]] = -zoomDelta;
          }
        },
        _addHooks: function() {
          on(document, "keydown", this._onKeyDown, this);
        },
        _removeHooks: function() {
          off(document, "keydown", this._onKeyDown, this);
        },
        _onKeyDown: function(e) {
          if (e.altKey || e.ctrlKey || e.metaKey) {
            return;
          }
          var key = e.keyCode, map = this._map, offset;
          if (key in this._panKeys) {
            if (!map._panAnim || !map._panAnim._inProgress) {
              offset = this._panKeys[key];
              if (e.shiftKey) {
                offset = toPoint2(offset).multiplyBy(3);
              }
              if (map.options.maxBounds) {
                offset = map._limitOffset(toPoint2(offset), map.options.maxBounds);
              }
              if (map.options.worldCopyJump) {
                var newLatLng = map.wrapLatLng(map.unproject(map.project(map.getCenter()).add(offset)));
                map.panTo(newLatLng);
              } else {
                map.panBy(offset);
              }
            }
          } else if (key in this._zoomKeys) {
            map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);
          } else if (key === 27 && map._popup && map._popup.options.closeOnEscapeKey) {
            map.closePopup();
          } else {
            return;
          }
          stop(e);
        }
      });
      Map.addInitHook("addHandler", "keyboard", Keyboard);
      Map.mergeOptions({
        scrollWheelZoom: true,
        wheelDebounceTime: 40,
        wheelPxPerZoomLevel: 60
      });
      var ScrollWheelZoom = Handler.extend({
        addHooks: function() {
          on(this._map._container, "wheel", this._onWheelScroll, this);
          this._delta = 0;
        },
        removeHooks: function() {
          off(this._map._container, "wheel", this._onWheelScroll, this);
        },
        _onWheelScroll: function(e) {
          var delta = getWheelDelta(e);
          var debounce = this._map.options.wheelDebounceTime;
          this._delta += delta;
          this._lastMousePos = this._map.mouseEventToContainerPoint(e);
          if (!this._startTime) {
            this._startTime = +new Date();
          }
          var left = Math.max(debounce - (+new Date() - this._startTime), 0);
          clearTimeout(this._timer);
          this._timer = setTimeout(bind(this._performZoom, this), left);
          stop(e);
        },
        _performZoom: function() {
          var map = this._map, zoom2 = map.getZoom(), snap2 = this._map.options.zoomSnap || 0;
          map._stop();
          var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4), d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2, d4 = snap2 ? Math.ceil(d3 / snap2) * snap2 : d3, delta = map._limitZoom(zoom2 + (this._delta > 0 ? d4 : -d4)) - zoom2;
          this._delta = 0;
          this._startTime = null;
          if (!delta) {
            return;
          }
          if (map.options.scrollWheelZoom === "center") {
            map.setZoom(zoom2 + delta);
          } else {
            map.setZoomAround(this._lastMousePos, zoom2 + delta);
          }
        }
      });
      Map.addInitHook("addHandler", "scrollWheelZoom", ScrollWheelZoom);
      var tapHoldDelay = 600;
      Map.mergeOptions({
        tapHold: Browser2.touchNative && Browser2.safari && Browser2.mobile,
        tapTolerance: 15
      });
      var TapHold = Handler.extend({
        addHooks: function() {
          on(this._map._container, "touchstart", this._onDown, this);
        },
        removeHooks: function() {
          off(this._map._container, "touchstart", this._onDown, this);
        },
        _onDown: function(e) {
          clearTimeout(this._holdTimeout);
          if (e.touches.length !== 1) {
            return;
          }
          var first = e.touches[0];
          this._startPos = this._newPos = new Point2(first.clientX, first.clientY);
          this._holdTimeout = setTimeout(bind(function() {
            this._cancel();
            if (!this._isTapValid()) {
              return;
            }
            on(document, "touchend", preventDefault);
            on(document, "touchend touchcancel", this._cancelClickPrevent);
            this._simulateEvent("contextmenu", first);
          }, this), tapHoldDelay);
          on(document, "touchend touchcancel contextmenu", this._cancel, this);
          on(document, "touchmove", this._onMove, this);
        },
        _cancelClickPrevent: function cancelClickPrevent() {
          off(document, "touchend", preventDefault);
          off(document, "touchend touchcancel", cancelClickPrevent);
        },
        _cancel: function() {
          clearTimeout(this._holdTimeout);
          off(document, "touchend touchcancel contextmenu", this._cancel, this);
          off(document, "touchmove", this._onMove, this);
        },
        _onMove: function(e) {
          var first = e.touches[0];
          this._newPos = new Point2(first.clientX, first.clientY);
        },
        _isTapValid: function() {
          return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
        },
        _simulateEvent: function(type, e) {
          var simulatedEvent = new MouseEvent(type, {
            bubbles: true,
            cancelable: true,
            view: window,
            screenX: e.screenX,
            screenY: e.screenY,
            clientX: e.clientX,
            clientY: e.clientY
          });
          simulatedEvent._simulated = true;
          e.target.dispatchEvent(simulatedEvent);
        }
      });
      Map.addInitHook("addHandler", "tapHold", TapHold);
      Map.mergeOptions({
        touchZoom: Browser2.touch,
        bounceAtZoomLimits: true
      });
      var TouchZoom = Handler.extend({
        addHooks: function() {
          addClass(this._map._container, "leaflet-touch-zoom");
          on(this._map._container, "touchstart", this._onTouchStart, this);
        },
        removeHooks: function() {
          removeClass(this._map._container, "leaflet-touch-zoom");
          off(this._map._container, "touchstart", this._onTouchStart, this);
        },
        _onTouchStart: function(e) {
          var map = this._map;
          if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) {
            return;
          }
          var p1 = map.mouseEventToContainerPoint(e.touches[0]), p2 = map.mouseEventToContainerPoint(e.touches[1]);
          this._centerPoint = map.getSize()._divideBy(2);
          this._startLatLng = map.containerPointToLatLng(this._centerPoint);
          if (map.options.touchZoom !== "center") {
            this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));
          }
          this._startDist = p1.distanceTo(p2);
          this._startZoom = map.getZoom();
          this._moved = false;
          this._zooming = true;
          map._stop();
          on(document, "touchmove", this._onTouchMove, this);
          on(document, "touchend touchcancel", this._onTouchEnd, this);
          preventDefault(e);
        },
        _onTouchMove: function(e) {
          if (!e.touches || e.touches.length !== 2 || !this._zooming) {
            return;
          }
          var map = this._map, p1 = map.mouseEventToContainerPoint(e.touches[0]), p2 = map.mouseEventToContainerPoint(e.touches[1]), scale2 = p1.distanceTo(p2) / this._startDist;
          this._zoom = map.getScaleZoom(scale2, this._startZoom);
          if (!map.options.bounceAtZoomLimits && (this._zoom < map.getMinZoom() && scale2 < 1 || this._zoom > map.getMaxZoom() && scale2 > 1)) {
            this._zoom = map._limitZoom(this._zoom);
          }
          if (map.options.touchZoom === "center") {
            this._center = this._startLatLng;
            if (scale2 === 1) {
              return;
            }
          } else {
            var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
            if (scale2 === 1 && delta.x === 0 && delta.y === 0) {
              return;
            }
            this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
          }
          if (!this._moved) {
            map._moveStart(true, false);
            this._moved = true;
          }
          cancelAnimFrame(this._animRequest);
          var moveFn = bind(map._move, map, this._center, this._zoom, { pinch: true, round: false }, void 0);
          this._animRequest = requestAnimFrame(moveFn, this, true);
          preventDefault(e);
        },
        _onTouchEnd: function() {
          if (!this._moved || !this._zooming) {
            this._zooming = false;
            return;
          }
          this._zooming = false;
          cancelAnimFrame(this._animRequest);
          off(document, "touchmove", this._onTouchMove, this);
          off(document, "touchend touchcancel", this._onTouchEnd, this);
          if (this._map.options.zoomAnimation) {
            this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
          } else {
            this._map._resetView(this._center, this._map._limitZoom(this._zoom));
          }
        }
      });
      Map.addInitHook("addHandler", "touchZoom", TouchZoom);
      Map.BoxZoom = BoxZoom;
      Map.DoubleClickZoom = DoubleClickZoom;
      Map.Drag = Drag;
      Map.Keyboard = Keyboard;
      Map.ScrollWheelZoom = ScrollWheelZoom;
      Map.TapHold = TapHold;
      Map.TouchZoom = TouchZoom;
      exports5.Bounds = Bounds;
      exports5.Browser = Browser2;
      exports5.CRS = CRS2;
      exports5.Canvas = Canvas;
      exports5.Circle = Circle;
      exports5.CircleMarker = CircleMarker;
      exports5.Class = Class;
      exports5.Control = Control;
      exports5.DivIcon = DivIcon;
      exports5.DivOverlay = DivOverlay;
      exports5.DomEvent = DomEvent;
      exports5.DomUtil = DomUtil2;
      exports5.Draggable = Draggable;
      exports5.Evented = Evented;
      exports5.FeatureGroup = FeatureGroup;
      exports5.GeoJSON = GeoJSON;
      exports5.GridLayer = GridLayer2;
      exports5.Handler = Handler;
      exports5.Icon = Icon;
      exports5.ImageOverlay = ImageOverlay;
      exports5.LatLng = LatLng;
      exports5.LatLngBounds = LatLngBounds2;
      exports5.Layer = Layer;
      exports5.LayerGroup = LayerGroup;
      exports5.LineUtil = LineUtil;
      exports5.Map = Map;
      exports5.Marker = Marker;
      exports5.Mixin = Mixin;
      exports5.Path = Path;
      exports5.Point = Point2;
      exports5.PolyUtil = PolyUtil;
      exports5.Polygon = Polygon;
      exports5.Polyline = Polyline;
      exports5.Popup = Popup;
      exports5.PosAnimation = PosAnimation;
      exports5.Projection = index;
      exports5.Rectangle = Rectangle;
      exports5.Renderer = Renderer;
      exports5.SVG = SVG;
      exports5.SVGOverlay = SVGOverlay;
      exports5.TileLayer = TileLayer;
      exports5.Tooltip = Tooltip;
      exports5.Transformation = Transformation;
      exports5.Util = Util2;
      exports5.VideoOverlay = VideoOverlay;
      exports5.bind = bind;
      exports5.bounds = toBounds;
      exports5.canvas = canvas;
      exports5.circle = circle;
      exports5.circleMarker = circleMarker;
      exports5.control = control;
      exports5.divIcon = divIcon;
      exports5.extend = extend;
      exports5.featureGroup = featureGroup;
      exports5.geoJSON = geoJSON;
      exports5.geoJson = geoJson;
      exports5.gridLayer = gridLayer;
      exports5.icon = icon;
      exports5.imageOverlay = imageOverlay;
      exports5.latLng = toLatLng;
      exports5.latLngBounds = toLatLngBounds;
      exports5.layerGroup = layerGroup;
      exports5.map = createMap;
      exports5.marker = marker;
      exports5.point = toPoint2;
      exports5.polygon = polygon;
      exports5.polyline = polyline;
      exports5.popup = popup;
      exports5.rectangle = rectangle2;
      exports5.setOptions = setOptions;
      exports5.stamp = stamp;
      exports5.svg = svg;
      exports5.svgOverlay = svgOverlay;
      exports5.tileLayer = tileLayer;
      exports5.tooltip = tooltip;
      exports5.transformation = toTransformation;
      exports5.version = version;
      exports5.videoOverlay = videoOverlay;
      var oldL = window.L;
      exports5.noConflict = function() {
        window.L = oldL;
        return this;
      };
      window.L = exports5;
    });
  }
});

// node_modules/chroma-js/chroma.js
var require_chroma = __commonJS({
  "node_modules/chroma-js/chroma.js"(exports4, module) {
    (function() {
      var Color, DEG2RAD, LAB_CONSTANTS, PI, PITHIRD, RAD2DEG, TWOPI, _average_lrgb, _guess_formats, _guess_formats_sorted, _input, _interpolators, abs, atan2, bezier, blend, blend_f, brewer, burn, chroma2, clip_rgb, cmyk2rgb, colors, cos, css2rgb, darken, dodge, each, floor, hcg2rgb, hex2rgb, hsi2rgb, hsl2css, hsl2rgb, hsv2rgb, interpolate, interpolate_hsx, interpolate_lab, interpolate_lrgb, interpolate_num, interpolate_rgb, lab2lch, lab2rgb, lab_xyz, lch2lab, lch2rgb, lighten, limit, log2, luminance_x, m, max, multiply2, normal, num2rgb, overlay, pow, rgb2cmyk, rgb2css, rgb2hcg, rgb2hex, rgb2hsi, rgb2hsl, rgb2hsv, rgb2lab, rgb2lch, rgb2luminance, rgb2num, rgb2temperature, rgb2xyz, rgb_xyz, rnd, root, round, screen, sin, sqrt, temperature2rgb, type, unpack, w3cx11, xyz_lab, xyz_rgb, slice = [].slice;
      type = function() {
        var classToType, len, name, o, ref;
        classToType = {};
        ref = "Boolean Number String Function Array Date RegExp Undefined Null".split(" ");
        for (o = 0, len = ref.length; o < len; o++) {
          name = ref[o];
          classToType["[object " + name + "]"] = name.toLowerCase();
        }
        return function(obj2) {
          var strType;
          strType = Object.prototype.toString.call(obj2);
          return classToType[strType] || "object";
        };
      }();
      limit = function(x, min, max2) {
        if (min == null) {
          min = 0;
        }
        if (max2 == null) {
          max2 = 1;
        }
        if (x < min) {
          x = min;
        }
        if (x > max2) {
          x = max2;
        }
        return x;
      };
      unpack = function(args) {
        if (args.length >= 3) {
          return Array.prototype.slice.call(args);
        } else {
          return args[0];
        }
      };
      clip_rgb = function(rgb) {
        var i, o;
        rgb._clipped = false;
        rgb._unclipped = rgb.slice(0);
        for (i = o = 0; o < 3; i = ++o) {
          if (i < 3) {
            if (rgb[i] < 0 || rgb[i] > 255) {
              rgb._clipped = true;
            }
            if (rgb[i] < 0) {
              rgb[i] = 0;
            }
            if (rgb[i] > 255) {
              rgb[i] = 255;
            }
          } else if (i === 3) {
            if (rgb[i] < 0) {
              rgb[i] = 0;
            }
            if (rgb[i] > 1) {
              rgb[i] = 1;
            }
          }
        }
        if (!rgb._clipped) {
          delete rgb._unclipped;
        }
        return rgb;
      };
      PI = Math.PI, round = Math.round, cos = Math.cos, floor = Math.floor, pow = Math.pow, log2 = Math.log, sin = Math.sin, sqrt = Math.sqrt, atan2 = Math.atan2, max = Math.max, abs = Math.abs;
      TWOPI = PI * 2;
      PITHIRD = PI / 3;
      DEG2RAD = PI / 180;
      RAD2DEG = 180 / PI;
      chroma2 = function() {
        if (arguments[0] instanceof Color) {
          return arguments[0];
        }
        return function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor(), result2 = func.apply(child, args);
          return Object(result2) === result2 ? result2 : child;
        }(Color, arguments, function() {
        });
      };
      chroma2["default"] = chroma2;
      _interpolators = [];
      if (typeof module !== "undefined" && module !== null && module.exports != null) {
        module.exports = chroma2;
      }
      if (typeof define === "function" && define.amd) {
        define([], function() {
          return chroma2;
        });
      } else {
        root = typeof exports4 !== "undefined" && exports4 !== null ? exports4 : this;
        root.chroma = chroma2;
      }
      chroma2.version = "1.4.1";
      _input = {};
      _guess_formats = [];
      _guess_formats_sorted = false;
      Color = function() {
        function Color2() {
          var arg, args, chk, len, len1, me, mode2, o, w;
          me = this;
          args = [];
          for (o = 0, len = arguments.length; o < len; o++) {
            arg = arguments[o];
            if (arg != null) {
              args.push(arg);
            }
          }
          if (args.length > 1) {
            mode2 = args[args.length - 1];
          }
          if (_input[mode2] != null) {
            me._rgb = clip_rgb(_input[mode2](unpack(args.slice(0, -1))));
          } else {
            if (!_guess_formats_sorted) {
              _guess_formats = _guess_formats.sort(function(a, b) {
                return b.p - a.p;
              });
              _guess_formats_sorted = true;
            }
            for (w = 0, len1 = _guess_formats.length; w < len1; w++) {
              chk = _guess_formats[w];
              mode2 = chk.test.apply(chk, args);
              if (mode2) {
                break;
              }
            }
            if (mode2) {
              me._rgb = clip_rgb(_input[mode2].apply(_input, args));
            }
          }
          if (me._rgb == null) {
            console.warn("unknown format: " + args);
          }
          if (me._rgb == null) {
            me._rgb = [0, 0, 0];
          }
          if (me._rgb.length === 3) {
            me._rgb.push(1);
          }
        }
        Color2.prototype.toString = function() {
          return this.hex();
        };
        return Color2;
      }();
      chroma2._input = _input;
      chroma2.brewer = brewer = {
        OrRd: ["#fff7ec", "#fee8c8", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#b30000", "#7f0000"],
        PuBu: ["#fff7fb", "#ece7f2", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#045a8d", "#023858"],
        BuPu: ["#f7fcfd", "#e0ecf4", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#810f7c", "#4d004b"],
        Oranges: ["#fff5eb", "#fee6ce", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#a63603", "#7f2704"],
        BuGn: ["#f7fcfd", "#e5f5f9", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#006d2c", "#00441b"],
        YlOrBr: ["#ffffe5", "#fff7bc", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#993404", "#662506"],
        YlGn: ["#ffffe5", "#f7fcb9", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#006837", "#004529"],
        Reds: ["#fff5f0", "#fee0d2", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#a50f15", "#67000d"],
        RdPu: ["#fff7f3", "#fde0dd", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177", "#49006a"],
        Greens: ["#f7fcf5", "#e5f5e0", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#006d2c", "#00441b"],
        YlGnBu: ["#ffffd9", "#edf8b1", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#253494", "#081d58"],
        Purples: ["#fcfbfd", "#efedf5", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#54278f", "#3f007d"],
        GnBu: ["#f7fcf0", "#e0f3db", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#0868ac", "#084081"],
        Greys: ["#ffffff", "#f0f0f0", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525", "#000000"],
        YlOrRd: ["#ffffcc", "#ffeda0", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#bd0026", "#800026"],
        PuRd: ["#f7f4f9", "#e7e1ef", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#980043", "#67001f"],
        Blues: ["#f7fbff", "#deebf7", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#08519c", "#08306b"],
        PuBuGn: ["#fff7fb", "#ece2f0", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016c59", "#014636"],
        Viridis: ["#440154", "#482777", "#3f4a8a", "#31678e", "#26838f", "#1f9d8a", "#6cce5a", "#b6de2b", "#fee825"],
        Spectral: ["#9e0142", "#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#e6f598", "#abdda4", "#66c2a5", "#3288bd", "#5e4fa2"],
        RdYlGn: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850", "#006837"],
        RdBu: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#f7f7f7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac", "#053061"],
        PiYG: ["#8e0152", "#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#f7f7f7", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221", "#276419"],
        PRGn: ["#40004b", "#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837", "#00441b"],
        RdYlBu: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee090", "#ffffbf", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4", "#313695"],
        BrBG: ["#543005", "#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#f5f5f5", "#c7eae5", "#80cdc1", "#35978f", "#01665e", "#003c30"],
        RdGy: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#ffffff", "#e0e0e0", "#bababa", "#878787", "#4d4d4d", "#1a1a1a"],
        PuOr: ["#7f3b08", "#b35806", "#e08214", "#fdb863", "#fee0b6", "#f7f7f7", "#d8daeb", "#b2abd2", "#8073ac", "#542788", "#2d004b"],
        Set2: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f", "#e5c494", "#b3b3b3"],
        Accent: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f", "#bf5b17", "#666666"],
        Set1: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628", "#f781bf", "#999999"],
        Set3: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5", "#ffed6f"],
        Dark2: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02", "#a6761d", "#666666"],
        Paired: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a", "#ffff99", "#b15928"],
        Pastel2: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae", "#f1e2cc", "#cccccc"],
        Pastel1: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd", "#fddaec", "#f2f2f2"]
      };
      (function() {
        var key, results;
        results = [];
        for (key in brewer) {
          results.push(brewer[key.toLowerCase()] = brewer[key]);
        }
        return results;
      })();
      w3cx11 = {
        aliceblue: "#f0f8ff",
        antiquewhite: "#faebd7",
        aqua: "#00ffff",
        aquamarine: "#7fffd4",
        azure: "#f0ffff",
        beige: "#f5f5dc",
        bisque: "#ffe4c4",
        black: "#000000",
        blanchedalmond: "#ffebcd",
        blue: "#0000ff",
        blueviolet: "#8a2be2",
        brown: "#a52a2a",
        burlywood: "#deb887",
        cadetblue: "#5f9ea0",
        chartreuse: "#7fff00",
        chocolate: "#d2691e",
        coral: "#ff7f50",
        cornflower: "#6495ed",
        cornflowerblue: "#6495ed",
        cornsilk: "#fff8dc",
        crimson: "#dc143c",
        cyan: "#00ffff",
        darkblue: "#00008b",
        darkcyan: "#008b8b",
        darkgoldenrod: "#b8860b",
        darkgray: "#a9a9a9",
        darkgreen: "#006400",
        darkgrey: "#a9a9a9",
        darkkhaki: "#bdb76b",
        darkmagenta: "#8b008b",
        darkolivegreen: "#556b2f",
        darkorange: "#ff8c00",
        darkorchid: "#9932cc",
        darkred: "#8b0000",
        darksalmon: "#e9967a",
        darkseagreen: "#8fbc8f",
        darkslateblue: "#483d8b",
        darkslategray: "#2f4f4f",
        darkslategrey: "#2f4f4f",
        darkturquoise: "#00ced1",
        darkviolet: "#9400d3",
        deeppink: "#ff1493",
        deepskyblue: "#00bfff",
        dimgray: "#696969",
        dimgrey: "#696969",
        dodgerblue: "#1e90ff",
        firebrick: "#b22222",
        floralwhite: "#fffaf0",
        forestgreen: "#228b22",
        fuchsia: "#ff00ff",
        gainsboro: "#dcdcdc",
        ghostwhite: "#f8f8ff",
        gold: "#ffd700",
        goldenrod: "#daa520",
        gray: "#808080",
        green: "#008000",
        greenyellow: "#adff2f",
        grey: "#808080",
        honeydew: "#f0fff0",
        hotpink: "#ff69b4",
        indianred: "#cd5c5c",
        indigo: "#4b0082",
        ivory: "#fffff0",
        khaki: "#f0e68c",
        laserlemon: "#ffff54",
        lavender: "#e6e6fa",
        lavenderblush: "#fff0f5",
        lawngreen: "#7cfc00",
        lemonchiffon: "#fffacd",
        lightblue: "#add8e6",
        lightcoral: "#f08080",
        lightcyan: "#e0ffff",
        lightgoldenrod: "#fafad2",
        lightgoldenrodyellow: "#fafad2",
        lightgray: "#d3d3d3",
        lightgreen: "#90ee90",
        lightgrey: "#d3d3d3",
        lightpink: "#ffb6c1",
        lightsalmon: "#ffa07a",
        lightseagreen: "#20b2aa",
        lightskyblue: "#87cefa",
        lightslategray: "#778899",
        lightslategrey: "#778899",
        lightsteelblue: "#b0c4de",
        lightyellow: "#ffffe0",
        lime: "#00ff00",
        limegreen: "#32cd32",
        linen: "#faf0e6",
        magenta: "#ff00ff",
        maroon: "#800000",
        maroon2: "#7f0000",
        maroon3: "#b03060",
        mediumaquamarine: "#66cdaa",
        mediumblue: "#0000cd",
        mediumorchid: "#ba55d3",
        mediumpurple: "#9370db",
        mediumseagreen: "#3cb371",
        mediumslateblue: "#7b68ee",
        mediumspringgreen: "#00fa9a",
        mediumturquoise: "#48d1cc",
        mediumvioletred: "#c71585",
        midnightblue: "#191970",
        mintcream: "#f5fffa",
        mistyrose: "#ffe4e1",
        moccasin: "#ffe4b5",
        navajowhite: "#ffdead",
        navy: "#000080",
        oldlace: "#fdf5e6",
        olive: "#808000",
        olivedrab: "#6b8e23",
        orange: "#ffa500",
        orangered: "#ff4500",
        orchid: "#da70d6",
        palegoldenrod: "#eee8aa",
        palegreen: "#98fb98",
        paleturquoise: "#afeeee",
        palevioletred: "#db7093",
        papayawhip: "#ffefd5",
        peachpuff: "#ffdab9",
        peru: "#cd853f",
        pink: "#ffc0cb",
        plum: "#dda0dd",
        powderblue: "#b0e0e6",
        purple: "#800080",
        purple2: "#7f007f",
        purple3: "#a020f0",
        rebeccapurple: "#663399",
        red: "#ff0000",
        rosybrown: "#bc8f8f",
        royalblue: "#4169e1",
        saddlebrown: "#8b4513",
        salmon: "#fa8072",
        sandybrown: "#f4a460",
        seagreen: "#2e8b57",
        seashell: "#fff5ee",
        sienna: "#a0522d",
        silver: "#c0c0c0",
        skyblue: "#87ceeb",
        slateblue: "#6a5acd",
        slategray: "#708090",
        slategrey: "#708090",
        snow: "#fffafa",
        springgreen: "#00ff7f",
        steelblue: "#4682b4",
        tan: "#d2b48c",
        teal: "#008080",
        thistle: "#d8bfd8",
        tomato: "#ff6347",
        turquoise: "#40e0d0",
        violet: "#ee82ee",
        wheat: "#f5deb3",
        white: "#ffffff",
        whitesmoke: "#f5f5f5",
        yellow: "#ffff00",
        yellowgreen: "#9acd32"
      };
      chroma2.colors = colors = w3cx11;
      lab2rgb = function() {
        var a, args, b, g, l, r, x, y, z;
        args = unpack(arguments);
        l = args[0], a = args[1], b = args[2];
        y = (l + 16) / 116;
        x = isNaN(a) ? y : y + a / 500;
        z = isNaN(b) ? y : y - b / 200;
        y = LAB_CONSTANTS.Yn * lab_xyz(y);
        x = LAB_CONSTANTS.Xn * lab_xyz(x);
        z = LAB_CONSTANTS.Zn * lab_xyz(z);
        r = xyz_rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z);
        g = xyz_rgb(-0.969266 * x + 1.8760108 * y + 0.041556 * z);
        b = xyz_rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z);
        return [r, g, b, args.length > 3 ? args[3] : 1];
      };
      xyz_rgb = function(r) {
        return 255 * (r <= 304e-5 ? 12.92 * r : 1.055 * pow(r, 1 / 2.4) - 0.055);
      };
      lab_xyz = function(t) {
        if (t > LAB_CONSTANTS.t1) {
          return t * t * t;
        } else {
          return LAB_CONSTANTS.t2 * (t - LAB_CONSTANTS.t0);
        }
      };
      LAB_CONSTANTS = {
        Kn: 18,
        Xn: 0.95047,
        Yn: 1,
        Zn: 1.08883,
        t0: 0.137931034,
        t1: 0.206896552,
        t2: 0.12841855,
        t3: 8856452e-9
      };
      rgb2lab = function() {
        var b, g, r, ref, ref1, x, y, z;
        ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
        ref1 = rgb2xyz(r, g, b), x = ref1[0], y = ref1[1], z = ref1[2];
        return [116 * y - 16, 500 * (x - y), 200 * (y - z)];
      };
      rgb_xyz = function(r) {
        if ((r /= 255) <= 0.04045) {
          return r / 12.92;
        } else {
          return pow((r + 0.055) / 1.055, 2.4);
        }
      };
      xyz_lab = function(t) {
        if (t > LAB_CONSTANTS.t3) {
          return pow(t, 1 / 3);
        } else {
          return t / LAB_CONSTANTS.t2 + LAB_CONSTANTS.t0;
        }
      };
      rgb2xyz = function() {
        var b, g, r, ref, x, y, z;
        ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
        r = rgb_xyz(r);
        g = rgb_xyz(g);
        b = rgb_xyz(b);
        x = xyz_lab((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / LAB_CONSTANTS.Xn);
        y = xyz_lab((0.2126729 * r + 0.7151522 * g + 0.072175 * b) / LAB_CONSTANTS.Yn);
        z = xyz_lab((0.0193339 * r + 0.119192 * g + 0.9503041 * b) / LAB_CONSTANTS.Zn);
        return [x, y, z];
      };
      chroma2.lab = function() {
        return function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor(), result2 = func.apply(child, args);
          return Object(result2) === result2 ? result2 : child;
        }(Color, slice.call(arguments).concat(["lab"]), function() {
        });
      };
      _input.lab = lab2rgb;
      Color.prototype.lab = function() {
        return rgb2lab(this._rgb);
      };
      bezier = function(colors2) {
        var I2, I0, I1, c, lab0, lab1, lab2, lab3, ref, ref1, ref2;
        colors2 = function() {
          var len, o, results;
          results = [];
          for (o = 0, len = colors2.length; o < len; o++) {
            c = colors2[o];
            results.push(chroma2(c));
          }
          return results;
        }();
        if (colors2.length === 2) {
          ref = function() {
            var len, o, results;
            results = [];
            for (o = 0, len = colors2.length; o < len; o++) {
              c = colors2[o];
              results.push(c.lab());
            }
            return results;
          }(), lab0 = ref[0], lab1 = ref[1];
          I2 = function(t) {
            var i, lab;
            lab = function() {
              var o, results;
              results = [];
              for (i = o = 0; o <= 2; i = ++o) {
                results.push(lab0[i] + t * (lab1[i] - lab0[i]));
              }
              return results;
            }();
            return chroma2.lab.apply(chroma2, lab);
          };
        } else if (colors2.length === 3) {
          ref1 = function() {
            var len, o, results;
            results = [];
            for (o = 0, len = colors2.length; o < len; o++) {
              c = colors2[o];
              results.push(c.lab());
            }
            return results;
          }(), lab0 = ref1[0], lab1 = ref1[1], lab2 = ref1[2];
          I2 = function(t) {
            var i, lab;
            lab = function() {
              var o, results;
              results = [];
              for (i = o = 0; o <= 2; i = ++o) {
                results.push((1 - t) * (1 - t) * lab0[i] + 2 * (1 - t) * t * lab1[i] + t * t * lab2[i]);
              }
              return results;
            }();
            return chroma2.lab.apply(chroma2, lab);
          };
        } else if (colors2.length === 4) {
          ref2 = function() {
            var len, o, results;
            results = [];
            for (o = 0, len = colors2.length; o < len; o++) {
              c = colors2[o];
              results.push(c.lab());
            }
            return results;
          }(), lab0 = ref2[0], lab1 = ref2[1], lab2 = ref2[2], lab3 = ref2[3];
          I2 = function(t) {
            var i, lab;
            lab = function() {
              var o, results;
              results = [];
              for (i = o = 0; o <= 2; i = ++o) {
                results.push((1 - t) * (1 - t) * (1 - t) * lab0[i] + 3 * (1 - t) * (1 - t) * t * lab1[i] + 3 * (1 - t) * t * t * lab2[i] + t * t * t * lab3[i]);
              }
              return results;
            }();
            return chroma2.lab.apply(chroma2, lab);
          };
        } else if (colors2.length === 5) {
          I0 = bezier(colors2.slice(0, 3));
          I1 = bezier(colors2.slice(2, 5));
          I2 = function(t) {
            if (t < 0.5) {
              return I0(t * 2);
            } else {
              return I1((t - 0.5) * 2);
            }
          };
        }
        return I2;
      };
      chroma2.bezier = function(colors2) {
        var f;
        f = bezier(colors2);
        f.scale = function() {
          return chroma2.scale(f);
        };
        return f;
      };
      chroma2.cubehelix = function(start2, rotations, hue, gamma, lightness) {
        var dh, dl, f;
        if (start2 == null) {
          start2 = 300;
        }
        if (rotations == null) {
          rotations = -1.5;
        }
        if (hue == null) {
          hue = 1;
        }
        if (gamma == null) {
          gamma = 1;
        }
        if (lightness == null) {
          lightness = [0, 1];
        }
        dh = 0;
        if (type(lightness) === "array") {
          dl = lightness[1] - lightness[0];
        } else {
          dl = 0;
          lightness = [lightness, lightness];
        }
        f = function(fract) {
          var a, amp, b, cos_a, g, h, l, r, sin_a;
          a = TWOPI * ((start2 + 120) / 360 + rotations * fract);
          l = pow(lightness[0] + dl * fract, gamma);
          h = dh !== 0 ? hue[0] + fract * dh : hue;
          amp = h * l * (1 - l) / 2;
          cos_a = cos(a);
          sin_a = sin(a);
          r = l + amp * (-0.14861 * cos_a + 1.78277 * sin_a);
          g = l + amp * (-0.29227 * cos_a - 0.90649 * sin_a);
          b = l + amp * (1.97294 * cos_a);
          return chroma2(clip_rgb([r * 255, g * 255, b * 255, 1]));
        };
        f.start = function(s) {
          if (s == null) {
            return start2;
          }
          start2 = s;
          return f;
        };
        f.rotations = function(r) {
          if (r == null) {
            return rotations;
          }
          rotations = r;
          return f;
        };
        f.gamma = function(g) {
          if (g == null) {
            return gamma;
          }
          gamma = g;
          return f;
        };
        f.hue = function(h) {
          if (h == null) {
            return hue;
          }
          hue = h;
          if (type(hue) === "array") {
            dh = hue[1] - hue[0];
            if (dh === 0) {
              hue = hue[1];
            }
          } else {
            dh = 0;
          }
          return f;
        };
        f.lightness = function(h) {
          if (h == null) {
            return lightness;
          }
          if (type(h) === "array") {
            lightness = h;
            dl = h[1] - h[0];
          } else {
            lightness = [h, h];
            dl = 0;
          }
          return f;
        };
        f.scale = function() {
          return chroma2.scale(f);
        };
        f.hue(hue);
        return f;
      };
      chroma2.random = function() {
        var code, digits, i, o;
        digits = "0123456789abcdef";
        code = "#";
        for (i = o = 0; o < 6; i = ++o) {
          code += digits.charAt(floor(Math.random() * 16));
        }
        return new Color(code);
      };
      _interpolators = [];
      interpolate = function(col1, col2, f, m2) {
        var interpol, len, o, res;
        if (f == null) {
          f = 0.5;
        }
        if (m2 == null) {
          m2 = "rgb";
        }
        if (type(col1) !== "object") {
          col1 = chroma2(col1);
        }
        if (type(col2) !== "object") {
          col2 = chroma2(col2);
        }
        for (o = 0, len = _interpolators.length; o < len; o++) {
          interpol = _interpolators[o];
          if (m2 === interpol[0]) {
            res = interpol[1](col1, col2, f, m2);
            break;
          }
        }
        if (res == null) {
          throw "color mode " + m2 + " is not supported";
        }
        return res.alpha(col1.alpha() + f * (col2.alpha() - col1.alpha()));
      };
      chroma2.interpolate = interpolate;
      Color.prototype.interpolate = function(col2, f, m2) {
        return interpolate(this, col2, f, m2);
      };
      chroma2.mix = interpolate;
      Color.prototype.mix = Color.prototype.interpolate;
      _input.rgb = function() {
        var k, ref, results, v;
        ref = unpack(arguments);
        results = [];
        for (k in ref) {
          v = ref[k];
          results.push(v);
        }
        return results;
      };
      chroma2.rgb = function() {
        return function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor(), result2 = func.apply(child, args);
          return Object(result2) === result2 ? result2 : child;
        }(Color, slice.call(arguments).concat(["rgb"]), function() {
        });
      };
      Color.prototype.rgb = function(round2) {
        if (round2 == null) {
          round2 = true;
        }
        if (round2) {
          return this._rgb.map(Math.round).slice(0, 3);
        } else {
          return this._rgb.slice(0, 3);
        }
      };
      Color.prototype.rgba = function(round2) {
        if (round2 == null) {
          round2 = true;
        }
        if (!round2) {
          return this._rgb.slice(0);
        }
        return [Math.round(this._rgb[0]), Math.round(this._rgb[1]), Math.round(this._rgb[2]), this._rgb[3]];
      };
      _guess_formats.push({
        p: 3,
        test: function(n) {
          var a;
          a = unpack(arguments);
          if (type(a) === "array" && a.length === 3) {
            return "rgb";
          }
          if (a.length === 4 && type(a[3]) === "number" && a[3] >= 0 && a[3] <= 1) {
            return "rgb";
          }
        }
      });
      _input.lrgb = _input.rgb;
      interpolate_lrgb = function(col1, col2, f, m2) {
        var xyz0, xyz1;
        xyz0 = col1._rgb;
        xyz1 = col2._rgb;
        return new Color(sqrt(pow(xyz0[0], 2) * (1 - f) + pow(xyz1[0], 2) * f), sqrt(pow(xyz0[1], 2) * (1 - f) + pow(xyz1[1], 2) * f), sqrt(pow(xyz0[2], 2) * (1 - f) + pow(xyz1[2], 2) * f), m2);
      };
      _average_lrgb = function(colors2) {
        var col, f, len, o, rgb, xyz;
        f = 1 / colors2.length;
        xyz = [0, 0, 0, 0];
        for (o = 0, len = colors2.length; o < len; o++) {
          col = colors2[o];
          rgb = col._rgb;
          xyz[0] += pow(rgb[0], 2) * f;
          xyz[1] += pow(rgb[1], 2) * f;
          xyz[2] += pow(rgb[2], 2) * f;
          xyz[3] += rgb[3] * f;
        }
        xyz[0] = sqrt(xyz[0]);
        xyz[1] = sqrt(xyz[1]);
        xyz[2] = sqrt(xyz[2]);
        if (xyz[3] > 1) {
          xyz[3] = 1;
        }
        return new Color(clip_rgb(xyz));
      };
      _interpolators.push(["lrgb", interpolate_lrgb]);
      chroma2.average = function(colors2, mode2) {
        var A2, alpha, c, cnt, dx, dy, first, i, l, len, o, xyz, xyz2;
        if (mode2 == null) {
          mode2 = "rgb";
        }
        l = colors2.length;
        colors2 = colors2.map(function(c2) {
          return chroma2(c2);
        });
        first = colors2.splice(0, 1)[0];
        if (mode2 === "lrgb") {
          return _average_lrgb(colors2);
        }
        xyz = first.get(mode2);
        cnt = [];
        dx = 0;
        dy = 0;
        for (i in xyz) {
          xyz[i] = xyz[i] || 0;
          cnt.push(isNaN(xyz[i]) ? 0 : 1);
          if (mode2.charAt(i) === "h" && !isNaN(xyz[i])) {
            A2 = xyz[i] / 180 * PI;
            dx += cos(A2);
            dy += sin(A2);
          }
        }
        alpha = first.alpha();
        for (o = 0, len = colors2.length; o < len; o++) {
          c = colors2[o];
          xyz2 = c.get(mode2);
          alpha += c.alpha();
          for (i in xyz) {
            if (!isNaN(xyz2[i])) {
              cnt[i] += 1;
              if (mode2.charAt(i) === "h") {
                A2 = xyz2[i] / 180 * PI;
                dx += cos(A2);
                dy += sin(A2);
              } else {
                xyz[i] += xyz2[i];
              }
            }
          }
        }
        for (i in xyz) {
          if (mode2.charAt(i) === "h") {
            A2 = atan2(dy / cnt[i], dx / cnt[i]) / PI * 180;
            while (A2 < 0) {
              A2 += 360;
            }
            while (A2 >= 360) {
              A2 -= 360;
            }
            xyz[i] = A2;
          } else {
            xyz[i] = xyz[i] / cnt[i];
          }
        }
        return chroma2(xyz, mode2).alpha(alpha / l);
      };
      hex2rgb = function(hex) {
        var a, b, g, r, rgb, u;
        if (hex.match(/^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/)) {
          if (hex.length === 4 || hex.length === 7) {
            hex = hex.substr(1);
          }
          if (hex.length === 3) {
            hex = hex.split("");
            hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
          }
          u = parseInt(hex, 16);
          r = u >> 16;
          g = u >> 8 & 255;
          b = u & 255;
          return [r, g, b, 1];
        }
        if (hex.match(/^#?([A-Fa-f0-9]{8})$/)) {
          if (hex.length === 9) {
            hex = hex.substr(1);
          }
          u = parseInt(hex, 16);
          r = u >> 24 & 255;
          g = u >> 16 & 255;
          b = u >> 8 & 255;
          a = round((u & 255) / 255 * 100) / 100;
          return [r, g, b, a];
        }
        if (_input.css != null && (rgb = _input.css(hex))) {
          return rgb;
        }
        throw "unknown color: " + hex;
      };
      rgb2hex = function(channels, mode2) {
        var a, b, g, hxa, r, str, u;
        if (mode2 == null) {
          mode2 = "auto";
        }
        r = channels[0], g = channels[1], b = channels[2], a = channels[3];
        if (mode2 === "auto") {
          mode2 = a < 1 ? "rgba" : "rgb";
        }
        r = Math.round(r);
        g = Math.round(g);
        b = Math.round(b);
        u = r << 16 | g << 8 | b;
        str = "000000" + u.toString(16);
        str = str.substr(str.length - 6);
        hxa = "0" + round(a * 255).toString(16);
        hxa = hxa.substr(hxa.length - 2);
        return "#" + function() {
          switch (mode2.toLowerCase()) {
            case "rgba":
              return str + hxa;
            case "argb":
              return hxa + str;
            default:
              return str;
          }
        }();
      };
      _input.hex = function(h) {
        return hex2rgb(h);
      };
      chroma2.hex = function() {
        return function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor(), result2 = func.apply(child, args);
          return Object(result2) === result2 ? result2 : child;
        }(Color, slice.call(arguments).concat(["hex"]), function() {
        });
      };
      Color.prototype.hex = function(mode2) {
        if (mode2 == null) {
          mode2 = "auto";
        }
        return rgb2hex(this._rgb, mode2);
      };
      _guess_formats.push({
        p: 4,
        test: function(n) {
          if (arguments.length === 1 && type(n) === "string") {
            return "hex";
          }
        }
      });
      hsl2rgb = function() {
        var args, b, c, g, h, i, l, o, r, ref, s, t1, t2, t3;
        args = unpack(arguments);
        h = args[0], s = args[1], l = args[2];
        if (s === 0) {
          r = g = b = l * 255;
        } else {
          t3 = [0, 0, 0];
          c = [0, 0, 0];
          t2 = l < 0.5 ? l * (1 + s) : l + s - l * s;
          t1 = 2 * l - t2;
          h /= 360;
          t3[0] = h + 1 / 3;
          t3[1] = h;
          t3[2] = h - 1 / 3;
          for (i = o = 0; o <= 2; i = ++o) {
            if (t3[i] < 0) {
              t3[i] += 1;
            }
            if (t3[i] > 1) {
              t3[i] -= 1;
            }
            if (6 * t3[i] < 1) {
              c[i] = t1 + (t2 - t1) * 6 * t3[i];
            } else if (2 * t3[i] < 1) {
              c[i] = t2;
            } else if (3 * t3[i] < 2) {
              c[i] = t1 + (t2 - t1) * (2 / 3 - t3[i]) * 6;
            } else {
              c[i] = t1;
            }
          }
          ref = [round(c[0] * 255), round(c[1] * 255), round(c[2] * 255)], r = ref[0], g = ref[1], b = ref[2];
        }
        if (args.length > 3) {
          return [r, g, b, args[3]];
        } else {
          return [r, g, b];
        }
      };
      rgb2hsl = function(r, g, b) {
        var h, l, min, ref, s;
        if (r !== void 0 && r.length >= 3) {
          ref = r, r = ref[0], g = ref[1], b = ref[2];
        }
        r /= 255;
        g /= 255;
        b /= 255;
        min = Math.min(r, g, b);
        max = Math.max(r, g, b);
        l = (max + min) / 2;
        if (max === min) {
          s = 0;
          h = Number.NaN;
        } else {
          s = l < 0.5 ? (max - min) / (max + min) : (max - min) / (2 - max - min);
        }
        if (r === max) {
          h = (g - b) / (max - min);
        } else if (g === max) {
          h = 2 + (b - r) / (max - min);
        } else if (b === max) {
          h = 4 + (r - g) / (max - min);
        }
        h *= 60;
        if (h < 0) {
          h += 360;
        }
        return [h, s, l];
      };
      chroma2.hsl = function() {
        return function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor(), result2 = func.apply(child, args);
          return Object(result2) === result2 ? result2 : child;
        }(Color, slice.call(arguments).concat(["hsl"]), function() {
        });
      };
      _input.hsl = hsl2rgb;
      Color.prototype.hsl = function() {
        return rgb2hsl(this._rgb);
      };
      hsv2rgb = function() {
        var args, b, f, g, h, i, p, q, r, ref, ref1, ref2, ref3, ref4, ref5, s, t, v;
        args = unpack(arguments);
        h = args[0], s = args[1], v = args[2];
        v *= 255;
        if (s === 0) {
          r = g = b = v;
        } else {
          if (h === 360) {
            h = 0;
          }
          if (h > 360) {
            h -= 360;
          }
          if (h < 0) {
            h += 360;
          }
          h /= 60;
          i = floor(h);
          f = h - i;
          p = v * (1 - s);
          q = v * (1 - s * f);
          t = v * (1 - s * (1 - f));
          switch (i) {
            case 0:
              ref = [v, t, p], r = ref[0], g = ref[1], b = ref[2];
              break;
            case 1:
              ref1 = [q, v, p], r = ref1[0], g = ref1[1], b = ref1[2];
              break;
            case 2:
              ref2 = [p, v, t], r = ref2[0], g = ref2[1], b = ref2[2];
              break;
            case 3:
              ref3 = [p, q, v], r = ref3[0], g = ref3[1], b = ref3[2];
              break;
            case 4:
              ref4 = [t, p, v], r = ref4[0], g = ref4[1], b = ref4[2];
              break;
            case 5:
              ref5 = [v, p, q], r = ref5[0], g = ref5[1], b = ref5[2];
          }
        }
        return [r, g, b, args.length > 3 ? args[3] : 1];
      };
      rgb2hsv = function() {
        var b, delta, g, h, min, r, ref, s, v;
        ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
        min = Math.min(r, g, b);
        max = Math.max(r, g, b);
        delta = max - min;
        v = max / 255;
        if (max === 0) {
          h = Number.NaN;
          s = 0;
        } else {
          s = delta / max;
          if (r === max) {
            h = (g - b) / delta;
          }
          if (g === max) {
            h = 2 + (b - r) / delta;
          }
          if (b === max) {
            h = 4 + (r - g) / delta;
          }
          h *= 60;
          if (h < 0) {
            h += 360;
          }
        }
        return [h, s, v];
      };
      chroma2.hsv = function() {
        return function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor(), result2 = func.apply(child, args);
          return Object(result2) === result2 ? result2 : child;
        }(Color, slice.call(arguments).concat(["hsv"]), function() {
        });
      };
      _input.hsv = hsv2rgb;
      Color.prototype.hsv = function() {
        return rgb2hsv(this._rgb);
      };
      num2rgb = function(num) {
        var b, g, r;
        if (type(num) === "number" && num >= 0 && num <= 16777215) {
          r = num >> 16;
          g = num >> 8 & 255;
          b = num & 255;
          return [r, g, b, 1];
        }
        console.warn("unknown num color: " + num);
        return [0, 0, 0, 1];
      };
      rgb2num = function() {
        var b, g, r, ref;
        ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
        return (r << 16) + (g << 8) + b;
      };
      chroma2.num = function(num) {
        return new Color(num, "num");
      };
      Color.prototype.num = function(mode2) {
        if (mode2 == null) {
          mode2 = "rgb";
        }
        return rgb2num(this._rgb, mode2);
      };
      _input.num = num2rgb;
      _guess_formats.push({
        p: 1,
        test: function(n) {
          if (arguments.length === 1 && type(n) === "number" && n >= 0 && n <= 16777215) {
            return "num";
          }
        }
      });
      hcg2rgb = function() {
        var _c, _g, args, b, c, f, g, h, i, p, q, r, ref, ref1, ref2, ref3, ref4, ref5, t, v;
        args = unpack(arguments);
        h = args[0], c = args[1], _g = args[2];
        c = c / 100;
        g = g / 100 * 255;
        _c = c * 255;
        if (c === 0) {
          r = g = b = _g;
        } else {
          if (h === 360) {
            h = 0;
          }
          if (h > 360) {
            h -= 360;
          }
          if (h < 0) {
            h += 360;
          }
          h /= 60;
          i = floor(h);
          f = h - i;
          p = _g * (1 - c);
          q = p + _c * (1 - f);
          t = p + _c * f;
          v = p + _c;
          switch (i) {
            case 0:
              ref = [v, t, p], r = ref[0], g = ref[1], b = ref[2];
              break;
            case 1:
              ref1 = [q, v, p], r = ref1[0], g = ref1[1], b = ref1[2];
              break;
            case 2:
              ref2 = [p, v, t], r = ref2[0], g = ref2[1], b = ref2[2];
              break;
            case 3:
              ref3 = [p, q, v], r = ref3[0], g = ref3[1], b = ref3[2];
              break;
            case 4:
              ref4 = [t, p, v], r = ref4[0], g = ref4[1], b = ref4[2];
              break;
            case 5:
              ref5 = [v, p, q], r = ref5[0], g = ref5[1], b = ref5[2];
          }
        }
        return [r, g, b, args.length > 3 ? args[3] : 1];
      };
      rgb2hcg = function() {
        var _g, b, c, delta, g, h, min, r, ref;
        ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
        min = Math.min(r, g, b);
        max = Math.max(r, g, b);
        delta = max - min;
        c = delta * 100 / 255;
        _g = min / (255 - delta) * 100;
        if (delta === 0) {
          h = Number.NaN;
        } else {
          if (r === max) {
            h = (g - b) / delta;
          }
          if (g === max) {
            h = 2 + (b - r) / delta;
          }
          if (b === max) {
            h = 4 + (r - g) / delta;
          }
          h *= 60;
          if (h < 0) {
            h += 360;
          }
        }
        return [h, c, _g];
      };
      chroma2.hcg = function() {
        return function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor(), result2 = func.apply(child, args);
          return Object(result2) === result2 ? result2 : child;
        }(Color, slice.call(arguments).concat(["hcg"]), function() {
        });
      };
      _input.hcg = hcg2rgb;
      Color.prototype.hcg = function() {
        return rgb2hcg(this._rgb);
      };
      css2rgb = function(css) {
        var aa, ab, hsl, i, m2, o, rgb, w;
        css = css.toLowerCase();
        if (chroma2.colors != null && chroma2.colors[css]) {
          return hex2rgb(chroma2.colors[css]);
        }
        if (m2 = css.match(/rgb\(\s*(\-?\d+),\s*(\-?\d+)\s*,\s*(\-?\d+)\s*\)/)) {
          rgb = m2.slice(1, 4);
          for (i = o = 0; o <= 2; i = ++o) {
            rgb[i] = +rgb[i];
          }
          rgb[3] = 1;
        } else if (m2 = css.match(/rgba\(\s*(\-?\d+),\s*(\-?\d+)\s*,\s*(\-?\d+)\s*,\s*([01]|[01]?\.\d+)\)/)) {
          rgb = m2.slice(1, 5);
          for (i = w = 0; w <= 3; i = ++w) {
            rgb[i] = +rgb[i];
          }
        } else if (m2 = css.match(/rgb\(\s*(\-?\d+(?:\.\d+)?)%,\s*(\-?\d+(?:\.\d+)?)%\s*,\s*(\-?\d+(?:\.\d+)?)%\s*\)/)) {
          rgb = m2.slice(1, 4);
          for (i = aa = 0; aa <= 2; i = ++aa) {
            rgb[i] = round(rgb[i] * 2.55);
          }
          rgb[3] = 1;
        } else if (m2 = css.match(/rgba\(\s*(\-?\d+(?:\.\d+)?)%,\s*(\-?\d+(?:\.\d+)?)%\s*,\s*(\-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)/)) {
          rgb = m2.slice(1, 5);
          for (i = ab = 0; ab <= 2; i = ++ab) {
            rgb[i] = round(rgb[i] * 2.55);
          }
          rgb[3] = +rgb[3];
        } else if (m2 = css.match(/hsl\(\s*(\-?\d+(?:\.\d+)?),\s*(\-?\d+(?:\.\d+)?)%\s*,\s*(\-?\d+(?:\.\d+)?)%\s*\)/)) {
          hsl = m2.slice(1, 4);
          hsl[1] *= 0.01;
          hsl[2] *= 0.01;
          rgb = hsl2rgb(hsl);
          rgb[3] = 1;
        } else if (m2 = css.match(/hsla\(\s*(\-?\d+(?:\.\d+)?),\s*(\-?\d+(?:\.\d+)?)%\s*,\s*(\-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)/)) {
          hsl = m2.slice(1, 4);
          hsl[1] *= 0.01;
          hsl[2] *= 0.01;
          rgb = hsl2rgb(hsl);
          rgb[3] = +m2[4];
        }
        return rgb;
      };
      rgb2css = function(rgba) {
        var mode2;
        mode2 = rgba[3] < 1 ? "rgba" : "rgb";
        if (mode2 === "rgb") {
          return mode2 + "(" + rgba.slice(0, 3).map(round).join(",") + ")";
        } else if (mode2 === "rgba") {
          return mode2 + "(" + rgba.slice(0, 3).map(round).join(",") + "," + rgba[3] + ")";
        } else {
        }
      };
      rnd = function(a) {
        return round(a * 100) / 100;
      };
      hsl2css = function(hsl, alpha) {
        var mode2;
        mode2 = alpha < 1 ? "hsla" : "hsl";
        hsl[0] = rnd(hsl[0] || 0);
        hsl[1] = rnd(hsl[1] * 100) + "%";
        hsl[2] = rnd(hsl[2] * 100) + "%";
        if (mode2 === "hsla") {
          hsl[3] = alpha;
        }
        return mode2 + "(" + hsl.join(",") + ")";
      };
      _input.css = function(h) {
        return css2rgb(h);
      };
      chroma2.css = function() {
        return function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor(), result2 = func.apply(child, args);
          return Object(result2) === result2 ? result2 : child;
        }(Color, slice.call(arguments).concat(["css"]), function() {
        });
      };
      Color.prototype.css = function(mode2) {
        if (mode2 == null) {
          mode2 = "rgb";
        }
        if (mode2.slice(0, 3) === "rgb") {
          return rgb2css(this._rgb);
        } else if (mode2.slice(0, 3) === "hsl") {
          return hsl2css(this.hsl(), this.alpha());
        }
      };
      _input.named = function(name) {
        return hex2rgb(w3cx11[name]);
      };
      _guess_formats.push({
        p: 5,
        test: function(n) {
          if (arguments.length === 1 && w3cx11[n] != null) {
            return "named";
          }
        }
      });
      Color.prototype.name = function(n) {
        var h, k;
        if (arguments.length) {
          if (w3cx11[n]) {
            this._rgb = hex2rgb(w3cx11[n]);
          }
          this._rgb[3] = 1;
          this;
        }
        h = this.hex("rgb");
        for (k in w3cx11) {
          if (h === w3cx11[k]) {
            return k;
          }
        }
        return h;
      };
      lch2lab = function() {
        var c, h, l, ref;
        ref = unpack(arguments), l = ref[0], c = ref[1], h = ref[2];
        h = h * DEG2RAD;
        return [l, cos(h) * c, sin(h) * c];
      };
      lch2rgb = function() {
        var L3, a, args, b, c, g, h, l, r, ref, ref1;
        args = unpack(arguments);
        l = args[0], c = args[1], h = args[2];
        ref = lch2lab(l, c, h), L3 = ref[0], a = ref[1], b = ref[2];
        ref1 = lab2rgb(L3, a, b), r = ref1[0], g = ref1[1], b = ref1[2];
        return [r, g, b, args.length > 3 ? args[3] : 1];
      };
      lab2lch = function() {
        var a, b, c, h, l, ref;
        ref = unpack(arguments), l = ref[0], a = ref[1], b = ref[2];
        c = sqrt(a * a + b * b);
        h = (atan2(b, a) * RAD2DEG + 360) % 360;
        if (round(c * 1e4) === 0) {
          h = Number.NaN;
        }
        return [l, c, h];
      };
      rgb2lch = function() {
        var a, b, g, l, r, ref, ref1;
        ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
        ref1 = rgb2lab(r, g, b), l = ref1[0], a = ref1[1], b = ref1[2];
        return lab2lch(l, a, b);
      };
      chroma2.lch = function() {
        var args;
        args = unpack(arguments);
        return new Color(args, "lch");
      };
      chroma2.hcl = function() {
        var args;
        args = unpack(arguments);
        return new Color(args, "hcl");
      };
      _input.lch = lch2rgb;
      _input.hcl = function() {
        var c, h, l, ref;
        ref = unpack(arguments), h = ref[0], c = ref[1], l = ref[2];
        return lch2rgb([l, c, h]);
      };
      Color.prototype.lch = function() {
        return rgb2lch(this._rgb);
      };
      Color.prototype.hcl = function() {
        return rgb2lch(this._rgb).reverse();
      };
      rgb2cmyk = function(mode2) {
        var b, c, f, g, k, m2, r, ref, y;
        if (mode2 == null) {
          mode2 = "rgb";
        }
        ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
        r = r / 255;
        g = g / 255;
        b = b / 255;
        k = 1 - Math.max(r, Math.max(g, b));
        f = k < 1 ? 1 / (1 - k) : 0;
        c = (1 - r - k) * f;
        m2 = (1 - g - k) * f;
        y = (1 - b - k) * f;
        return [c, m2, y, k];
      };
      cmyk2rgb = function() {
        var alpha, args, b, c, g, k, m2, r, y;
        args = unpack(arguments);
        c = args[0], m2 = args[1], y = args[2], k = args[3];
        alpha = args.length > 4 ? args[4] : 1;
        if (k === 1) {
          return [0, 0, 0, alpha];
        }
        r = c >= 1 ? 0 : 255 * (1 - c) * (1 - k);
        g = m2 >= 1 ? 0 : 255 * (1 - m2) * (1 - k);
        b = y >= 1 ? 0 : 255 * (1 - y) * (1 - k);
        return [r, g, b, alpha];
      };
      _input.cmyk = function() {
        return cmyk2rgb(unpack(arguments));
      };
      chroma2.cmyk = function() {
        return function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor(), result2 = func.apply(child, args);
          return Object(result2) === result2 ? result2 : child;
        }(Color, slice.call(arguments).concat(["cmyk"]), function() {
        });
      };
      Color.prototype.cmyk = function() {
        return rgb2cmyk(this._rgb);
      };
      _input.gl = function() {
        var i, k, o, rgb, v;
        rgb = function() {
          var ref, results;
          ref = unpack(arguments);
          results = [];
          for (k in ref) {
            v = ref[k];
            results.push(v);
          }
          return results;
        }.apply(this, arguments);
        for (i = o = 0; o <= 2; i = ++o) {
          rgb[i] *= 255;
        }
        return rgb;
      };
      chroma2.gl = function() {
        return function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor(), result2 = func.apply(child, args);
          return Object(result2) === result2 ? result2 : child;
        }(Color, slice.call(arguments).concat(["gl"]), function() {
        });
      };
      Color.prototype.gl = function() {
        var rgb;
        rgb = this._rgb;
        return [rgb[0] / 255, rgb[1] / 255, rgb[2] / 255, rgb[3]];
      };
      rgb2luminance = function(r, g, b) {
        var ref;
        ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
        r = luminance_x(r);
        g = luminance_x(g);
        b = luminance_x(b);
        return 0.2126 * r + 0.7152 * g + 0.0722 * b;
      };
      luminance_x = function(x) {
        x /= 255;
        if (x <= 0.03928) {
          return x / 12.92;
        } else {
          return pow((x + 0.055) / 1.055, 2.4);
        }
      };
      interpolate_rgb = function(col1, col2, f, m2) {
        var xyz0, xyz1;
        xyz0 = col1._rgb;
        xyz1 = col2._rgb;
        return new Color(xyz0[0] + f * (xyz1[0] - xyz0[0]), xyz0[1] + f * (xyz1[1] - xyz0[1]), xyz0[2] + f * (xyz1[2] - xyz0[2]), m2);
      };
      _interpolators.push(["rgb", interpolate_rgb]);
      Color.prototype.luminance = function(lum, mode2) {
        var cur_lum, eps, max_iter, rgba, test;
        if (mode2 == null) {
          mode2 = "rgb";
        }
        if (!arguments.length) {
          return rgb2luminance(this._rgb);
        }
        rgba = this._rgb;
        if (lum === 0) {
          rgba = [0, 0, 0, this._rgb[3]];
        } else if (lum === 1) {
          rgba = [255, 255, 255, this[3]];
        } else {
          cur_lum = rgb2luminance(this._rgb);
          eps = 1e-7;
          max_iter = 20;
          test = function(l, h) {
            var lm, m2;
            m2 = l.interpolate(h, 0.5, mode2);
            lm = m2.luminance();
            if (Math.abs(lum - lm) < eps || !max_iter--) {
              return m2;
            }
            if (lm > lum) {
              return test(l, m2);
            }
            return test(m2, h);
          };
          if (cur_lum > lum) {
            rgba = test(chroma2("black"), this).rgba();
          } else {
            rgba = test(this, chroma2("white")).rgba();
          }
        }
        return chroma2(rgba).alpha(this.alpha());
      };
      temperature2rgb = function(kelvin) {
        var b, g, r, temp;
        temp = kelvin / 100;
        if (temp < 66) {
          r = 255;
          g = -155.25485562709179 - 0.44596950469579133 * (g = temp - 2) + 104.49216199393888 * log2(g);
          b = temp < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (b = temp - 10) + 115.67994401066147 * log2(b);
        } else {
          r = 351.97690566805693 + 0.114206453784165 * (r = temp - 55) - 40.25366309332127 * log2(r);
          g = 325.4494125711974 + 0.07943456536662342 * (g = temp - 50) - 28.0852963507957 * log2(g);
          b = 255;
        }
        return [r, g, b];
      };
      rgb2temperature = function() {
        var b, eps, g, maxTemp, minTemp, r, ref, rgb, temp;
        ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
        minTemp = 1e3;
        maxTemp = 4e4;
        eps = 0.4;
        while (maxTemp - minTemp > eps) {
          temp = (maxTemp + minTemp) * 0.5;
          rgb = temperature2rgb(temp);
          if (rgb[2] / rgb[0] >= b / r) {
            maxTemp = temp;
          } else {
            minTemp = temp;
          }
        }
        return round(temp);
      };
      chroma2.temperature = chroma2.kelvin = function() {
        return function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor(), result2 = func.apply(child, args);
          return Object(result2) === result2 ? result2 : child;
        }(Color, slice.call(arguments).concat(["temperature"]), function() {
        });
      };
      _input.temperature = _input.kelvin = _input.K = temperature2rgb;
      Color.prototype.temperature = function() {
        return rgb2temperature(this._rgb);
      };
      Color.prototype.kelvin = Color.prototype.temperature;
      chroma2.contrast = function(a, b) {
        var l1, l2, ref, ref1;
        if ((ref = type(a)) === "string" || ref === "number") {
          a = new Color(a);
        }
        if ((ref1 = type(b)) === "string" || ref1 === "number") {
          b = new Color(b);
        }
        l1 = a.luminance();
        l2 = b.luminance();
        if (l1 > l2) {
          return (l1 + 0.05) / (l2 + 0.05);
        } else {
          return (l2 + 0.05) / (l1 + 0.05);
        }
      };
      chroma2.distance = function(a, b, mode2) {
        var d, i, l1, l2, ref, ref1, sum_sq;
        if (mode2 == null) {
          mode2 = "lab";
        }
        if ((ref = type(a)) === "string" || ref === "number") {
          a = new Color(a);
        }
        if ((ref1 = type(b)) === "string" || ref1 === "number") {
          b = new Color(b);
        }
        l1 = a.get(mode2);
        l2 = b.get(mode2);
        sum_sq = 0;
        for (i in l1) {
          d = (l1[i] || 0) - (l2[i] || 0);
          sum_sq += d * d;
        }
        return Math.sqrt(sum_sq);
      };
      chroma2.deltaE = function(a, b, L3, C) {
        var L1, L22, a1, a2, b1, b2, c1, c2, c4, dH2, delA, delB, delC, delL, f, h1, ref, ref1, ref2, ref3, sc, sh, sl, t, v1, v2, v3;
        if (L3 == null) {
          L3 = 1;
        }
        if (C == null) {
          C = 1;
        }
        if ((ref = type(a)) === "string" || ref === "number") {
          a = new Color(a);
        }
        if ((ref1 = type(b)) === "string" || ref1 === "number") {
          b = new Color(b);
        }
        ref2 = a.lab(), L1 = ref2[0], a1 = ref2[1], b1 = ref2[2];
        ref3 = b.lab(), L22 = ref3[0], a2 = ref3[1], b2 = ref3[2];
        c1 = sqrt(a1 * a1 + b1 * b1);
        c2 = sqrt(a2 * a2 + b2 * b2);
        sl = L1 < 16 ? 0.511 : 0.040975 * L1 / (1 + 0.01765 * L1);
        sc = 0.0638 * c1 / (1 + 0.0131 * c1) + 0.638;
        h1 = c1 < 1e-6 ? 0 : atan2(b1, a1) * 180 / PI;
        while (h1 < 0) {
          h1 += 360;
        }
        while (h1 >= 360) {
          h1 -= 360;
        }
        t = h1 >= 164 && h1 <= 345 ? 0.56 + abs(0.2 * cos(PI * (h1 + 168) / 180)) : 0.36 + abs(0.4 * cos(PI * (h1 + 35) / 180));
        c4 = c1 * c1 * c1 * c1;
        f = sqrt(c4 / (c4 + 1900));
        sh = sc * (f * t + 1 - f);
        delL = L1 - L22;
        delC = c1 - c2;
        delA = a1 - a2;
        delB = b1 - b2;
        dH2 = delA * delA + delB * delB - delC * delC;
        v1 = delL / (L3 * sl);
        v2 = delC / (C * sc);
        v3 = sh;
        return sqrt(v1 * v1 + v2 * v2 + dH2 / (v3 * v3));
      };
      Color.prototype.get = function(modechan) {
        var channel, i, me, mode2, ref, src;
        me = this;
        ref = modechan.split("."), mode2 = ref[0], channel = ref[1];
        src = me[mode2]();
        if (channel) {
          i = mode2.indexOf(channel);
          if (i > -1) {
            return src[i];
          } else {
            return console.warn("unknown channel " + channel + " in mode " + mode2);
          }
        } else {
          return src;
        }
      };
      Color.prototype.set = function(modechan, value) {
        var channel, i, me, mode2, ref, src;
        me = this;
        ref = modechan.split("."), mode2 = ref[0], channel = ref[1];
        if (channel) {
          src = me[mode2]();
          i = mode2.indexOf(channel);
          if (i > -1) {
            if (type(value) === "string") {
              switch (value.charAt(0)) {
                case "+":
                  src[i] += +value;
                  break;
                case "-":
                  src[i] += +value;
                  break;
                case "*":
                  src[i] *= +value.substr(1);
                  break;
                case "/":
                  src[i] /= +value.substr(1);
                  break;
                default:
                  src[i] = +value;
              }
            } else {
              src[i] = value;
            }
          } else {
            console.warn("unknown channel " + channel + " in mode " + mode2);
          }
        } else {
          src = value;
        }
        return chroma2(src, mode2).alpha(me.alpha());
      };
      Color.prototype.clipped = function() {
        return this._rgb._clipped || false;
      };
      Color.prototype.alpha = function(a) {
        if (arguments.length) {
          return chroma2.rgb([this._rgb[0], this._rgb[1], this._rgb[2], a]);
        }
        return this._rgb[3];
      };
      Color.prototype.darken = function(amount) {
        var lab, me;
        if (amount == null) {
          amount = 1;
        }
        me = this;
        lab = me.lab();
        lab[0] -= LAB_CONSTANTS.Kn * amount;
        return chroma2.lab(lab).alpha(me.alpha());
      };
      Color.prototype.brighten = function(amount) {
        if (amount == null) {
          amount = 1;
        }
        return this.darken(-amount);
      };
      Color.prototype.darker = Color.prototype.darken;
      Color.prototype.brighter = Color.prototype.brighten;
      Color.prototype.saturate = function(amount) {
        var lch, me;
        if (amount == null) {
          amount = 1;
        }
        me = this;
        lch = me.lch();
        lch[1] += amount * LAB_CONSTANTS.Kn;
        if (lch[1] < 0) {
          lch[1] = 0;
        }
        return chroma2.lch(lch).alpha(me.alpha());
      };
      Color.prototype.desaturate = function(amount) {
        if (amount == null) {
          amount = 1;
        }
        return this.saturate(-amount);
      };
      Color.prototype.premultiply = function() {
        var a, rgb;
        rgb = this.rgb();
        a = this.alpha();
        return chroma2(rgb[0] * a, rgb[1] * a, rgb[2] * a, a);
      };
      blend = function(bottom, top, mode2) {
        if (!blend[mode2]) {
          throw "unknown blend mode " + mode2;
        }
        return blend[mode2](bottom, top);
      };
      blend_f = function(f) {
        return function(bottom, top) {
          var c0, c1;
          c0 = chroma2(top).rgb();
          c1 = chroma2(bottom).rgb();
          return chroma2(f(c0, c1), "rgb");
        };
      };
      each = function(f) {
        return function(c0, c1) {
          var i, o, out;
          out = [];
          for (i = o = 0; o <= 3; i = ++o) {
            out[i] = f(c0[i], c1[i]);
          }
          return out;
        };
      };
      normal = function(a, b) {
        return a;
      };
      multiply2 = function(a, b) {
        return a * b / 255;
      };
      darken = function(a, b) {
        if (a > b) {
          return b;
        } else {
          return a;
        }
      };
      lighten = function(a, b) {
        if (a > b) {
          return a;
        } else {
          return b;
        }
      };
      screen = function(a, b) {
        return 255 * (1 - (1 - a / 255) * (1 - b / 255));
      };
      overlay = function(a, b) {
        if (b < 128) {
          return 2 * a * b / 255;
        } else {
          return 255 * (1 - 2 * (1 - a / 255) * (1 - b / 255));
        }
      };
      burn = function(a, b) {
        return 255 * (1 - (1 - b / 255) / (a / 255));
      };
      dodge = function(a, b) {
        if (a === 255) {
          return 255;
        }
        a = 255 * (b / 255) / (1 - a / 255);
        if (a > 255) {
          return 255;
        } else {
          return a;
        }
      };
      blend.normal = blend_f(each(normal));
      blend.multiply = blend_f(each(multiply2));
      blend.screen = blend_f(each(screen));
      blend.overlay = blend_f(each(overlay));
      blend.darken = blend_f(each(darken));
      blend.lighten = blend_f(each(lighten));
      blend.dodge = blend_f(each(dodge));
      blend.burn = blend_f(each(burn));
      chroma2.blend = blend;
      chroma2.analyze = function(data) {
        var len, o, r, val;
        r = {
          min: Number.MAX_VALUE,
          max: Number.MAX_VALUE * -1,
          sum: 0,
          values: [],
          count: 0
        };
        for (o = 0, len = data.length; o < len; o++) {
          val = data[o];
          if (val != null && !isNaN(val)) {
            r.values.push(val);
            r.sum += val;
            if (val < r.min) {
              r.min = val;
            }
            if (val > r.max) {
              r.max = val;
            }
            r.count += 1;
          }
        }
        r.domain = [r.min, r.max];
        r.limits = function(mode2, num) {
          return chroma2.limits(r, mode2, num);
        };
        return r;
      };
      chroma2.scale = function(colors2, positions) {
        var _classes, _colorCache, _colors, _correctLightness, _domain, _fixed, _gamma, _max, _min, _mode, _nacol, _out, _padding, _pos, _spread, _useCache, classifyValue, f, getClass, getColor, resetCache, setColors, tmap;
        _mode = "rgb";
        _nacol = chroma2("#ccc");
        _spread = 0;
        _fixed = false;
        _domain = [0, 1];
        _pos = [];
        _padding = [0, 0];
        _classes = false;
        _colors = [];
        _out = false;
        _min = 0;
        _max = 1;
        _correctLightness = false;
        _colorCache = {};
        _useCache = true;
        _gamma = 1;
        setColors = function(colors3) {
          var c, col, o, ref, ref1, w;
          if (colors3 == null) {
            colors3 = ["#fff", "#000"];
          }
          if (colors3 != null && type(colors3) === "string" && chroma2.brewer != null) {
            colors3 = chroma2.brewer[colors3] || chroma2.brewer[colors3.toLowerCase()] || colors3;
          }
          if (type(colors3) === "array") {
            if (colors3.length === 1) {
              colors3 = [colors3[0], colors3[0]];
            }
            colors3 = colors3.slice(0);
            for (c = o = 0, ref = colors3.length - 1; 0 <= ref ? o <= ref : o >= ref; c = 0 <= ref ? ++o : --o) {
              col = colors3[c];
              if (type(col) === "string") {
                colors3[c] = chroma2(col);
              }
            }
            _pos.length = 0;
            for (c = w = 0, ref1 = colors3.length - 1; 0 <= ref1 ? w <= ref1 : w >= ref1; c = 0 <= ref1 ? ++w : --w) {
              _pos.push(c / (colors3.length - 1));
            }
          }
          resetCache();
          return _colors = colors3;
        };
        getClass = function(value) {
          var i, n;
          if (_classes != null) {
            n = _classes.length - 1;
            i = 0;
            while (i < n && value >= _classes[i]) {
              i++;
            }
            return i - 1;
          }
          return 0;
        };
        tmap = function(t) {
          return t;
        };
        classifyValue = function(value) {
          var i, maxc, minc, n, val;
          val = value;
          if (_classes.length > 2) {
            n = _classes.length - 1;
            i = getClass(value);
            minc = _classes[0] + (_classes[1] - _classes[0]) * (0 + _spread * 0.5);
            maxc = _classes[n - 1] + (_classes[n] - _classes[n - 1]) * (1 - _spread * 0.5);
            val = _min + (_classes[i] + (_classes[i + 1] - _classes[i]) * 0.5 - minc) / (maxc - minc) * (_max - _min);
          }
          return val;
        };
        getColor = function(val, bypassMap) {
          var c, col, i, k, o, p, ref, t;
          if (bypassMap == null) {
            bypassMap = false;
          }
          if (isNaN(val) || val === null) {
            return _nacol;
          }
          if (!bypassMap) {
            if (_classes && _classes.length > 2) {
              c = getClass(val);
              t = c / (_classes.length - 2);
            } else if (_max !== _min) {
              t = (val - _min) / (_max - _min);
            } else {
              t = 1;
            }
          } else {
            t = val;
          }
          if (!bypassMap) {
            t = tmap(t);
          }
          if (_gamma !== 1) {
            t = pow(t, _gamma);
          }
          t = _padding[0] + t * (1 - _padding[0] - _padding[1]);
          t = Math.min(1, Math.max(0, t));
          k = Math.floor(t * 1e4);
          if (_useCache && _colorCache[k]) {
            col = _colorCache[k];
          } else {
            if (type(_colors) === "array") {
              for (i = o = 0, ref = _pos.length - 1; 0 <= ref ? o <= ref : o >= ref; i = 0 <= ref ? ++o : --o) {
                p = _pos[i];
                if (t <= p) {
                  col = _colors[i];
                  break;
                }
                if (t >= p && i === _pos.length - 1) {
                  col = _colors[i];
                  break;
                }
                if (t > p && t < _pos[i + 1]) {
                  t = (t - p) / (_pos[i + 1] - p);
                  col = chroma2.interpolate(_colors[i], _colors[i + 1], t, _mode);
                  break;
                }
              }
            } else if (type(_colors) === "function") {
              col = _colors(t);
            }
            if (_useCache) {
              _colorCache[k] = col;
            }
          }
          return col;
        };
        resetCache = function() {
          return _colorCache = {};
        };
        setColors(colors2);
        f = function(v) {
          var c;
          c = chroma2(getColor(v));
          if (_out && c[_out]) {
            return c[_out]();
          } else {
            return c;
          }
        };
        f.classes = function(classes) {
          var d;
          if (classes != null) {
            if (type(classes) === "array") {
              _classes = classes;
              _domain = [classes[0], classes[classes.length - 1]];
            } else {
              d = chroma2.analyze(_domain);
              if (classes === 0) {
                _classes = [d.min, d.max];
              } else {
                _classes = chroma2.limits(d, "e", classes);
              }
            }
            return f;
          }
          return _classes;
        };
        f.domain = function(domain) {
          var c, d, k, len, o, ref, w;
          if (!arguments.length) {
            return _domain;
          }
          _min = domain[0];
          _max = domain[domain.length - 1];
          _pos = [];
          k = _colors.length;
          if (domain.length === k && _min !== _max) {
            for (o = 0, len = domain.length; o < len; o++) {
              d = domain[o];
              _pos.push((d - _min) / (_max - _min));
            }
          } else {
            for (c = w = 0, ref = k - 1; 0 <= ref ? w <= ref : w >= ref; c = 0 <= ref ? ++w : --w) {
              _pos.push(c / (k - 1));
            }
          }
          _domain = [_min, _max];
          return f;
        };
        f.mode = function(_m) {
          if (!arguments.length) {
            return _mode;
          }
          _mode = _m;
          resetCache();
          return f;
        };
        f.range = function(colors3, _pos2) {
          setColors(colors3, _pos2);
          return f;
        };
        f.out = function(_o) {
          _out = _o;
          return f;
        };
        f.spread = function(val) {
          if (!arguments.length) {
            return _spread;
          }
          _spread = val;
          return f;
        };
        f.correctLightness = function(v) {
          if (v == null) {
            v = true;
          }
          _correctLightness = v;
          resetCache();
          if (_correctLightness) {
            tmap = function(t) {
              var L0, L1, L_actual, L_diff, L_ideal, max_iter, pol, t0, t1;
              L0 = getColor(0, true).lab()[0];
              L1 = getColor(1, true).lab()[0];
              pol = L0 > L1;
              L_actual = getColor(t, true).lab()[0];
              L_ideal = L0 + (L1 - L0) * t;
              L_diff = L_actual - L_ideal;
              t0 = 0;
              t1 = 1;
              max_iter = 20;
              while (Math.abs(L_diff) > 0.01 && max_iter-- > 0) {
                (function() {
                  if (pol) {
                    L_diff *= -1;
                  }
                  if (L_diff < 0) {
                    t0 = t;
                    t += (t1 - t) * 0.5;
                  } else {
                    t1 = t;
                    t += (t0 - t) * 0.5;
                  }
                  L_actual = getColor(t, true).lab()[0];
                  return L_diff = L_actual - L_ideal;
                })();
              }
              return t;
            };
          } else {
            tmap = function(t) {
              return t;
            };
          }
          return f;
        };
        f.padding = function(p) {
          if (p != null) {
            if (type(p) === "number") {
              p = [p, p];
            }
            _padding = p;
            return f;
          } else {
            return _padding;
          }
        };
        f.colors = function(numColors, out) {
          var dd, dm, i, o, ref, result2, results, samples, w;
          if (arguments.length < 2) {
            out = "hex";
          }
          result2 = [];
          if (arguments.length === 0) {
            result2 = _colors.slice(0);
          } else if (numColors === 1) {
            result2 = [f(0.5)];
          } else if (numColors > 1) {
            dm = _domain[0];
            dd = _domain[1] - dm;
            result2 = function() {
              results = [];
              for (var o2 = 0; 0 <= numColors ? o2 < numColors : o2 > numColors; 0 <= numColors ? o2++ : o2--) {
                results.push(o2);
              }
              return results;
            }.apply(this).map(function(i2) {
              return f(dm + i2 / (numColors - 1) * dd);
            });
          } else {
            colors2 = [];
            samples = [];
            if (_classes && _classes.length > 2) {
              for (i = w = 1, ref = _classes.length; 1 <= ref ? w < ref : w > ref; i = 1 <= ref ? ++w : --w) {
                samples.push((_classes[i - 1] + _classes[i]) * 0.5);
              }
            } else {
              samples = _domain;
            }
            result2 = samples.map(function(v) {
              return f(v);
            });
          }
          if (chroma2[out]) {
            result2 = result2.map(function(c) {
              return c[out]();
            });
          }
          return result2;
        };
        f.cache = function(c) {
          if (c != null) {
            _useCache = c;
            return f;
          } else {
            return _useCache;
          }
        };
        f.gamma = function(g) {
          if (g != null) {
            _gamma = g;
            return f;
          } else {
            return _gamma;
          }
        };
        f.nodata = function(d) {
          if (d != null) {
            _nacol = chroma2(d);
            return f;
          } else {
            return _nacol;
          }
        };
        return f;
      };
      if (chroma2.scales == null) {
        chroma2.scales = {};
      }
      chroma2.scales.cool = function() {
        return chroma2.scale([chroma2.hsl(180, 1, 0.9), chroma2.hsl(250, 0.7, 0.4)]);
      };
      chroma2.scales.hot = function() {
        return chroma2.scale(["#000", "#f00", "#ff0", "#fff"], [0, 0.25, 0.75, 1]).mode("rgb");
      };
      chroma2.analyze = function(data, key, filter) {
        var add3, k, len, o, r, val, visit;
        r = {
          min: Number.MAX_VALUE,
          max: Number.MAX_VALUE * -1,
          sum: 0,
          values: [],
          count: 0
        };
        if (filter == null) {
          filter = function() {
            return true;
          };
        }
        add3 = function(val2) {
          if (val2 != null && !isNaN(val2)) {
            r.values.push(val2);
            r.sum += val2;
            if (val2 < r.min) {
              r.min = val2;
            }
            if (val2 > r.max) {
              r.max = val2;
            }
            r.count += 1;
          }
        };
        visit = function(val2, k2) {
          if (filter(val2, k2)) {
            if (key != null && type(key) === "function") {
              return add3(key(val2));
            } else if (key != null && type(key) === "string" || type(key) === "number") {
              return add3(val2[key]);
            } else {
              return add3(val2);
            }
          }
        };
        if (type(data) === "array") {
          for (o = 0, len = data.length; o < len; o++) {
            val = data[o];
            visit(val);
          }
        } else {
          for (k in data) {
            val = data[k];
            visit(val, k);
          }
        }
        r.domain = [r.min, r.max];
        r.limits = function(mode2, num) {
          return chroma2.limits(r, mode2, num);
        };
        return r;
      };
      chroma2.limits = function(data, mode2, num) {
        var aa, ab, ac, ad, ae, af, ag, ah, ai, aj, ak, al, am, assignments, best, centroids, cluster, clusterSizes, dist, i, j, kClusters, limits, max_log, min, min_log, mindist, n, nb_iters, newCentroids, o, p, pb, pr, ref, ref1, ref10, ref11, ref12, ref13, ref14, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, repeat, sum, tmpKMeansBreaks, v, value, values, w;
        if (mode2 == null) {
          mode2 = "equal";
        }
        if (num == null) {
          num = 7;
        }
        if (type(data) === "array") {
          data = chroma2.analyze(data);
        }
        min = data.min;
        max = data.max;
        sum = data.sum;
        values = data.values.sort(function(a, b) {
          return a - b;
        });
        if (num === 1) {
          return [min, max];
        }
        limits = [];
        if (mode2.substr(0, 1) === "c") {
          limits.push(min);
          limits.push(max);
        }
        if (mode2.substr(0, 1) === "e") {
          limits.push(min);
          for (i = o = 1, ref = num - 1; 1 <= ref ? o <= ref : o >= ref; i = 1 <= ref ? ++o : --o) {
            limits.push(min + i / num * (max - min));
          }
          limits.push(max);
        } else if (mode2.substr(0, 1) === "l") {
          if (min <= 0) {
            throw "Logarithmic scales are only possible for values > 0";
          }
          min_log = Math.LOG10E * log2(min);
          max_log = Math.LOG10E * log2(max);
          limits.push(min);
          for (i = w = 1, ref1 = num - 1; 1 <= ref1 ? w <= ref1 : w >= ref1; i = 1 <= ref1 ? ++w : --w) {
            limits.push(pow(10, min_log + i / num * (max_log - min_log)));
          }
          limits.push(max);
        } else if (mode2.substr(0, 1) === "q") {
          limits.push(min);
          for (i = aa = 1, ref2 = num - 1; 1 <= ref2 ? aa <= ref2 : aa >= ref2; i = 1 <= ref2 ? ++aa : --aa) {
            p = (values.length - 1) * i / num;
            pb = floor(p);
            if (pb === p) {
              limits.push(values[pb]);
            } else {
              pr = p - pb;
              limits.push(values[pb] * (1 - pr) + values[pb + 1] * pr);
            }
          }
          limits.push(max);
        } else if (mode2.substr(0, 1) === "k") {
          n = values.length;
          assignments = new Array(n);
          clusterSizes = new Array(num);
          repeat = true;
          nb_iters = 0;
          centroids = null;
          centroids = [];
          centroids.push(min);
          for (i = ab = 1, ref3 = num - 1; 1 <= ref3 ? ab <= ref3 : ab >= ref3; i = 1 <= ref3 ? ++ab : --ab) {
            centroids.push(min + i / num * (max - min));
          }
          centroids.push(max);
          while (repeat) {
            for (j = ac = 0, ref4 = num - 1; 0 <= ref4 ? ac <= ref4 : ac >= ref4; j = 0 <= ref4 ? ++ac : --ac) {
              clusterSizes[j] = 0;
            }
            for (i = ad = 0, ref5 = n - 1; 0 <= ref5 ? ad <= ref5 : ad >= ref5; i = 0 <= ref5 ? ++ad : --ad) {
              value = values[i];
              mindist = Number.MAX_VALUE;
              for (j = ae = 0, ref6 = num - 1; 0 <= ref6 ? ae <= ref6 : ae >= ref6; j = 0 <= ref6 ? ++ae : --ae) {
                dist = abs(centroids[j] - value);
                if (dist < mindist) {
                  mindist = dist;
                  best = j;
                }
              }
              clusterSizes[best]++;
              assignments[i] = best;
            }
            newCentroids = new Array(num);
            for (j = af = 0, ref7 = num - 1; 0 <= ref7 ? af <= ref7 : af >= ref7; j = 0 <= ref7 ? ++af : --af) {
              newCentroids[j] = null;
            }
            for (i = ag = 0, ref8 = n - 1; 0 <= ref8 ? ag <= ref8 : ag >= ref8; i = 0 <= ref8 ? ++ag : --ag) {
              cluster = assignments[i];
              if (newCentroids[cluster] === null) {
                newCentroids[cluster] = values[i];
              } else {
                newCentroids[cluster] += values[i];
              }
            }
            for (j = ah = 0, ref9 = num - 1; 0 <= ref9 ? ah <= ref9 : ah >= ref9; j = 0 <= ref9 ? ++ah : --ah) {
              newCentroids[j] *= 1 / clusterSizes[j];
            }
            repeat = false;
            for (j = ai = 0, ref10 = num - 1; 0 <= ref10 ? ai <= ref10 : ai >= ref10; j = 0 <= ref10 ? ++ai : --ai) {
              if (newCentroids[j] !== centroids[i]) {
                repeat = true;
                break;
              }
            }
            centroids = newCentroids;
            nb_iters++;
            if (nb_iters > 200) {
              repeat = false;
            }
          }
          kClusters = {};
          for (j = aj = 0, ref11 = num - 1; 0 <= ref11 ? aj <= ref11 : aj >= ref11; j = 0 <= ref11 ? ++aj : --aj) {
            kClusters[j] = [];
          }
          for (i = ak = 0, ref12 = n - 1; 0 <= ref12 ? ak <= ref12 : ak >= ref12; i = 0 <= ref12 ? ++ak : --ak) {
            cluster = assignments[i];
            kClusters[cluster].push(values[i]);
          }
          tmpKMeansBreaks = [];
          for (j = al = 0, ref13 = num - 1; 0 <= ref13 ? al <= ref13 : al >= ref13; j = 0 <= ref13 ? ++al : --al) {
            tmpKMeansBreaks.push(kClusters[j][0]);
            tmpKMeansBreaks.push(kClusters[j][kClusters[j].length - 1]);
          }
          tmpKMeansBreaks = tmpKMeansBreaks.sort(function(a, b) {
            return a - b;
          });
          limits.push(tmpKMeansBreaks[0]);
          for (i = am = 1, ref14 = tmpKMeansBreaks.length - 1; am <= ref14; i = am += 2) {
            v = tmpKMeansBreaks[i];
            if (!isNaN(v) && limits.indexOf(v) === -1) {
              limits.push(v);
            }
          }
        }
        return limits;
      };
      hsi2rgb = function(h, s, i) {
        var args, b, g, r;
        args = unpack(arguments);
        h = args[0], s = args[1], i = args[2];
        if (isNaN(h)) {
          h = 0;
        }
        h /= 360;
        if (h < 1 / 3) {
          b = (1 - s) / 3;
          r = (1 + s * cos(TWOPI * h) / cos(PITHIRD - TWOPI * h)) / 3;
          g = 1 - (b + r);
        } else if (h < 2 / 3) {
          h -= 1 / 3;
          r = (1 - s) / 3;
          g = (1 + s * cos(TWOPI * h) / cos(PITHIRD - TWOPI * h)) / 3;
          b = 1 - (r + g);
        } else {
          h -= 2 / 3;
          g = (1 - s) / 3;
          b = (1 + s * cos(TWOPI * h) / cos(PITHIRD - TWOPI * h)) / 3;
          r = 1 - (g + b);
        }
        r = limit(i * r * 3);
        g = limit(i * g * 3);
        b = limit(i * b * 3);
        return [r * 255, g * 255, b * 255, args.length > 3 ? args[3] : 1];
      };
      rgb2hsi = function() {
        var b, g, h, i, min, r, ref, s;
        ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
        TWOPI = Math.PI * 2;
        r /= 255;
        g /= 255;
        b /= 255;
        min = Math.min(r, g, b);
        i = (r + g + b) / 3;
        s = 1 - min / i;
        if (s === 0) {
          h = 0;
        } else {
          h = (r - g + (r - b)) / 2;
          h /= Math.sqrt((r - g) * (r - g) + (r - b) * (g - b));
          h = Math.acos(h);
          if (b > g) {
            h = TWOPI - h;
          }
          h /= TWOPI;
        }
        return [h * 360, s, i];
      };
      chroma2.hsi = function() {
        return function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor(), result2 = func.apply(child, args);
          return Object(result2) === result2 ? result2 : child;
        }(Color, slice.call(arguments).concat(["hsi"]), function() {
        });
      };
      _input.hsi = hsi2rgb;
      Color.prototype.hsi = function() {
        return rgb2hsi(this._rgb);
      };
      interpolate_hsx = function(col1, col2, f, m2) {
        var dh, hue, hue0, hue1, lbv, lbv0, lbv1, res, sat, sat0, sat1, xyz0, xyz1;
        if (m2 === "hsl") {
          xyz0 = col1.hsl();
          xyz1 = col2.hsl();
        } else if (m2 === "hsv") {
          xyz0 = col1.hsv();
          xyz1 = col2.hsv();
        } else if (m2 === "hcg") {
          xyz0 = col1.hcg();
          xyz1 = col2.hcg();
        } else if (m2 === "hsi") {
          xyz0 = col1.hsi();
          xyz1 = col2.hsi();
        } else if (m2 === "lch" || m2 === "hcl") {
          m2 = "hcl";
          xyz0 = col1.hcl();
          xyz1 = col2.hcl();
        }
        if (m2.substr(0, 1) === "h") {
          hue0 = xyz0[0], sat0 = xyz0[1], lbv0 = xyz0[2];
          hue1 = xyz1[0], sat1 = xyz1[1], lbv1 = xyz1[2];
        }
        if (!isNaN(hue0) && !isNaN(hue1)) {
          if (hue1 > hue0 && hue1 - hue0 > 180) {
            dh = hue1 - (hue0 + 360);
          } else if (hue1 < hue0 && hue0 - hue1 > 180) {
            dh = hue1 + 360 - hue0;
          } else {
            dh = hue1 - hue0;
          }
          hue = hue0 + f * dh;
        } else if (!isNaN(hue0)) {
          hue = hue0;
          if ((lbv1 === 1 || lbv1 === 0) && m2 !== "hsv") {
            sat = sat0;
          }
        } else if (!isNaN(hue1)) {
          hue = hue1;
          if ((lbv0 === 1 || lbv0 === 0) && m2 !== "hsv") {
            sat = sat1;
          }
        } else {
          hue = Number.NaN;
        }
        if (sat == null) {
          sat = sat0 + f * (sat1 - sat0);
        }
        lbv = lbv0 + f * (lbv1 - lbv0);
        return res = chroma2[m2](hue, sat, lbv);
      };
      _interpolators = _interpolators.concat(function() {
        var len, o, ref, results;
        ref = ["hsv", "hsl", "hsi", "hcl", "lch", "hcg"];
        results = [];
        for (o = 0, len = ref.length; o < len; o++) {
          m = ref[o];
          results.push([m, interpolate_hsx]);
        }
        return results;
      }());
      interpolate_num = function(col1, col2, f, m2) {
        var n1, n2;
        n1 = col1.num();
        n2 = col2.num();
        return chroma2.num(n1 + (n2 - n1) * f, "num");
      };
      _interpolators.push(["num", interpolate_num]);
      interpolate_lab = function(col1, col2, f, m2) {
        var res, xyz0, xyz1;
        xyz0 = col1.lab();
        xyz1 = col2.lab();
        return res = new Color(xyz0[0] + f * (xyz1[0] - xyz0[0]), xyz0[1] + f * (xyz1[1] - xyz0[1]), xyz0[2] + f * (xyz1[2] - xyz0[2]), m2);
      };
      _interpolators.push(["lab", interpolate_lab]);
    }).call(exports4);
  }
});

// node_modules/dufour-peyton-intersection/src/categorize-intersection.js
var require_categorize_intersection = __commonJS({
  "node_modules/dufour-peyton-intersection/src/categorize-intersection.js"(exports4, module) {
    module.exports = function categorizeIntersection(segments) {
      try {
        let through, xmin, xmax;
        const n = segments.length;
        const first = segments[0];
        if (n === 1) {
          through = true;
          xmin = first.xmin;
          xmax = first.xmax;
        } else {
          const last = segments[n - 1];
          through = first.direction === last.direction;
          xmin = Math.min(first.xmin, last.xmin);
          xmax = Math.max(first.xmax, last.xmax);
        }
        if (xmin === void 0 || xmax === void 0 || through === void 0 || isNaN(xmin) || isNaN(xmax)) {
          throw Error("categorizeIntersection failed with xmin", xmin, "and xmax", xmax);
        }
        return { xmin, xmax, through };
      } catch (error) {
        console.error("[categorizeIntersection] segments:", segments);
        console.error("[categorizeIntersection]", error);
        throw error;
      }
    };
  }
});

// node_modules/dufour-peyton-intersection/src/clamp.js
var require_clamp = __commonJS({
  "node_modules/dufour-peyton-intersection/src/clamp.js"(exports4, module) {
    module.exports = function clamp(n, min, max) {
      if (n < min)
        return min;
      else if (n > max)
        return max;
      return n;
    };
  }
});

// node_modules/dufour-peyton-intersection/src/cluster.js
var require_cluster = __commonJS({
  "node_modules/dufour-peyton-intersection/src/cluster.js"(exports4, module) {
    module.exports = function cluster(items, newClusterTest) {
      try {
        const numberOfItems = items.length;
        const clusters = [];
        let cluster2 = [];
        for (let i = 0; i < numberOfItems; i++) {
          const item = items[i];
          cluster2.push(item);
          if (newClusterTest(item)) {
            clusters.push(cluster2);
            cluster2 = [];
          }
        }
        if (cluster2.length > 0)
          clusters.push(cluster2);
        return clusters;
      } catch (error) {
        console.error("[cluster]:", error);
      }
    };
  }
});

// node_modules/dufour-peyton-intersection/src/cluster-line-segments.js
var require_cluster_line_segments = __commonJS({
  "node_modules/dufour-peyton-intersection/src/cluster-line-segments.js"(exports4, module) {
    var cluster = require_cluster();
    module.exports = function clusterLineSegments(lineSegments, numberOfEdges, debug = false) {
      try {
        const clusters = cluster(lineSegments, (s) => s.endsOffLine);
        const numberOfClusters = clusters.length;
        if (numberOfClusters >= 2) {
          const firstCluster = clusters[0];
          const firstSegment = firstCluster[0];
          const lastCluster = clusters[clusters.length - 1];
          const lastSegment = lastCluster[lastCluster.length - 1];
          if (lastSegment.index === numberOfEdges - 1 && firstSegment.index === 0 && lastSegment.endsOnLine) {
            clusters[0] = clusters.pop().concat(firstCluster);
          }
        }
        return clusters;
      } catch (error) {
        console.error("[clusterLineSegments]", error);
      }
    };
  }
});

// node_modules/dufour-peyton-intersection/src/get-line-from-points.js
var require_get_line_from_points = __commonJS({
  "node_modules/dufour-peyton-intersection/src/get-line-from-points.js"(exports4, module) {
    module.exports = function getLineFromPoints(startPoint, endPoint) {
      const [x1, y1] = startPoint;
      const [x2, y2] = endPoint;
      const a = y2 - y1;
      const b = x1 - x2;
      const c = a * x1 + b * y1;
      return { a, b, c };
    };
  }
});

// node_modules/dufour-peyton-intersection/src/couple.js
var require_couple = __commonJS({
  "node_modules/dufour-peyton-intersection/src/couple.js"(exports4, module) {
    module.exports = function couple(array) {
      const couples = [];
      const lengthOfArray = array.length;
      for (let i = 0; i < lengthOfArray; i += 2) {
        couples.push([array[i], array[i + 1]]);
      }
      return couples;
    };
  }
});

// node_modules/dufour-peyton-intersection/src/each-edge.js
var require_each_edge = __commonJS({
  "node_modules/dufour-peyton-intersection/src/each-edge.js"(exports4, module) {
    module.exports = function eachEdge(polygon, callback) {
      polygon.forEach((ring) => {
        for (let i = 1; i < ring.length; i++) {
          const startPoint = ring[i - 1];
          const endPoint = ring[i];
          const edgeIndex = i - 1;
          callback([startPoint, endPoint], edgeIndex);
        }
      });
    };
  }
});

// node_modules/dufour-peyton-intersection/src/get-edges.js
var require_get_edges = __commonJS({
  "node_modules/dufour-peyton-intersection/src/get-edges.js"(exports4, module) {
    var eachEdge = require_each_edge();
    module.exports = function getEdges(polygon) {
      const edges = [];
      eachEdge(polygon, (edge) => edges.push(edge));
      return edges;
    };
  }
});

// node_modules/dufour-peyton-intersection/src/get-intersection-of-two-lines.js
var require_get_intersection_of_two_lines = __commonJS({
  "node_modules/dufour-peyton-intersection/src/get-intersection-of-two-lines.js"(exports4, module) {
    module.exports = function getIntersectionOfTwoLines(line1, line2) {
      const det = line1.a * line2.b - line2.a * line1.b;
      if (det) {
        const x = (line2.b * line1.c - line1.b * line2.c) / det;
        const y = (line1.a * line2.c - line2.a * line1.c) / det;
        return { x, y };
      }
    };
  }
});

// node_modules/get-depth/index.js
var require_get_depth = __commonJS({
  "node_modules/get-depth/index.js"(exports4, module) {
    module.exports = function getDepth(arr) {
      const isArray = (arr2) => Array.isArray(arr2) || arr2 instanceof Int8Array || arr2 instanceof Uint8Array || arr2 instanceof Uint8ClampedArray || arr2 instanceof Int16Array || arr2 instanceof Uint16Array || arr2 instanceof Int32Array || arr2 instanceof Uint32Array || arr2 instanceof Float32Array || arr2 instanceof Float64Array || arr2 instanceof BigInt64Array || arr2 instanceof BigUint64Array;
      let depth = 0;
      let part = arr;
      while (isArray(part)) {
        depth++;
        part = part[0];
      }
      return depth;
    };
  }
});

// node_modules/dufour-peyton-intersection/src/each-polygon.js
var require_each_polygon = __commonJS({
  "node_modules/dufour-peyton-intersection/src/each-polygon.js"(exports4, module) {
    var getDepth = require_get_depth();
    module.exports = function eachPolygon(geojson, callback) {
      if (geojson.type === "FeatureCollection") {
        geojson.features.forEach((feature) => eachPolygon(feature, callback));
      } else if (geojson.type === "Feature") {
        eachPolygon(geojson.geometry, callback);
      } else if (geojson.type === "Polygon") {
        eachPolygon(geojson.coordinates, callback);
      } else if (geojson.type === "MultiPolygon") {
        geojson.coordinates.forEach((polygon) => {
          callback(polygon);
        });
      } else if (Array.isArray(geojson)) {
        const depth = getDepth(geojson);
        if (depth === 4) {
          geojson.forEach((polygon) => {
            callback(polygon);
          });
        } else if (depth === 3) {
          callback(geojson);
        }
      }
    };
  }
});

// node_modules/dufour-peyton-intersection/src/get-polygons.js
var require_get_polygons = __commonJS({
  "node_modules/dufour-peyton-intersection/src/get-polygons.js"(exports4, module) {
    var eachPolygon = require_each_polygon();
    module.exports = function getPolygons(geojson) {
      const polygons = [];
      eachPolygon(geojson, (polygon) => polygons.push(polygon));
      return polygons;
    };
  }
});

// node_modules/dufour-peyton-intersection/src/merge-ranges.js
var require_merge_ranges = __commonJS({
  "node_modules/dufour-peyton-intersection/src/merge-ranges.js"(exports4, module) {
    module.exports = function mergeRanges(ranges) {
      const numberOfRanges = ranges.length;
      if (numberOfRanges > 0) {
        const firstRange = ranges[0];
        let previousEnd = firstRange[1];
        const result2 = [firstRange];
        for (let i = 1; i < numberOfRanges; i++) {
          const tempRange = ranges[i];
          const [start2, end] = tempRange;
          if (start2 <= previousEnd) {
            result2[result2.length - 1][1] = end;
          } else {
            result2.push(tempRange);
          }
          previousEnd = end;
        }
        return result2;
      }
    };
  }
});

// node_modules/dufour-peyton-intersection/src/partition.js
var require_partition = __commonJS({
  "node_modules/dufour-peyton-intersection/src/partition.js"(exports4, module) {
    module.exports = function partition(array, filter) {
      const passed = [];
      const unpassed = [];
      const len = array.length;
      for (let i = 0; i < len; i++) {
        const item = array[i];
        if (filter(item))
          passed.push(item);
        else
          unpassed.push(item);
      }
      return [passed, unpassed];
    };
  }
});

// node_modules/dufour-peyton-intersection/src/round-down.js
var require_round_down = __commonJS({
  "node_modules/dufour-peyton-intersection/src/round-down.js"(exports4, module) {
    module.exports = function roundDown(n) {
      return -1 * Math.round(-1 * n);
    };
  }
});

// node_modules/dufour-peyton-intersection/src/prepare-snap.js
var require_prepare_snap = __commonJS({
  "node_modules/dufour-peyton-intersection/src/prepare-snap.js"(exports4, module) {
    var roundDown = require_round_down();
    module.exports = function prepareSnap(raster_xmin, pixel_width) {
      return ([xmin, xmax]) => {
        xmin = roundDown((xmin - raster_xmin) / pixel_width);
        if (xmin === -0)
          xmin = 0;
        xmax = Math.round((xmax - raster_xmin) / pixel_width);
        if (xmax === -0)
          xmax = 0;
        return [xmin, xmax];
      };
    };
  }
});

// node_modules/dufour-peyton-intersection/src/range.js
var require_range = __commonJS({
  "node_modules/dufour-peyton-intersection/src/range.js"(exports4, module) {
    module.exports = function range2(count) {
      const result2 = new Array(count);
      for (let i = 0; i < count; i++)
        result2[i] = i;
      return result2;
    };
  }
});

// node_modules/dufour-peyton-intersection/src/calculate-core.js
var require_calculate_core = __commonJS({
  "node_modules/dufour-peyton-intersection/src/calculate-core.js"(exports4, module) {
    var getLineFromPoints = require_get_line_from_points();
    var categorizeIntersection = require_categorize_intersection();
    var clamp = require_clamp();
    var couple = require_couple();
    var clusterLineSegments = require_cluster_line_segments();
    var getEdges = require_get_edges();
    var getIntersectionOfTwoLines = require_get_intersection_of_two_lines();
    var getPolygons = require_get_polygons();
    var mergeRanges = require_merge_ranges();
    var partition = require_partition();
    var prepareSnap = require_prepare_snap();
    var range2 = require_range();
    module.exports = function calculateCore({
      debug_level = 0,
      raster_bbox,
      raster_height,
      raster_width,
      pixel_height,
      pixel_width,
      geometry,
      per_pixel,
      per_row_segment
    }) {
      const [raster_xmin, raster_ymin, raster_xmax, raster_ymax] = raster_bbox;
      const imageLines = [];
      if (raster_height === 0)
        return;
      for (let y = 0; y < raster_height; y++) {
        const lat = raster_ymax - pixel_height * y - pixel_height / 2;
        const point0 = [raster_xmin, lat];
        const point1 = [raster_xmin + 1, lat];
        const line = getLineFromPoints(point0, point1);
        imageLines.push(line);
      }
      if (debug_level >= 2)
        console.log("[dufour-peyton-intersection] imageLines:", imageLines);
      const polygons = getPolygons(geometry);
      const polygonEdges = polygons.map(getEdges);
      polygonEdges.forEach((edges) => {
        const intersectionsByRow = range2(raster_height).map(() => []);
        const numberOfEdges = edges.length;
        for (let i = 0; i < numberOfEdges; i++) {
          const edge = edges[i];
          const [startPoint, endPoint] = edge;
          const [x1, y1] = startPoint;
          const [x2, y2] = endPoint;
          const direction = Math.sign(y2 - y1);
          const horizontal = y1 === y2;
          const vertical = x1 === x2;
          const edgeY = y1;
          const edgeLine = getLineFromPoints(startPoint, endPoint);
          const edgeYMin = Math.min(y1, y2);
          const edgeYMax = Math.max(y1, y2);
          let startLng, startLat, endLat, endLng;
          if (x1 < x2) {
            [startLng, startLat] = startPoint;
            [endLng, endLat] = endPoint;
          } else {
            [startLng, startLat] = endPoint;
            [endLng, endLat] = startPoint;
          }
          if (startLng === void 0)
            throw Error("startLng is " + startLng);
          const imageY1 = Math.round((raster_bbox[3] - 0.5 * pixel_height - startLat) / pixel_height);
          const imageY2 = Math.round((raster_bbox[3] - 0.5 * pixel_height - endLat) / pixel_height);
          let rowStart, rowEnd;
          if (imageY1 < imageY2) {
            rowStart = imageY1;
            rowEnd = imageY2;
          } else {
            rowStart = imageY2;
            rowEnd = imageY1;
          }
          rowStart = clamp(rowStart, 0, raster_height - 1);
          rowEnd = clamp(rowEnd, 0, raster_height - 1);
          for (let j = rowStart; j < rowEnd + 1; j++) {
            const imageLine = imageLines[j];
            if (imageLine === void 0) {
              console.error("j:", j);
              console.error("imageLines:", imageLines);
              throw Error("imageLines");
            }
            const imageLineY = -1 * imageLine.c;
            const startsOnLine = y1 === imageLineY;
            const endsOnLine = y2 === imageLineY;
            const endsOffLine = !endsOnLine;
            let xminOnLine, xmaxOnLine;
            if (horizontal) {
              if (edgeY === imageLineY) {
                xminOnLine = startLng;
                xmaxOnLine = endLng;
              } else {
                continue;
              }
            } else if (vertical) {
              if (imageLineY >= edgeYMin && imageLineY <= edgeYMax) {
                xminOnLine = startLng;
                xmaxOnLine = endLng;
              }
            } else if (startsOnLine) {
              xminOnLine = xmaxOnLine = x1;
            } else if (endsOnLine) {
              xminOnLine = xmaxOnLine = x2;
            } else {
              try {
                xminOnLine = xmaxOnLine = getIntersectionOfTwoLines(edgeLine, imageLine).x;
              } catch (error) {
                throw error;
              }
            }
            if (xminOnLine !== void 0 && xmaxOnLine !== void 0 && (horizontal || xminOnLine >= startLng && xmaxOnLine <= endLng && imageLineY <= edgeYMax && imageLineY >= edgeYMin)) {
              intersectionsByRow[j].push({
                direction,
                index: i,
                edge,
                endsOnLine,
                endsOffLine,
                horizontal,
                startsOnLine,
                vertical,
                xmin: xminOnLine,
                xmax: xmaxOnLine,
                imageLineY
              });
            }
          }
        }
        const half_pixel_width = pixel_width / 2;
        const snap2 = prepareSnap(raster_xmin, pixel_width);
        intersectionsByRow.forEach((segmentsInRow, row_index) => {
          if (segmentsInRow.length > 0) {
            const clusters = clusterLineSegments(segmentsInRow, numberOfEdges);
            const categorized = clusters.map(categorizeIntersection);
            const [throughs, nonthroughs] = partition(categorized, (item) => item.through);
            if (throughs.length % 2 === 1) {
              if (debug_level >= 1)
                console.error("throughs:", JSON.stringify(throughs));
              throw Error("throughs.length for " + row_index + " is odd with " + throughs.length);
            }
            let insides2 = nonthroughs.map((intersection) => [intersection.xmin, intersection.xmax]);
            throughs.sort((a, b) => a.xmin - b.xmin);
            const couples = couple(throughs).map((couple2) => {
              const [left, right] = couple2;
              return [left.xmin, right.xmax];
            });
            insides2 = insides2.concat(couples);
            insides2 = mergeRanges(insides2);
            insides2.forEach((pair) => {
              const [xmin, xmax] = pair;
              if (xmax - xmin < half_pixel_width)
                return;
              const [left, right] = snap2(pair);
              if (left === right)
                return;
              if (left > raster_width)
                return;
              if (right <= 0)
                return;
              const start_column_index = Math.max(left, 0);
              const end_column_index = Math.min(right - 1, raster_width - 1);
              if (per_row_segment) {
                per_row_segment({
                  row: row_index,
                  columns: [start_column_index, end_column_index]
                });
              }
              if (per_pixel) {
                for (let column_index = start_column_index; column_index <= end_column_index; column_index++) {
                  per_pixel({ row: row_index, column: column_index });
                }
              }
            });
          }
        });
      });
    };
  }
});

// node_modules/dufour-peyton-intersection/src/check-rows.js
var require_check_rows = __commonJS({
  "node_modules/dufour-peyton-intersection/src/check-rows.js"(exports4, module) {
    module.exports = function checkRanges(rows) {
      rows.forEach((ranges, irow) => {
        for (let irange = 0; irange < ranges.length; irange++) {
          const range2 = ranges[irange];
          const [start2, end] = range2;
          if (start2 > end) {
            console.warn("[dufour-peyton-intersection] uh oh, encountered invalid range", range2, "at row index", irow, "with ranges", ranges);
          }
          for (let iother = irange + 1; iother < ranges.length; iother++) {
            if (iother[0] <= end) {
              console.warn("[dufour-peyton-intersection] encountered range problem on row index", irow, ":", ranges);
            }
          }
        }
      });
    };
  }
});

// node_modules/dufour-peyton-intersection/src/merge-consecutive-ranges.js
var require_merge_consecutive_ranges = __commonJS({
  "node_modules/dufour-peyton-intersection/src/merge-consecutive-ranges.js"(exports4, module) {
    module.exports = function mergeConsecutiveRanges(ranges) {
      const numberOfRanges = ranges.length;
      if (numberOfRanges > 0) {
        const firstRange = ranges[0];
        let previousEnd = firstRange[1];
        const result2 = [firstRange];
        for (let i = 1; i < numberOfRanges; i++) {
          const tempRange = ranges[i];
          const [start2, end] = tempRange;
          if (start2 <= previousEnd + 1) {
            result2[result2.length - 1][1] = end;
          } else {
            result2.push(tempRange);
          }
          previousEnd = end;
        }
        return result2;
      }
    };
  }
});

// node_modules/dufour-peyton-intersection/src/calculate.js
var require_calculate = __commonJS({
  "node_modules/dufour-peyton-intersection/src/calculate.js"(exports4, module) {
    var calculateCallbacks = require_calculate_core();
    var checkRows = require_check_rows();
    var mergeConsecutiveRanges = require_merge_consecutive_ranges();
    module.exports = function calculate({
      debug = false,
      raster_bbox,
      raster_height,
      raster_width,
      pixel_height,
      pixel_width,
      geometry,
      per_pixel,
      per_row_segment
    }) {
      const [xmin, ymin, xmax, ymax] = raster_bbox;
      if (pixel_height === void 0 || pixel_height === null)
        pixel_height = (ymax - ymin) / raster_height;
      if (pixel_width === void 0 || pixel_width === null)
        pixel_width = (xmax - xmin) / raster_width;
      const rows = new Array(raster_height);
      calculateCallbacks({
        raster_bbox,
        raster_height,
        raster_width,
        pixel_height,
        pixel_width,
        geometry,
        per_pixel,
        per_row_segment: ({ row, columns }) => {
          if (!rows[row])
            rows[row] = [];
          rows[row].push(columns);
          if (per_row_segment)
            per_row_segment({ row, columns });
        }
      });
      for (let irow = 0; irow < rows.length; irow++) {
        const ranges = rows[irow];
        if (ranges) {
          ranges.sort((a, b) => a === b ? a[1] - b[1] : a[0] - b[0]);
          rows[irow] = mergeConsecutiveRanges(ranges);
        }
      }
      if (debug)
        checkRows(insides);
      return { rows };
    };
  }
});

// node_modules/dufour-peyton-intersection/src/get-bounding-box.js
var require_get_bounding_box = __commonJS({
  "node_modules/dufour-peyton-intersection/src/get-bounding-box.js"(exports4, module) {
    var eachPolygon = require_each_polygon();
    module.exports = function getBoundingBox(geometry) {
      let xmin, ymin, xmax, ymax;
      eachPolygon(geometry, (polygon) => {
        const ring = polygon[0];
        const imax = ring.length - 1;
        let i;
        if (xmin === void 0) {
          xmin = xmax = ring[0][0];
          ymin = ymax = ring[0][1];
          i = 1;
        } else {
          i = 0;
        }
        for (; i <= imax; i++) {
          const [x, y] = ring[i];
          if (x < xmin)
            xmin = x;
          else if (x > xmax)
            xmax = x;
          if (y < ymin)
            ymin = y;
          else if (y > ymax)
            ymax = y;
        }
      });
      return [xmin, ymin, xmax, ymax];
    };
  }
});

// node_modules/dufour-peyton-intersection/src/index.js
var require_src = __commonJS({
  "node_modules/dufour-peyton-intersection/src/index.js"(exports4, module) {
    var categorizeIntersection = require_categorize_intersection();
    var clamp = require_clamp();
    var cluster = require_cluster();
    var clusterLineSegments = require_cluster_line_segments();
    var calculate = require_calculate();
    var calculateCore = require_calculate_core();
    var couple = require_couple();
    var getBoundingBox = require_get_bounding_box();
    var getPolygons = require_get_polygons();
    var eachEdge = require_each_edge();
    var getIntersectionOfTwoLines = require_get_intersection_of_two_lines();
    var getLineFromPoints = require_get_line_from_points();
    var mergeRanges = require_merge_ranges();
    var partition = require_partition();
    var prepareSnap = require_prepare_snap();
    var range2 = require_range();
    var roundDown = require_round_down();
    var dufour_peyton_intersection = {
      calculate,
      calculateCore,
      categorizeIntersection,
      clamp,
      cluster,
      clusterLineSegments,
      couple,
      eachEdge,
      getBoundingBox,
      getIntersectionOfTwoLines,
      getLineFromPoints,
      getPolygons,
      mergeRanges,
      partition,
      prepareSnap,
      range: range2,
      roundDown
    };
    if (typeof define === "function" && define.amd)
      define(() => dufour_peyton_intersection);
    if (typeof module === "object")
      module.exports = dufour_peyton_intersection;
    if (typeof self == "object")
      self.dufour_peyton_intersection = dufour_peyton_intersection;
    if (typeof window == "object")
      window.dufour_peyton_intersection = dufour_peyton_intersection;
  }
});

// node_modules/geomask/node_modules/preciso/expand.js
var require_expand = __commonJS({
  "node_modules/geomask/node_modules/preciso/expand.js"(exports4, module) {
    module.exports = function expand(n) {
      if (n[0] === "+")
        n = n.substring(1);
      const sign = n[0] === "-" ? "-" : "";
      if (sign === "-")
        n = n.substring(1);
      const index_of_e = n.indexOf("e");
      if (index_of_e === -1)
        return sign + n;
      let index_of_dot = n.indexOf(".");
      if (index_of_dot === -1)
        index_of_dot = index_of_e;
      const shift = Number(n.substring(index_of_e + 1));
      const base = n.substring(0, index_of_e).replace(".", "");
      const normshift = index_of_dot + shift;
      const baselen = base.length;
      if (normshift >= baselen) {
        const zct = normshift - baselen;
        let result2 = base;
        for (let i = 0; i < zct; i++)
          result2 += "0";
        return sign + result2;
      } else if (normshift < 0) {
        result = "0.";
        for (let i = 0; i > normshift; i--)
          result += "0";
        result += base;
        return sign + result;
      } else {
        return sign + base.substring(0, normshift) + "." + base.substring(normshift);
      }
    };
  }
});

// node_modules/geomask/node_modules/preciso/clean.js
var require_clean = __commonJS({
  "node_modules/geomask/node_modules/preciso/clean.js"(exports4, module) {
    var expand = require_expand();
    module.exports = function clean(n) {
      if (n[0] === "+")
        n = n.substring(1);
      n = expand(n);
      n = n.replace(/^0+(?=\d)/, "");
      return n;
    };
  }
});

// node_modules/geomask/node_modules/preciso/compare_positive.js
var require_compare_positive = __commonJS({
  "node_modules/geomask/node_modules/preciso/compare_positive.js"(exports4, module) {
    var clean = require_clean();
    module.exports = function compare_positive(a, b) {
      const alen = a.length;
      const blen = b.length;
      const aidx = a.indexOf(".");
      const bidx = b.indexOf(".");
      const a_adjusted_dot_index = aidx === -1 ? alen : aidx;
      const b_adjusted_dot_index = bidx === -1 ? blen : bidx;
      const offset = a_adjusted_dot_index - b_adjusted_dot_index;
      let left = Math.max(a_adjusted_dot_index, b_adjusted_dot_index);
      let right = Math.max(alen - a_adjusted_dot_index, blen - b_adjusted_dot_index);
      let aoffset = offset < 0 ? -1 * offset : 0;
      let boffset = offset <= 0 ? 0 : offset;
      let imax = left + 1 + right - 1;
      let i = 0;
      while (i < imax) {
        const achar = a[i - aoffset] || "0";
        const bchar = b[i - boffset] || "0";
        if (achar !== bchar) {
          if (achar > bchar)
            return ">";
          else if (achar < bchar)
            return "<";
        }
        i++;
      }
      return "=";
    };
  }
});

// node_modules/geomask/node_modules/preciso/long_addition.js
var require_long_addition = __commonJS({
  "node_modules/geomask/node_modules/preciso/long_addition.js"(exports4, module) {
    module.exports = function long_addition(a, b) {
      const alen = a.length;
      const blen = b.length;
      const aidx = a.indexOf(".");
      const bidx = b.indexOf(".");
      const a_adjusted_dot_index = aidx === -1 ? alen : aidx;
      const b_adjusted_dot_index = bidx === -1 ? blen : bidx;
      const offset = a_adjusted_dot_index - b_adjusted_dot_index;
      let left = Math.max(a_adjusted_dot_index, b_adjusted_dot_index);
      let right = Math.max(alen - a_adjusted_dot_index - 1, blen - b_adjusted_dot_index - 1);
      let aoffset = offset < 0 ? -1 * offset : 0;
      let boffset = offset <= 0 ? 0 : offset;
      let imax = left + 1 + right - 1;
      let result2 = "";
      let carried = 0;
      let i = imax;
      if (right > 0) {
        while (i > imax - right) {
          const achar = a[i - aoffset] || "0";
          const bchar = b[i - boffset] || "0";
          let n = Number(achar) + Number(bchar) + carried;
          if (n >= 10) {
            n -= 10;
            carried = 1;
          } else {
            carried = 0;
          }
          if (result2 !== "" || n !== 0) {
            result2 = n + result2;
          }
          i--;
        }
        if (result2)
          result2 = "." + result2;
        i--;
      }
      if (left > 0) {
        while (i >= 0) {
          const achar = a[i - aoffset] || "0";
          const bchar = b[i - boffset] || "0";
          let n = Number(achar) + Number(bchar) + carried;
          if (n >= 10) {
            n -= 10;
            carried = 1;
          } else {
            carried = 0;
          }
          result2 = n + result2;
          i--;
        }
      }
      if (carried === 1) {
        result2 = carried + result2;
      }
      return result2;
    };
  }
});

// node_modules/geomask/node_modules/preciso/long_subtraction.js
var require_long_subtraction = __commonJS({
  "node_modules/geomask/node_modules/preciso/long_subtraction.js"(exports4, module) {
    module.exports = function long_subtraction(a, b) {
      const alen = a.length;
      const blen = b.length;
      const aidx = a.indexOf(".");
      const bidx = b.indexOf(".");
      const a_adjusted_dot_index = aidx === -1 ? alen : aidx;
      const b_adjusted_dot_index = bidx === -1 ? blen : bidx;
      const offset = a_adjusted_dot_index - b_adjusted_dot_index;
      let left = Math.max(a_adjusted_dot_index, b_adjusted_dot_index);
      let right = Math.max(alen - a_adjusted_dot_index - 1, blen - b_adjusted_dot_index - 1);
      let aoffset = offset < 0 ? -1 * offset : 0;
      let boffset = offset <= 0 ? 0 : offset;
      let imax = left + 1 + right - 1;
      let result2 = "";
      let borrowed = 0;
      let i = imax;
      if (right > 0) {
        while (i > imax - right) {
          let top = a[i - aoffset] || "0";
          let bottom = b[i - boffset] || "0";
          top -= borrowed;
          borrowed = 0;
          let n = top - bottom;
          if (n < 0) {
            while (n < 0) {
              borrowed++;
              n += 10;
            }
          } else if (borrowed) {
            borrowed--;
          }
          if (result2 !== "" || n !== 0) {
            result2 = n + result2;
          }
          i--;
        }
        if (result2 !== "") {
          result2 = "." + result2;
        }
        i--;
      }
      if (left > 0) {
        while (i > 0) {
          let top = a[i - aoffset] || "0";
          let bottom = b[i - boffset] || "0";
          top -= borrowed;
          borrowed = 0;
          let n2 = top - bottom;
          if (n2 < 0) {
            while (n2 < 0) {
              borrowed++;
              n2 += 10;
            }
          } else if (borrowed) {
            borrowed--;
          }
          result2 = n2 + result2;
          i--;
        }
        const achar = a[0 - aoffset] || "0";
        const bchar = b[0 - boffset] || "0";
        let n = Number(achar) - (borrowed > 0 ? 1 : 0) - Number(bchar);
        if (n !== 0) {
          result2 = n + result2;
        }
        result2 = result2.replace(/^0+/, "");
      }
      if (result2[0] === ".")
        result2 = "0" + result2;
      return result2;
    };
  }
});

// node_modules/geomask/node_modules/preciso/subtract.js
var require_subtract = __commonJS({
  "node_modules/geomask/node_modules/preciso/subtract.js"(exports4, module) {
    var clean = require_clean();
    var compare_positive = require_compare_positive();
    var long_addition = require_long_addition();
    var long_subtraction = require_long_subtraction();
    module.exports = function subtract2(a, b) {
      a = clean(a);
      b = clean(b);
      const a_is_positive = a[0] !== "-";
      const b_is_positive = b[0] !== "-";
      if (a_is_positive) {
        if (b_is_positive) {
          const comparison = compare_positive(a, b);
          if (comparison === ">") {
            return long_subtraction(a, b);
          } else if (comparison === "<") {
            return "-" + long_subtraction(b, a);
          } else {
            return "0";
          }
        } else {
          return long_addition(a, b.substring(1));
        }
      } else if (b_is_positive) {
        return "-" + long_addition(a.substring(1), b);
      } else {
        a = a.substring(1);
        b = b.substring(1);
        const comparison = compare_positive(a, b);
        if (comparison === ">") {
          return "-" + long_subtraction(a, b);
        } else if (comparison === "<") {
          return long_subtraction(b, a);
        } else {
          return "0";
        }
      }
    };
  }
});

// node_modules/geomask/node_modules/preciso/absolute.js
var require_absolute = __commonJS({
  "node_modules/geomask/node_modules/preciso/absolute.js"(exports4, module) {
    var clean = require_clean();
    module.exports = function absolute(n) {
      n = clean(n);
      if (n[0] === "-")
        return n.substring(1);
      else
        return n;
    };
  }
});

// node_modules/geomask/node_modules/preciso/add.js
var require_add = __commonJS({
  "node_modules/geomask/node_modules/preciso/add.js"(exports4, module) {
    var compare_positive = require_compare_positive();
    var clean = require_clean();
    var long_addition = require_long_addition();
    var long_subtraction = require_long_subtraction();
    module.exports = function add3(a, b) {
      a = clean(a);
      b = clean(b);
      const apos = a[0] !== "-";
      const bpos = b[0] !== "-";
      if (apos && bpos) {
        return long_addition(a, b);
      } else if (!apos && !bpos) {
        return "-" + long_addition(a.substring(1), b.substring(1));
      } else if (!apos && bpos) {
        a = a.substring(1);
        switch (compare_positive(a, b)) {
          case "=":
            return "0";
          case "<":
            return long_subtraction(b, a);
          case ">":
            return "-" + long_subtraction(a, b);
        }
      } else if (apos && !bpos) {
        b = b.substring(1);
        switch (compare_positive(a, b)) {
          case "=":
            return "0";
          case "<":
            return "-" + long_subtraction(b, a);
          case ">":
            return long_subtraction(a, b);
        }
      }
    };
  }
});

// node_modules/geomask/node_modules/preciso/long_multiplication.js
var require_long_multiplication = __commonJS({
  "node_modules/geomask/node_modules/preciso/long_multiplication.js"(exports4, module) {
    var CHUNK_SIZE = 15;
    module.exports = function long_multiplication(a, b) {
      if (a === "0" || b === "0")
        return "0";
      const top_index_of_dot = a.indexOf(".");
      const bottom_index_of_dot = b.indexOf(".");
      const a_num_decimal_places = top_index_of_dot === -1 ? 0 : a.length - 1 - top_index_of_dot;
      const b_num_decimal_places = bottom_index_of_dot === -1 ? 0 : b.length - 1 - bottom_index_of_dot;
      const out_num_decimal_places = a_num_decimal_places + b_num_decimal_places;
      a = a.replace(".", "");
      b = b.replace(".", "");
      const alen = a.length;
      const blen = b.length;
      const chunks = [];
      let i = alen;
      while (i >= 0) {
        const end = i;
        const start2 = i -= CHUNK_SIZE;
        const str = a.substring(start2, end);
        chunks.push([Number(str), str.length]);
      }
      const partial_products = [];
      const partials = [];
      for (let i2 = 0, ireverse = blen - 1; ireverse >= 0; ireverse--, i2++) {
        const bstr = b[ireverse];
        const bnum = Number(bstr);
        let carried2 = 0;
        let partial = "";
        const ichunklast = chunks.length - 1;
        chunks.forEach(([chunk, chunklen], c) => {
          const subpartial = carried2 + bnum * chunk;
          let subpartstr = subpartial.toString();
          const subpartcharlen = subpartstr.length;
          if (subpartcharlen > chunklen && c !== ichunklast) {
            const islice = -1 * chunklen;
            partial = subpartstr.slice(islice) + partial;
            carried2 = Number(subpartstr.slice(0, islice));
          } else {
            const imax = chunklen - subpartcharlen;
            for (let i3 = 0; i3 < imax; i3++) {
              subpartstr = "0" + subpartstr;
            }
            carried2 = 0;
            partial = subpartstr + partial;
          }
        });
        partial += "0".repeat(i2);
        partial_products.push(partial);
        partials.push([Array.from(partial).map((char) => Number(char)), partial.length]);
      }
      const num_partials = partial_products.length;
      const number_of_columns = partials[partials.length - 1][1] + num_partials;
      let result2 = "";
      let carried = 0;
      for (let icol = 0; icol < number_of_columns; icol++) {
        let sum = carried;
        const pmax = Math.min(icol, num_partials - 1);
        for (let p = 0; p <= pmax; p++) {
          const [pnums, plen] = partials[p];
          const i2 = plen - 1 - icol;
          if (i2 >= 0) {
            sum += pnums[i2];
          }
        }
        if (sum >= 10) {
          sum = sum.toString();
          result2 = sum[sum.length - 1] + result2;
          carried = Number(sum.slice(0, -1));
        } else {
          result2 = sum + result2;
          carried = 0;
        }
      }
      if (out_num_decimal_places === 0) {
        result2 = result2.replace(/^0+/, "");
      } else {
        const idot = result2.length - out_num_decimal_places;
        result2 = result2.substring(0, idot) + "." + result2.substring(idot);
        result2 = result2.replace(/^0+/, "");
        result2 = result2.replace(/\.?0+$/, "");
        if (result2[0] === ".")
          result2 = "0" + result2;
      }
      return result2;
    };
  }
});

// node_modules/geomask/node_modules/preciso/multiply.js
var require_multiply = __commonJS({
  "node_modules/geomask/node_modules/preciso/multiply.js"(exports4, module) {
    var absolute = require_absolute();
    var clean = require_clean();
    var compare_positive = require_compare_positive();
    var long_multiplication = require_long_multiplication();
    module.exports = function multiply2(a, b) {
      a = clean(a);
      b = clean(b);
      const apos = a[0] !== "-";
      const bpos = b[0] !== "-";
      const out_sign = apos !== bpos ? "-" : "";
      a = absolute(a);
      b = absolute(b);
      const comparison = compare_positive(a, b);
      if (comparison === "<") {
        const aold = a;
        const bold = b;
        a = bold;
        b = aold;
      }
      return out_sign + long_multiplication(a, b);
    };
  }
});

// node_modules/geomask/node_modules/preciso/round_last_decimal.js
var require_round_last_decimal = __commonJS({
  "node_modules/geomask/node_modules/preciso/round_last_decimal.js"(exports4, module) {
    var up = ["5", "6", "7", "8", "9"];
    module.exports = function round_last_decimal(n) {
      if (n[0] === "+")
        n = n.substring(1);
      const len = n.length;
      let result2 = "";
      const last_char = n[n.length - 1];
      if (up.includes(last_char)) {
        let i;
        for (i = len - 2; i >= 0; i--) {
          const char = n[i];
          if (char === "." || char === "-")
            continue;
          const nchar = Number(char) + 1;
          if (nchar === 10) {
            result2 = "0" + result2;
          } else {
            result2 = nchar + result2;
            break;
          }
        }
        if (i > 0)
          result2 = n.substring(0, i) + result2;
      } else {
        result2 = n.substring(0, len - 1);
      }
      if (result2[result2.length - 1] === ".")
        result2 = result2.substring(0, result2.length - 1);
      if (result2.indexOf(".") > -1)
        result2 = result2.replace(/0+$/, "");
      return result2;
    };
  }
});

// node_modules/geomask/node_modules/preciso/long_division.js
var require_long_division = __commonJS({
  "node_modules/geomask/node_modules/preciso/long_division.js"(exports4, module) {
    var compare_positive = require_compare_positive();
    var add3 = require_add();
    var multiply2 = require_multiply();
    var subtract2 = require_subtract();
    var round_last_decimal = require_round_last_decimal();
    module.exports = function long_division(dividend, divisor, { max_decimal_digits = 100, ellipsis = false } = {}) {
      if (dividend[0] === "0")
        dividend = dividend.substring(1);
      if (divisor[0] === "0")
        divisor = divisor.substring(1);
      const dividend_index_of_dot = dividend.indexOf(".");
      const divisor_index_of_dot = divisor.indexOf(".");
      const adjusted_dividend_index_of_dot = dividend_index_of_dot === -1 ? dividend.length : dividend_index_of_dot;
      const divisor_num_decimal_places = divisor_index_of_dot === -1 ? 0 : divisor.length - 1 - divisor_index_of_dot;
      let repeating = false;
      dividend = dividend.replace(/\./, "");
      divisor = divisor.replace(/\./, "");
      const dividend_length = dividend.length;
      let current = "";
      let quotient = "";
      let comparison;
      let offset = -1 * divisor_num_decimal_places;
      let skip = 0;
      for (let i = 0; i < dividend_length; i++) {
        const char = dividend[i];
        current += char;
        comparison = compare_positive(current, divisor);
        if (comparison === ">") {
          let times = 1;
          let product = add3(divisor, divisor);
          let passed_product = divisor;
          while (compare_positive(product, current) !== ">") {
            times++;
            passed_product = product;
            product = add3(product, divisor);
          }
          times = times.toString();
          if (quotient !== "") {
            for (let i2 = times.length; i2 <= skip; i2++)
              quotient += "0";
          }
          quotient += times;
          current = subtract2(current, passed_product);
          skip = 0;
        } else if (comparison === "<") {
          if (quotient === "") {
            offset++;
          }
          skip++;
          continue;
        } else if (comparison === "=") {
          if (quotient !== "") {
            for (let i2 = 0; i2 < skip; i2++)
              quotient += "0";
          }
          quotient += "1";
          current = "0";
          skip = 0;
        }
      }
      if (current.match(/^0+$/g)) {
        if (comparison === "<") {
          quotient += current.substring(0, current.length - 1);
        }
      } else {
        const previous = {};
        const idot2 = adjusted_dividend_index_of_dot - offset;
        const qlen2 = quotient.length;
        const imax = idot2 - qlen2 + max_decimal_digits + 1;
        if (quotient === "") {
          skip = 0;
        }
        for (let i = 0; i < imax; i++) {
          current += "0";
          if (ellipsis) {
            if (current in previous) {
              previous[current]++;
              if (previous[current] > 3) {
                quotient += "...";
                repeating = true;
                break;
              }
            } else {
              previous[current] = 1;
            }
          }
          const comparison2 = compare_positive(current, divisor);
          if (comparison2 === ">") {
            let times = 1;
            let product = add3(divisor, divisor);
            let passed_product = divisor;
            while (compare_positive(product, current) !== ">") {
              times++;
              passed_product = product;
              product = add3(product, divisor);
            }
            times = times.toString();
            for (let i2 = times.length; i2 <= skip; i2++)
              quotient += "0";
            quotient += times;
            current = subtract2(current, passed_product);
            if (current === "0") {
              break;
            }
            skip = 0;
          } else if (comparison2 === "<") {
            skip++;
            continue;
          } else if (comparison2 === "=") {
            for (let i2 = 0; i2 < skip; i2++)
              quotient += "0";
            quotient += "1";
            skip = 0;
            break;
          }
        }
      }
      const idot = adjusted_dividend_index_of_dot - offset;
      const qlen = quotient.length;
      let num_decimals;
      if (idot === qlen) {
        num_decimals = 0;
      } else if (idot < 0) {
        quotient = "0." + "0".repeat(Math.abs(idot)) + quotient;
        num_decimals = qlen - idot;
      } else if (idot > qlen) {
        for (let i = qlen; i < idot; i++)
          quotient += "0";
        num_decimals = 0;
      } else if (idot < qlen) {
        quotient = quotient.substring(0, idot) + "." + quotient.substring(idot);
        num_decimals = qlen - idot;
      } else if (idot === 0) {
        quotient = "0." + quotient;
        num_decimals = qlen;
      }
      quotient = quotient.replace(/^0+/, "");
      quotient = quotient.replace(/\.\d+0+$/, "");
      if (!repeating) {
        const extra_decimals = num_decimals - max_decimal_digits;
        if (extra_decimals > 0) {
          quotient = round_last_decimal(quotient.substring(0, quotient.length - extra_decimals + 1));
        }
      }
      if (quotient[0] === ".")
        quotient = "0" + quotient;
      return quotient;
    };
  }
});

// node_modules/geomask/node_modules/preciso/divide.js
var require_divide = __commonJS({
  "node_modules/geomask/node_modules/preciso/divide.js"(exports4, module) {
    var absolute = require_absolute();
    var clean = require_clean();
    var long_division = require_long_division();
    module.exports = function(dividend, divisor, options) {
      dividend = clean(dividend);
      divisor = clean(divisor);
      const dividend_is_positive = dividend[0] !== "-";
      const divisor_is_positive = divisor[0] !== "-";
      const out_sign = dividend_is_positive !== divisor_is_positive ? "-" : "";
      if (!dividend_is_positive)
        dividend = absolute(dividend);
      if (!divisor_is_positive)
        divisor = absolute(divisor);
      return out_sign + long_division(dividend, divisor, options);
    };
  }
});

// node_modules/reproject-geojson/pluggable.js
var require_pluggable = __commonJS({
  "node_modules/reproject-geojson/pluggable.js"(exports4, module) {
    var clone = (data) => JSON.parse(JSON.stringify(data));
    function reprojectGeoJSONPluggable(data, { in_place = false, reproject }) {
      if (typeof reproject !== "function") {
        throw new Error(`[reproject-geojson] you must specify a reproject function`);
      }
      if (in_place !== true)
        data = clone(data);
      if (data.type === "FeatureCollection") {
        data.features = data.features.map((feature) => reprojectGeoJSONPluggable(feature, { in_place, reproject }));
      } else if (data.type === "Feature") {
        data.geometry = reprojectGeoJSONPluggable(data.geometry, { in_place, reproject });
      } else if (data.type === "LineString") {
        data.coordinates = data.coordinates.map((coord) => reproject(coord));
      } else if (data.type === "MultiLineString") {
        data.coordinates = data.coordinates.map((line) => line.map((coord) => reproject(coord)));
      } else if (data.type === "MultiPoint") {
        data.coordinates = data.coordinates.map((point3) => reproject(point3));
      } else if (data.type === "MultiPolygon") {
        data.coordinates = data.coordinates.map((polygon) => {
          return polygon.map((ring) => ring.map((coord) => reproject(coord)));
        });
      } else if (data.type === "Point") {
        data.coordinates = reproject(data.coordinates);
      } else if (data.type === "Polygon") {
        data.coordinates = data.coordinates.map((ring) => ring.map((coord) => reproject(coord)));
      }
      return data;
    }
    if (typeof define === "function" && define.amd)
      define(function() {
        return reprojectGeoJSONPluggable;
      });
    if (typeof module === "object")
      module.exports = reprojectGeoJSONPluggable;
    if (typeof window === "object")
      window.reprojectGeoJSONPluggable = reprojectGeoJSONPluggable;
    if (typeof self === "object")
      self.reprojectGeoJSONPluggable = reprojectGeoJSONPluggable;
  }
});

// node_modules/segflip/segflip.js
var require_segflip = __commonJS({
  "node_modules/segflip/segflip.js"(exports4, module) {
    function segflip({ segments: segs, min = -Infinity, max = Infinity, debug = false }) {
      if (debug)
        console.log("[segflip] segs:", segs);
      if (segs === void 0 || segs === null || Array.isArray(segs) && segs.length === 0) {
        if (debug)
          console.log("[segflip] segments are empty so return the whole row flipped");
        return [[min, max]];
      }
      const nums = segs.map(([start2, end]) => [start2 - 1, end + 1]).flat();
      nums.unshift(min);
      nums.push(max);
      if (debug)
        console.log("flattened nums:", nums);
      const results = [];
      for (let i = 1; i < nums.length; i += 2) {
        const start2 = nums[i - 1];
        const end = nums[i];
        if (start2 > end)
          continue;
        results.push([start2, end]);
      }
      return results;
    }
    if (typeof define === "function" && define.amd)
      define(function() {
        return segflip;
      });
    if (typeof module === "object")
      module.exports = segflip;
    if (typeof window === "object")
      window.segflip = segflip;
    if (typeof self === "object")
      self.segflip = segflip;
  }
});

// node_modules/geomask/lite.js
var require_lite = __commonJS({
  "node_modules/geomask/lite.js"(exports4, module) {
    var dufour_peyton_intersection = require_src();
    var subtract2 = require_subtract();
    var divide2 = require_divide();
    var reprojectGeoJSON = require_pluggable();
    var segflip = require_segflip();
    function checkRows({ rows }) {
      rows.forEach((segs, irow) => {
        if (segs) {
          segs.forEach(([start2, end], iseg) => {
            if (start2 > end) {
              throw Error(`uh oh: invalid segment at row ${irow}, segment ${iseg}`);
            }
          });
        }
      });
    }
    function inside({
      debug = false,
      raster_bbox,
      raster_height,
      raster_width,
      pixel_height,
      pixel_width,
      mask,
      reproject
    }) {
      if (typeof reproject === "function") {
        mask = reprojectGeoJSON(mask, { in_place: false, reproject });
      }
      if (pixel_height === void 0)
        pixel_height = Number(
          divide2(subtract2(raster_bbox[3].toString(), raster_bbox[1].toString()), raster_height.toString())
        );
      if (pixel_width === void 0)
        pixel_width = Number(
          divide2(subtract2(raster_bbox[2].toString(), raster_bbox[0].toString()), raster_width.toString())
        );
      const { rows } = dufour_peyton_intersection.calculate({
        raster_bbox,
        raster_height,
        raster_width,
        pixel_height,
        pixel_width,
        geometry: mask
      });
      if (debug)
        checkRows({ rows });
      return { rows };
    }
    function outside({
      debug = false,
      raster_bbox,
      raster_height,
      raster_width,
      pixel_height,
      pixel_width,
      mask,
      reproject
    }) {
      if (typeof reproject === "function") {
        mask = reprojectGeoJSON(mask, { in_place: false, reproject });
      }
      if (pixel_height === void 0)
        pixel_height = Number(
          divide2(subtract2(raster_bbox[3].toString(), raster_bbox[1].toString()), raster_height.toString())
        );
      if (pixel_width === void 0)
        pixel_width = Number(
          divide2(subtract2(raster_bbox[2].toString(), raster_bbox[0].toString()), raster_width.toString())
        );
      const { rows: insides2 } = inside({
        debug,
        raster_bbox,
        raster_height,
        raster_width,
        pixel_height,
        pixel_width,
        mask
      });
      if (debug)
        checkRows({ rows: insides2 });
      const last_column_index = raster_width - 1;
      const outsides = [];
      for (let i = 0; i < insides2.length; i++) {
        const segs = insides2[i];
        if (!Array.isArray(segs) || segs.length === 0) {
          outsides.push([[0, last_column_index]]);
        } else {
          outsides.push(
            segflip({
              segments: segs,
              min: 0,
              max: last_column_index,
              debug: false
            })
          );
        }
      }
      if (debug)
        checkRows({ rows: outsides });
      return { rows: outsides };
    }
    var geomask = { inside, outside };
    if (typeof module === "object")
      module.exports = geomask;
  }
});

// node_modules/proj4/lib/global.js
function global_default(defs2) {
  defs2("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees");
  defs2("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees");
  defs2("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");
  defs2.WGS84 = defs2["EPSG:4326"];
  defs2["EPSG:3785"] = defs2["EPSG:3857"];
  defs2.GOOGLE = defs2["EPSG:3857"];
  defs2["EPSG:900913"] = defs2["EPSG:3857"];
  defs2["EPSG:102113"] = defs2["EPSG:3857"];
}
var init_global = __esm({
  "node_modules/proj4/lib/global.js"() {
  }
});

// node_modules/proj4/lib/constants/values.js
var PJD_3PARAM, PJD_7PARAM, PJD_GRIDSHIFT, PJD_WGS84, PJD_NODATUM, SRS_WGS84_SEMIMAJOR, SRS_WGS84_SEMIMINOR, SRS_WGS84_ESQUARED, SEC_TO_RAD, HALF_PI, SIXTH, RA4, RA6, EPSLN, D2R, R2D, FORTPI, TWO_PI, SPI;
var init_values = __esm({
  "node_modules/proj4/lib/constants/values.js"() {
    PJD_3PARAM = 1;
    PJD_7PARAM = 2;
    PJD_GRIDSHIFT = 3;
    PJD_WGS84 = 4;
    PJD_NODATUM = 5;
    SRS_WGS84_SEMIMAJOR = 6378137;
    SRS_WGS84_SEMIMINOR = 6356752314e-3;
    SRS_WGS84_ESQUARED = 0.0066943799901413165;
    SEC_TO_RAD = 484813681109536e-20;
    HALF_PI = Math.PI / 2;
    SIXTH = 0.16666666666666666;
    RA4 = 0.04722222222222222;
    RA6 = 0.022156084656084655;
    EPSLN = 1e-10;
    D2R = 0.017453292519943295;
    R2D = 57.29577951308232;
    FORTPI = Math.PI / 4;
    TWO_PI = Math.PI * 2;
    SPI = 3.14159265359;
  }
});

// node_modules/proj4/lib/constants/PrimeMeridian.js
var exports;
var init_PrimeMeridian = __esm({
  "node_modules/proj4/lib/constants/PrimeMeridian.js"() {
    exports = {};
    exports.greenwich = 0;
    exports.lisbon = -9.131906111111;
    exports.paris = 2.337229166667;
    exports.bogota = -74.080916666667;
    exports.madrid = -3.687938888889;
    exports.rome = 12.452333333333;
    exports.bern = 7.439583333333;
    exports.jakarta = 106.807719444444;
    exports.ferro = -17.666666666667;
    exports.brussels = 4.367975;
    exports.stockholm = 18.058277777778;
    exports.athens = 23.7163375;
    exports.oslo = 10.722916666667;
  }
});

// node_modules/proj4/lib/constants/units.js
var units_default;
var init_units = __esm({
  "node_modules/proj4/lib/constants/units.js"() {
    units_default = {
      ft: { to_meter: 0.3048 },
      "us-ft": { to_meter: 1200 / 3937 }
    };
  }
});

// node_modules/proj4/lib/match.js
function match(obj2, key) {
  if (obj2[key]) {
    return obj2[key];
  }
  var keys = Object.keys(obj2);
  var lkey = key.toLowerCase().replace(ignoredChar, "");
  var i = -1;
  var testkey, processedKey;
  while (++i < keys.length) {
    testkey = keys[i];
    processedKey = testkey.toLowerCase().replace(ignoredChar, "");
    if (processedKey === lkey) {
      return obj2[testkey];
    }
  }
}
var ignoredChar;
var init_match = __esm({
  "node_modules/proj4/lib/match.js"() {
    ignoredChar = /[\s_\-\/\(\)]/g;
  }
});

// node_modules/proj4/lib/projString.js
function projString_default(defData) {
  var self2 = {};
  var paramObj = defData.split("+").map(function(v) {
    return v.trim();
  }).filter(function(a) {
    return a;
  }).reduce(function(p, a) {
    var split = a.split("=");
    split.push(true);
    p[split[0].toLowerCase()] = split[1];
    return p;
  }, {});
  var paramName, paramVal, paramOutname;
  var params2 = {
    proj: "projName",
    datum: "datumCode",
    rf: function(v) {
      self2.rf = parseFloat(v);
    },
    lat_0: function(v) {
      self2.lat0 = v * D2R;
    },
    lat_1: function(v) {
      self2.lat1 = v * D2R;
    },
    lat_2: function(v) {
      self2.lat2 = v * D2R;
    },
    lat_ts: function(v) {
      self2.lat_ts = v * D2R;
    },
    lon_0: function(v) {
      self2.long0 = v * D2R;
    },
    lon_1: function(v) {
      self2.long1 = v * D2R;
    },
    lon_2: function(v) {
      self2.long2 = v * D2R;
    },
    alpha: function(v) {
      self2.alpha = parseFloat(v) * D2R;
    },
    gamma: function(v) {
      self2.rectified_grid_angle = parseFloat(v);
    },
    lonc: function(v) {
      self2.longc = v * D2R;
    },
    x_0: function(v) {
      self2.x0 = parseFloat(v);
    },
    y_0: function(v) {
      self2.y0 = parseFloat(v);
    },
    k_0: function(v) {
      self2.k0 = parseFloat(v);
    },
    k: function(v) {
      self2.k0 = parseFloat(v);
    },
    a: function(v) {
      self2.a = parseFloat(v);
    },
    b: function(v) {
      self2.b = parseFloat(v);
    },
    r_a: function() {
      self2.R_A = true;
    },
    zone: function(v) {
      self2.zone = parseInt(v, 10);
    },
    south: function() {
      self2.utmSouth = true;
    },
    towgs84: function(v) {
      self2.datum_params = v.split(",").map(function(a) {
        return parseFloat(a);
      });
    },
    to_meter: function(v) {
      self2.to_meter = parseFloat(v);
    },
    units: function(v) {
      self2.units = v;
      var unit = match(units_default, v);
      if (unit) {
        self2.to_meter = unit.to_meter;
      }
    },
    from_greenwich: function(v) {
      self2.from_greenwich = v * D2R;
    },
    pm: function(v) {
      var pm = match(exports, v);
      self2.from_greenwich = (pm ? pm : parseFloat(v)) * D2R;
    },
    nadgrids: function(v) {
      if (v === "@null") {
        self2.datumCode = "none";
      } else {
        self2.nadgrids = v;
      }
    },
    axis: function(v) {
      var legalAxis = "ewnsud";
      if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {
        self2.axis = v;
      }
    },
    approx: function() {
      self2.approx = true;
    }
  };
  for (paramName in paramObj) {
    paramVal = paramObj[paramName];
    if (paramName in params2) {
      paramOutname = params2[paramName];
      if (typeof paramOutname === "function") {
        paramOutname(paramVal);
      } else {
        self2[paramOutname] = paramVal;
      }
    } else {
      self2[paramName] = paramVal;
    }
  }
  if (typeof self2.datumCode === "string" && self2.datumCode !== "WGS84") {
    self2.datumCode = self2.datumCode.toLowerCase();
  }
  return self2;
}
var init_projString = __esm({
  "node_modules/proj4/lib/projString.js"() {
    init_values();
    init_PrimeMeridian();
    init_units();
    init_match();
  }
});

// node_modules/wkt-parser/parser.js
function Parser(text) {
  if (typeof text !== "string") {
    throw new Error("not a string");
  }
  this.text = text.trim();
  this.level = 0;
  this.place = 0;
  this.root = null;
  this.stack = [];
  this.currentObject = null;
  this.state = NEUTRAL;
}
function parseString(txt) {
  var parser = new Parser(txt);
  return parser.output();
}
var parser_default, NEUTRAL, KEYWORD, NUMBER, QUOTED, AFTERQUOTE, ENDED, whitespace, latin, keyword, endThings, digets;
var init_parser = __esm({
  "node_modules/wkt-parser/parser.js"() {
    parser_default = parseString;
    NEUTRAL = 1;
    KEYWORD = 2;
    NUMBER = 3;
    QUOTED = 4;
    AFTERQUOTE = 5;
    ENDED = -1;
    whitespace = /\s/;
    latin = /[A-Za-z]/;
    keyword = /[A-Za-z84_]/;
    endThings = /[,\]]/;
    digets = /[\d\.E\-\+]/;
    Parser.prototype.readCharicter = function() {
      var char = this.text[this.place++];
      if (this.state !== QUOTED) {
        while (whitespace.test(char)) {
          if (this.place >= this.text.length) {
            return;
          }
          char = this.text[this.place++];
        }
      }
      switch (this.state) {
        case NEUTRAL:
          return this.neutral(char);
        case KEYWORD:
          return this.keyword(char);
        case QUOTED:
          return this.quoted(char);
        case AFTERQUOTE:
          return this.afterquote(char);
        case NUMBER:
          return this.number(char);
        case ENDED:
          return;
      }
    };
    Parser.prototype.afterquote = function(char) {
      if (char === '"') {
        this.word += '"';
        this.state = QUOTED;
        return;
      }
      if (endThings.test(char)) {
        this.word = this.word.trim();
        this.afterItem(char);
        return;
      }
      throw new Error(`havn't handled "` + char + '" in afterquote yet, index ' + this.place);
    };
    Parser.prototype.afterItem = function(char) {
      if (char === ",") {
        if (this.word !== null) {
          this.currentObject.push(this.word);
        }
        this.word = null;
        this.state = NEUTRAL;
        return;
      }
      if (char === "]") {
        this.level--;
        if (this.word !== null) {
          this.currentObject.push(this.word);
          this.word = null;
        }
        this.state = NEUTRAL;
        this.currentObject = this.stack.pop();
        if (!this.currentObject) {
          this.state = ENDED;
        }
        return;
      }
    };
    Parser.prototype.number = function(char) {
      if (digets.test(char)) {
        this.word += char;
        return;
      }
      if (endThings.test(char)) {
        this.word = parseFloat(this.word);
        this.afterItem(char);
        return;
      }
      throw new Error(`havn't handled "` + char + '" in number yet, index ' + this.place);
    };
    Parser.prototype.quoted = function(char) {
      if (char === '"') {
        this.state = AFTERQUOTE;
        return;
      }
      this.word += char;
      return;
    };
    Parser.prototype.keyword = function(char) {
      if (keyword.test(char)) {
        this.word += char;
        return;
      }
      if (char === "[") {
        var newObjects = [];
        newObjects.push(this.word);
        this.level++;
        if (this.root === null) {
          this.root = newObjects;
        } else {
          this.currentObject.push(newObjects);
        }
        this.stack.push(this.currentObject);
        this.currentObject = newObjects;
        this.state = NEUTRAL;
        return;
      }
      if (endThings.test(char)) {
        this.afterItem(char);
        return;
      }
      throw new Error(`havn't handled "` + char + '" in keyword yet, index ' + this.place);
    };
    Parser.prototype.neutral = function(char) {
      if (latin.test(char)) {
        this.word = char;
        this.state = KEYWORD;
        return;
      }
      if (char === '"') {
        this.word = "";
        this.state = QUOTED;
        return;
      }
      if (digets.test(char)) {
        this.word = char;
        this.state = NUMBER;
        return;
      }
      if (endThings.test(char)) {
        this.afterItem(char);
        return;
      }
      throw new Error(`havn't handled "` + char + '" in neutral yet, index ' + this.place);
    };
    Parser.prototype.output = function() {
      while (this.place < this.text.length) {
        this.readCharicter();
      }
      if (this.state === ENDED) {
        return this.root;
      }
      throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
    };
  }
});

// node_modules/wkt-parser/process.js
function mapit(obj2, key, value) {
  if (Array.isArray(key)) {
    value.unshift(key);
    key = null;
  }
  var thing = key ? {} : obj2;
  var out = value.reduce(function(newObj, item) {
    sExpr(item, newObj);
    return newObj;
  }, thing);
  if (key) {
    obj2[key] = out;
  }
}
function sExpr(v, obj2) {
  if (!Array.isArray(v)) {
    obj2[v] = true;
    return;
  }
  var key = v.shift();
  if (key === "PARAMETER") {
    key = v.shift();
  }
  if (v.length === 1) {
    if (Array.isArray(v[0])) {
      obj2[key] = {};
      sExpr(v[0], obj2[key]);
      return;
    }
    obj2[key] = v[0];
    return;
  }
  if (!v.length) {
    obj2[key] = true;
    return;
  }
  if (key === "TOWGS84") {
    obj2[key] = v;
    return;
  }
  if (key === "AXIS") {
    if (!(key in obj2)) {
      obj2[key] = [];
    }
    obj2[key].push(v);
    return;
  }
  if (!Array.isArray(key)) {
    obj2[key] = {};
  }
  var i;
  switch (key) {
    case "UNIT":
    case "PRIMEM":
    case "VERT_DATUM":
      obj2[key] = {
        name: v[0].toLowerCase(),
        convert: v[1]
      };
      if (v.length === 3) {
        sExpr(v[2], obj2[key]);
      }
      return;
    case "SPHEROID":
    case "ELLIPSOID":
      obj2[key] = {
        name: v[0],
        a: v[1],
        rf: v[2]
      };
      if (v.length === 4) {
        sExpr(v[3], obj2[key]);
      }
      return;
    case "PROJECTEDCRS":
    case "PROJCRS":
    case "GEOGCS":
    case "GEOCCS":
    case "PROJCS":
    case "LOCAL_CS":
    case "GEODCRS":
    case "GEODETICCRS":
    case "GEODETICDATUM":
    case "EDATUM":
    case "ENGINEERINGDATUM":
    case "VERT_CS":
    case "VERTCRS":
    case "VERTICALCRS":
    case "COMPD_CS":
    case "COMPOUNDCRS":
    case "ENGINEERINGCRS":
    case "ENGCRS":
    case "FITTED_CS":
    case "LOCAL_DATUM":
    case "DATUM":
      v[0] = ["name", v[0]];
      mapit(obj2, key, v);
      return;
    default:
      i = -1;
      while (++i < v.length) {
        if (!Array.isArray(v[i])) {
          return sExpr(v, obj2[key]);
        }
      }
      return mapit(obj2, key, v);
  }
}
var init_process = __esm({
  "node_modules/wkt-parser/process.js"() {
  }
});

// node_modules/wkt-parser/index.js
function rename(obj2, params2) {
  var outName = params2[0];
  var inName = params2[1];
  if (!(outName in obj2) && inName in obj2) {
    obj2[outName] = obj2[inName];
    if (params2.length === 3) {
      obj2[outName] = params2[2](obj2[outName]);
    }
  }
}
function d2r(input) {
  return input * D2R2;
}
function cleanWKT(wkt) {
  if (wkt.type === "GEOGCS") {
    wkt.projName = "longlat";
  } else if (wkt.type === "LOCAL_CS") {
    wkt.projName = "identity";
    wkt.local = true;
  } else {
    if (typeof wkt.PROJECTION === "object") {
      wkt.projName = Object.keys(wkt.PROJECTION)[0];
    } else {
      wkt.projName = wkt.PROJECTION;
    }
  }
  if (wkt.AXIS) {
    var axisOrder = "";
    for (var i = 0, ii = wkt.AXIS.length; i < ii; ++i) {
      var axis = [wkt.AXIS[i][0].toLowerCase(), wkt.AXIS[i][1].toLowerCase()];
      if (axis[0].indexOf("north") !== -1 || (axis[0] === "y" || axis[0] === "lat") && axis[1] === "north") {
        axisOrder += "n";
      } else if (axis[0].indexOf("south") !== -1 || (axis[0] === "y" || axis[0] === "lat") && axis[1] === "south") {
        axisOrder += "s";
      } else if (axis[0].indexOf("east") !== -1 || (axis[0] === "x" || axis[0] === "lon") && axis[1] === "east") {
        axisOrder += "e";
      } else if (axis[0].indexOf("west") !== -1 || (axis[0] === "x" || axis[0] === "lon") && axis[1] === "west") {
        axisOrder += "w";
      }
    }
    if (axisOrder.length === 2) {
      axisOrder += "u";
    }
    if (axisOrder.length === 3) {
      wkt.axis = axisOrder;
    }
  }
  if (wkt.UNIT) {
    wkt.units = wkt.UNIT.name.toLowerCase();
    if (wkt.units === "metre") {
      wkt.units = "meter";
    }
    if (wkt.UNIT.convert) {
      if (wkt.type === "GEOGCS") {
        if (wkt.DATUM && wkt.DATUM.SPHEROID) {
          wkt.to_meter = wkt.UNIT.convert * wkt.DATUM.SPHEROID.a;
        }
      } else {
        wkt.to_meter = wkt.UNIT.convert;
      }
    }
  }
  var geogcs = wkt.GEOGCS;
  if (wkt.type === "GEOGCS") {
    geogcs = wkt;
  }
  if (geogcs) {
    if (geogcs.DATUM) {
      wkt.datumCode = geogcs.DATUM.name.toLowerCase();
    } else {
      wkt.datumCode = geogcs.name.toLowerCase();
    }
    if (wkt.datumCode.slice(0, 2) === "d_") {
      wkt.datumCode = wkt.datumCode.slice(2);
    }
    if (wkt.datumCode === "new_zealand_geodetic_datum_1949" || wkt.datumCode === "new_zealand_1949") {
      wkt.datumCode = "nzgd49";
    }
    if (wkt.datumCode === "wgs_1984" || wkt.datumCode === "world_geodetic_system_1984") {
      if (wkt.PROJECTION === "Mercator_Auxiliary_Sphere") {
        wkt.sphere = true;
      }
      wkt.datumCode = "wgs84";
    }
    if (wkt.datumCode.slice(-6) === "_ferro") {
      wkt.datumCode = wkt.datumCode.slice(0, -6);
    }
    if (wkt.datumCode.slice(-8) === "_jakarta") {
      wkt.datumCode = wkt.datumCode.slice(0, -8);
    }
    if (~wkt.datumCode.indexOf("belge")) {
      wkt.datumCode = "rnb72";
    }
    if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {
      wkt.ellps = geogcs.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk");
      if (wkt.ellps.toLowerCase().slice(0, 13) === "international") {
        wkt.ellps = "intl";
      }
      wkt.a = geogcs.DATUM.SPHEROID.a;
      wkt.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);
    }
    if (geogcs.DATUM && geogcs.DATUM.TOWGS84) {
      wkt.datum_params = geogcs.DATUM.TOWGS84;
    }
    if (~wkt.datumCode.indexOf("osgb_1936")) {
      wkt.datumCode = "osgb36";
    }
    if (~wkt.datumCode.indexOf("osni_1952")) {
      wkt.datumCode = "osni52";
    }
    if (~wkt.datumCode.indexOf("tm65") || ~wkt.datumCode.indexOf("geodetic_datum_of_1965")) {
      wkt.datumCode = "ire65";
    }
    if (wkt.datumCode === "ch1903+") {
      wkt.datumCode = "ch1903";
    }
    if (~wkt.datumCode.indexOf("israel")) {
      wkt.datumCode = "isr93";
    }
  }
  if (wkt.b && !isFinite(wkt.b)) {
    wkt.b = wkt.a;
  }
  function toMeter(input) {
    var ratio = wkt.to_meter || 1;
    return input * ratio;
  }
  var renamer = function(a) {
    return rename(wkt, a);
  };
  var list = [
    ["standard_parallel_1", "Standard_Parallel_1"],
    ["standard_parallel_1", "Latitude of 1st standard parallel"],
    ["standard_parallel_2", "Standard_Parallel_2"],
    ["standard_parallel_2", "Latitude of 2nd standard parallel"],
    ["false_easting", "False_Easting"],
    ["false_easting", "False easting"],
    ["false-easting", "Easting at false origin"],
    ["false_northing", "False_Northing"],
    ["false_northing", "False northing"],
    ["false_northing", "Northing at false origin"],
    ["central_meridian", "Central_Meridian"],
    ["central_meridian", "Longitude of natural origin"],
    ["central_meridian", "Longitude of false origin"],
    ["latitude_of_origin", "Latitude_Of_Origin"],
    ["latitude_of_origin", "Central_Parallel"],
    ["latitude_of_origin", "Latitude of natural origin"],
    ["latitude_of_origin", "Latitude of false origin"],
    ["scale_factor", "Scale_Factor"],
    ["k0", "scale_factor"],
    ["latitude_of_center", "Latitude_Of_Center"],
    ["latitude_of_center", "Latitude_of_center"],
    ["lat0", "latitude_of_center", d2r],
    ["longitude_of_center", "Longitude_Of_Center"],
    ["longitude_of_center", "Longitude_of_center"],
    ["longc", "longitude_of_center", d2r],
    ["x0", "false_easting", toMeter],
    ["y0", "false_northing", toMeter],
    ["long0", "central_meridian", d2r],
    ["lat0", "latitude_of_origin", d2r],
    ["lat0", "standard_parallel_1", d2r],
    ["lat1", "standard_parallel_1", d2r],
    ["lat2", "standard_parallel_2", d2r],
    ["azimuth", "Azimuth"],
    ["alpha", "azimuth", d2r],
    ["srsCode", "name"]
  ];
  list.forEach(renamer);
  if (!wkt.long0 && wkt.longc && (wkt.projName === "Albers_Conic_Equal_Area" || wkt.projName === "Lambert_Azimuthal_Equal_Area")) {
    wkt.long0 = wkt.longc;
  }
  if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === "Stereographic_South_Pole" || wkt.projName === "Polar Stereographic (variant B)")) {
    wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);
    wkt.lat_ts = wkt.lat1;
  } else if (!wkt.lat_ts && wkt.lat0 && wkt.projName === "Polar_Stereographic") {
    wkt.lat_ts = wkt.lat0;
    wkt.lat0 = d2r(wkt.lat0 > 0 ? 90 : -90);
  }
}
function wkt_parser_default(wkt) {
  var lisp = parser_default(wkt);
  var type = lisp.shift();
  var name = lisp.shift();
  lisp.unshift(["name", name]);
  lisp.unshift(["type", type]);
  var obj2 = {};
  sExpr(lisp, obj2);
  cleanWKT(obj2);
  return obj2;
}
var D2R2;
var init_wkt_parser = __esm({
  "node_modules/wkt-parser/index.js"() {
    init_parser();
    init_process();
    D2R2 = 0.017453292519943295;
  }
});

// node_modules/proj4/lib/defs.js
function defs(name) {
  var that = this;
  if (arguments.length === 2) {
    var def = arguments[1];
    if (typeof def === "string") {
      if (def.charAt(0) === "+") {
        defs[name] = projString_default(arguments[1]);
      } else {
        defs[name] = wkt_parser_default(arguments[1]);
      }
    } else {
      defs[name] = def;
    }
  } else if (arguments.length === 1) {
    if (Array.isArray(name)) {
      return name.map(function(v) {
        if (Array.isArray(v)) {
          defs.apply(that, v);
        } else {
          defs(v);
        }
      });
    } else if (typeof name === "string") {
      if (name in defs) {
        return defs[name];
      }
    } else if ("EPSG" in name) {
      defs["EPSG:" + name.EPSG] = name;
    } else if ("ESRI" in name) {
      defs["ESRI:" + name.ESRI] = name;
    } else if ("IAU2000" in name) {
      defs["IAU2000:" + name.IAU2000] = name;
    } else {
      console.log(name);
    }
    return;
  }
}
var defs_default;
var init_defs = __esm({
  "node_modules/proj4/lib/defs.js"() {
    init_global();
    init_projString();
    init_wkt_parser();
    global_default(defs);
    defs_default = defs;
  }
});

// node_modules/proj4/lib/parseCode.js
function testObj(code) {
  return typeof code === "string";
}
function testDef(code) {
  return code in defs_default;
}
function testWKT(code) {
  return codeWords.some(function(word) {
    return code.indexOf(word) > -1;
  });
}
function checkMercator(item) {
  var auth = match(item, "authority");
  if (!auth) {
    return;
  }
  var code = match(auth, "epsg");
  return code && codes.indexOf(code) > -1;
}
function checkProjStr(item) {
  var ext = match(item, "extension");
  if (!ext) {
    return;
  }
  return match(ext, "proj4");
}
function testProj(code) {
  return code[0] === "+";
}
function parse(code) {
  if (testObj(code)) {
    if (testDef(code)) {
      return defs_default[code];
    }
    if (testWKT(code)) {
      var out = wkt_parser_default(code);
      if (checkMercator(out)) {
        return defs_default["EPSG:3857"];
      }
      var maybeProjStr = checkProjStr(out);
      if (maybeProjStr) {
        return projString_default(maybeProjStr);
      }
      return out;
    }
    if (testProj(code)) {
      return projString_default(code);
    }
  } else {
    return code;
  }
}
var codeWords, codes, parseCode_default;
var init_parseCode = __esm({
  "node_modules/proj4/lib/parseCode.js"() {
    init_defs();
    init_wkt_parser();
    init_projString();
    init_match();
    codeWords = ["PROJECTEDCRS", "PROJCRS", "GEOGCS", "GEOCCS", "PROJCS", "LOCAL_CS", "GEODCRS", "GEODETICCRS", "GEODETICDATUM", "ENGCRS", "ENGINEERINGCRS"];
    codes = ["3857", "900913", "3785", "102113"];
    parseCode_default = parse;
  }
});

// node_modules/proj4/lib/extend.js
function extend_default(destination, source) {
  destination = destination || {};
  var value, property;
  if (!source) {
    return destination;
  }
  for (property in source) {
    value = source[property];
    if (value !== void 0) {
      destination[property] = value;
    }
  }
  return destination;
}
var init_extend = __esm({
  "node_modules/proj4/lib/extend.js"() {
  }
});

// node_modules/proj4/lib/common/msfnz.js
function msfnz_default(eccent, sinphi, cosphi) {
  var con = eccent * sinphi;
  return cosphi / Math.sqrt(1 - con * con);
}
var init_msfnz = __esm({
  "node_modules/proj4/lib/common/msfnz.js"() {
  }
});

// node_modules/proj4/lib/common/sign.js
function sign_default(x) {
  return x < 0 ? -1 : 1;
}
var init_sign = __esm({
  "node_modules/proj4/lib/common/sign.js"() {
  }
});

// node_modules/proj4/lib/common/adjust_lon.js
function adjust_lon_default(x) {
  return Math.abs(x) <= SPI ? x : x - sign_default(x) * TWO_PI;
}
var init_adjust_lon = __esm({
  "node_modules/proj4/lib/common/adjust_lon.js"() {
    init_values();
    init_sign();
  }
});

// node_modules/proj4/lib/common/tsfnz.js
function tsfnz_default(eccent, phi, sinphi) {
  var con = eccent * sinphi;
  var com = 0.5 * eccent;
  con = Math.pow((1 - con) / (1 + con), com);
  return Math.tan(0.5 * (HALF_PI - phi)) / con;
}
var init_tsfnz = __esm({
  "node_modules/proj4/lib/common/tsfnz.js"() {
    init_values();
  }
});

// node_modules/proj4/lib/common/phi2z.js
function phi2z_default(eccent, ts) {
  var eccnth = 0.5 * eccent;
  var con, dphi;
  var phi = HALF_PI - 2 * Math.atan(ts);
  for (var i = 0; i <= 15; i++) {
    con = eccent * Math.sin(phi);
    dphi = HALF_PI - 2 * Math.atan(ts * Math.pow((1 - con) / (1 + con), eccnth)) - phi;
    phi += dphi;
    if (Math.abs(dphi) <= 1e-10) {
      return phi;
    }
  }
  return -9999;
}
var init_phi2z = __esm({
  "node_modules/proj4/lib/common/phi2z.js"() {
    init_values();
  }
});

// node_modules/proj4/lib/projections/merc.js
function init() {
  var con = this.b / this.a;
  this.es = 1 - con * con;
  if (!("x0" in this)) {
    this.x0 = 0;
  }
  if (!("y0" in this)) {
    this.y0 = 0;
  }
  this.e = Math.sqrt(this.es);
  if (this.lat_ts) {
    if (this.sphere) {
      this.k0 = Math.cos(this.lat_ts);
    } else {
      this.k0 = msfnz_default(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
    }
  } else {
    if (!this.k0) {
      if (this.k) {
        this.k0 = this.k;
      } else {
        this.k0 = 1;
      }
    }
  }
}
function forward(p) {
  var lon = p.x;
  var lat = p.y;
  if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {
    return null;
  }
  var x, y;
  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
    return null;
  } else {
    if (this.sphere) {
      x = this.x0 + this.a * this.k0 * adjust_lon_default(lon - this.long0);
      y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));
    } else {
      var sinphi = Math.sin(lat);
      var ts = tsfnz_default(this.e, lat, sinphi);
      x = this.x0 + this.a * this.k0 * adjust_lon_default(lon - this.long0);
      y = this.y0 - this.a * this.k0 * Math.log(ts);
    }
    p.x = x;
    p.y = y;
    return p;
  }
}
function inverse(p) {
  var x = p.x - this.x0;
  var y = p.y - this.y0;
  var lon, lat;
  if (this.sphere) {
    lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));
  } else {
    var ts = Math.exp(-y / (this.a * this.k0));
    lat = phi2z_default(this.e, ts);
    if (lat === -9999) {
      return null;
    }
  }
  lon = adjust_lon_default(this.long0 + x / (this.a * this.k0));
  p.x = lon;
  p.y = lat;
  return p;
}
var names, merc_default;
var init_merc = __esm({
  "node_modules/proj4/lib/projections/merc.js"() {
    init_msfnz();
    init_adjust_lon();
    init_tsfnz();
    init_phi2z();
    init_values();
    names = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
    merc_default = {
      init,
      forward,
      inverse,
      names
    };
  }
});

// node_modules/proj4/lib/projections/longlat.js
function init2() {
}
function identity(pt) {
  return pt;
}
var names2, longlat_default;
var init_longlat = __esm({
  "node_modules/proj4/lib/projections/longlat.js"() {
    names2 = ["longlat", "identity"];
    longlat_default = {
      init: init2,
      forward: identity,
      inverse: identity,
      names: names2
    };
  }
});

// node_modules/proj4/lib/projections.js
function add(proj, i) {
  var len = projStore.length;
  if (!proj.names) {
    console.log(i);
    return true;
  }
  projStore[len] = proj;
  proj.names.forEach(function(n) {
    names3[n.toLowerCase()] = len;
  });
  return this;
}
function get(name) {
  if (!name) {
    return false;
  }
  var n = name.toLowerCase();
  if (typeof names3[n] !== "undefined" && projStore[names3[n]]) {
    return projStore[names3[n]];
  }
}
function start() {
  projs.forEach(add);
}
var projs, names3, projStore, projections_default;
var init_projections = __esm({
  "node_modules/proj4/lib/projections.js"() {
    init_merc();
    init_longlat();
    projs = [merc_default, longlat_default];
    names3 = {};
    projStore = [];
    projections_default = {
      start,
      add,
      get
    };
  }
});

// node_modules/proj4/lib/constants/Ellipsoid.js
var exports2, WGS84;
var init_Ellipsoid = __esm({
  "node_modules/proj4/lib/constants/Ellipsoid.js"() {
    exports2 = {};
    exports2.MERIT = {
      a: 6378137,
      rf: 298.257,
      ellipseName: "MERIT 1983"
    };
    exports2.SGS85 = {
      a: 6378136,
      rf: 298.257,
      ellipseName: "Soviet Geodetic System 85"
    };
    exports2.GRS80 = {
      a: 6378137,
      rf: 298.257222101,
      ellipseName: "GRS 1980(IUGG, 1980)"
    };
    exports2.IAU76 = {
      a: 6378140,
      rf: 298.257,
      ellipseName: "IAU 1976"
    };
    exports2.airy = {
      a: 6377563396e-3,
      b: 635625691e-2,
      ellipseName: "Airy 1830"
    };
    exports2.APL4 = {
      a: 6378137,
      rf: 298.25,
      ellipseName: "Appl. Physics. 1965"
    };
    exports2.NWL9D = {
      a: 6378145,
      rf: 298.25,
      ellipseName: "Naval Weapons Lab., 1965"
    };
    exports2.mod_airy = {
      a: 6377340189e-3,
      b: 6356034446e-3,
      ellipseName: "Modified Airy"
    };
    exports2.andrae = {
      a: 637710443e-2,
      rf: 300,
      ellipseName: "Andrae 1876 (Den., Iclnd.)"
    };
    exports2.aust_SA = {
      a: 6378160,
      rf: 298.25,
      ellipseName: "Australian Natl & S. Amer. 1969"
    };
    exports2.GRS67 = {
      a: 6378160,
      rf: 298.247167427,
      ellipseName: "GRS 67(IUGG 1967)"
    };
    exports2.bessel = {
      a: 6377397155e-3,
      rf: 299.1528128,
      ellipseName: "Bessel 1841"
    };
    exports2.bess_nam = {
      a: 6377483865e-3,
      rf: 299.1528128,
      ellipseName: "Bessel 1841 (Namibia)"
    };
    exports2.clrk66 = {
      a: 63782064e-1,
      b: 63565838e-1,
      ellipseName: "Clarke 1866"
    };
    exports2.clrk80 = {
      a: 6378249145e-3,
      rf: 293.4663,
      ellipseName: "Clarke 1880 mod."
    };
    exports2.clrk80ign = {
      a: 63782492e-1,
      b: 6356515,
      rf: 293.4660213,
      ellipseName: "Clarke 1880 (IGN)"
    };
    exports2.clrk58 = {
      a: 6378293645208759e-9,
      rf: 294.2606763692654,
      ellipseName: "Clarke 1858"
    };
    exports2.CPM = {
      a: 63757387e-1,
      rf: 334.29,
      ellipseName: "Comm. des Poids et Mesures 1799"
    };
    exports2.delmbr = {
      a: 6376428,
      rf: 311.5,
      ellipseName: "Delambre 1810 (Belgium)"
    };
    exports2.engelis = {
      a: 637813605e-2,
      rf: 298.2566,
      ellipseName: "Engelis 1985"
    };
    exports2.evrst30 = {
      a: 6377276345e-3,
      rf: 300.8017,
      ellipseName: "Everest 1830"
    };
    exports2.evrst48 = {
      a: 6377304063e-3,
      rf: 300.8017,
      ellipseName: "Everest 1948"
    };
    exports2.evrst56 = {
      a: 6377301243e-3,
      rf: 300.8017,
      ellipseName: "Everest 1956"
    };
    exports2.evrst69 = {
      a: 6377295664e-3,
      rf: 300.8017,
      ellipseName: "Everest 1969"
    };
    exports2.evrstSS = {
      a: 6377298556e-3,
      rf: 300.8017,
      ellipseName: "Everest (Sabah & Sarawak)"
    };
    exports2.fschr60 = {
      a: 6378166,
      rf: 298.3,
      ellipseName: "Fischer (Mercury Datum) 1960"
    };
    exports2.fschr60m = {
      a: 6378155,
      rf: 298.3,
      ellipseName: "Fischer 1960"
    };
    exports2.fschr68 = {
      a: 6378150,
      rf: 298.3,
      ellipseName: "Fischer 1968"
    };
    exports2.helmert = {
      a: 6378200,
      rf: 298.3,
      ellipseName: "Helmert 1906"
    };
    exports2.hough = {
      a: 6378270,
      rf: 297,
      ellipseName: "Hough"
    };
    exports2.intl = {
      a: 6378388,
      rf: 297,
      ellipseName: "International 1909 (Hayford)"
    };
    exports2.kaula = {
      a: 6378163,
      rf: 298.24,
      ellipseName: "Kaula 1961"
    };
    exports2.lerch = {
      a: 6378139,
      rf: 298.257,
      ellipseName: "Lerch 1979"
    };
    exports2.mprts = {
      a: 6397300,
      rf: 191,
      ellipseName: "Maupertius 1738"
    };
    exports2.new_intl = {
      a: 63781575e-1,
      b: 63567722e-1,
      ellipseName: "New International 1967"
    };
    exports2.plessis = {
      a: 6376523,
      rf: 6355863,
      ellipseName: "Plessis 1817 (France)"
    };
    exports2.krass = {
      a: 6378245,
      rf: 298.3,
      ellipseName: "Krassovsky, 1942"
    };
    exports2.SEasia = {
      a: 6378155,
      b: 63567733205e-4,
      ellipseName: "Southeast Asia"
    };
    exports2.walbeck = {
      a: 6376896,
      b: 63558348467e-4,
      ellipseName: "Walbeck"
    };
    exports2.WGS60 = {
      a: 6378165,
      rf: 298.3,
      ellipseName: "WGS 60"
    };
    exports2.WGS66 = {
      a: 6378145,
      rf: 298.25,
      ellipseName: "WGS 66"
    };
    exports2.WGS7 = {
      a: 6378135,
      rf: 298.26,
      ellipseName: "WGS 72"
    };
    WGS84 = exports2.WGS84 = {
      a: 6378137,
      rf: 298.257223563,
      ellipseName: "WGS 84"
    };
    exports2.sphere = {
      a: 6370997,
      b: 6370997,
      ellipseName: "Normal Sphere (r=6370997)"
    };
  }
});

// node_modules/proj4/lib/deriveConstants.js
function eccentricity(a, b, rf, R_A) {
  var a2 = a * a;
  var b2 = b * b;
  var es = (a2 - b2) / a2;
  var e = 0;
  if (R_A) {
    a *= 1 - es * (SIXTH + es * (RA4 + es * RA6));
    a2 = a * a;
    es = 0;
  } else {
    e = Math.sqrt(es);
  }
  var ep2 = (a2 - b2) / b2;
  return {
    es,
    e,
    ep2
  };
}
function sphere(a, b, rf, ellps, sphere2) {
  if (!a) {
    var ellipse = match(exports2, ellps);
    if (!ellipse) {
      ellipse = WGS84;
    }
    a = ellipse.a;
    b = ellipse.b;
    rf = ellipse.rf;
  }
  if (rf && !b) {
    b = (1 - 1 / rf) * a;
  }
  if (rf === 0 || Math.abs(a - b) < EPSLN) {
    sphere2 = true;
    b = a;
  }
  return {
    a,
    b,
    rf,
    sphere: sphere2
  };
}
var init_deriveConstants = __esm({
  "node_modules/proj4/lib/deriveConstants.js"() {
    init_values();
    init_Ellipsoid();
    init_match();
  }
});

// node_modules/proj4/lib/constants/Datum.js
var exports3;
var init_Datum = __esm({
  "node_modules/proj4/lib/constants/Datum.js"() {
    exports3 = {};
    exports3.wgs84 = {
      towgs84: "0,0,0",
      ellipse: "WGS84",
      datumName: "WGS84"
    };
    exports3.ch1903 = {
      towgs84: "674.374,15.056,405.346",
      ellipse: "bessel",
      datumName: "swiss"
    };
    exports3.ggrs87 = {
      towgs84: "-199.87,74.79,246.62",
      ellipse: "GRS80",
      datumName: "Greek_Geodetic_Reference_System_1987"
    };
    exports3.nad83 = {
      towgs84: "0,0,0",
      ellipse: "GRS80",
      datumName: "North_American_Datum_1983"
    };
    exports3.nad27 = {
      nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
      ellipse: "clrk66",
      datumName: "North_American_Datum_1927"
    };
    exports3.potsdam = {
      towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
      ellipse: "bessel",
      datumName: "Potsdam Rauenberg 1950 DHDN"
    };
    exports3.carthage = {
      towgs84: "-263.0,6.0,431.0",
      ellipse: "clark80",
      datumName: "Carthage 1934 Tunisia"
    };
    exports3.hermannskogel = {
      towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
      ellipse: "bessel",
      datumName: "Hermannskogel"
    };
    exports3.osni52 = {
      towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
      ellipse: "airy",
      datumName: "Irish National"
    };
    exports3.ire65 = {
      towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
      ellipse: "mod_airy",
      datumName: "Ireland 1965"
    };
    exports3.rassadiran = {
      towgs84: "-133.63,-157.5,-158.62",
      ellipse: "intl",
      datumName: "Rassadiran"
    };
    exports3.nzgd49 = {
      towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
      ellipse: "intl",
      datumName: "New Zealand Geodetic Datum 1949"
    };
    exports3.osgb36 = {
      towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
      ellipse: "airy",
      datumName: "Airy 1830"
    };
    exports3.s_jtsk = {
      towgs84: "589,76,480",
      ellipse: "bessel",
      datumName: "S-JTSK (Ferro)"
    };
    exports3.beduaram = {
      towgs84: "-106,-87,188",
      ellipse: "clrk80",
      datumName: "Beduaram"
    };
    exports3.gunung_segara = {
      towgs84: "-403,684,41",
      ellipse: "bessel",
      datumName: "Gunung Segara Jakarta"
    };
    exports3.rnb72 = {
      towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
      ellipse: "intl",
      datumName: "Reseau National Belge 1972"
    };
  }
});

// node_modules/proj4/lib/datum.js
function datum(datumCode, datum_params, a, b, es, ep2, nadgrids) {
  var out = {};
  if (datumCode === void 0 || datumCode === "none") {
    out.datum_type = PJD_NODATUM;
  } else {
    out.datum_type = PJD_WGS84;
  }
  if (datum_params) {
    out.datum_params = datum_params.map(parseFloat);
    if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {
      out.datum_type = PJD_3PARAM;
    }
    if (out.datum_params.length > 3) {
      if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {
        out.datum_type = PJD_7PARAM;
        out.datum_params[3] *= SEC_TO_RAD;
        out.datum_params[4] *= SEC_TO_RAD;
        out.datum_params[5] *= SEC_TO_RAD;
        out.datum_params[6] = out.datum_params[6] / 1e6 + 1;
      }
    }
  }
  if (nadgrids) {
    out.datum_type = PJD_GRIDSHIFT;
    out.grids = nadgrids;
  }
  out.a = a;
  out.b = b;
  out.es = es;
  out.ep2 = ep2;
  return out;
}
var datum_default;
var init_datum = __esm({
  "node_modules/proj4/lib/datum.js"() {
    init_values();
    datum_default = datum;
  }
});

// node_modules/proj4/lib/nadgrid.js
function nadgrid(key, data) {
  var view = new DataView(data);
  var isLittleEndian = detectLittleEndian(view);
  var header = readHeader(view, isLittleEndian);
  if (header.nSubgrids > 1) {
    console.log("Only single NTv2 subgrids are currently supported, subsequent sub grids are ignored");
  }
  var subgrids = readSubgrids(view, header, isLittleEndian);
  var nadgrid2 = { header, subgrids };
  loadedNadgrids[key] = nadgrid2;
  return nadgrid2;
}
function getNadgrids(nadgrids) {
  if (nadgrids === void 0) {
    return null;
  }
  var grids = nadgrids.split(",");
  return grids.map(parseNadgridString);
}
function parseNadgridString(value) {
  if (value.length === 0) {
    return null;
  }
  var optional = value[0] === "@";
  if (optional) {
    value = value.slice(1);
  }
  if (value === "null") {
    return { name: "null", mandatory: !optional, grid: null, isNull: true };
  }
  return {
    name: value,
    mandatory: !optional,
    grid: loadedNadgrids[value] || null,
    isNull: false
  };
}
function secondsToRadians(seconds) {
  return seconds / 3600 * Math.PI / 180;
}
function detectLittleEndian(view) {
  var nFields = view.getInt32(8, false);
  if (nFields === 11) {
    return false;
  }
  nFields = view.getInt32(8, true);
  if (nFields !== 11) {
    console.warn("Failed to detect nadgrid endian-ness, defaulting to little-endian");
  }
  return true;
}
function readHeader(view, isLittleEndian) {
  return {
    nFields: view.getInt32(8, isLittleEndian),
    nSubgridFields: view.getInt32(24, isLittleEndian),
    nSubgrids: view.getInt32(40, isLittleEndian),
    shiftType: decodeString(view, 56, 56 + 8).trim(),
    fromSemiMajorAxis: view.getFloat64(120, isLittleEndian),
    fromSemiMinorAxis: view.getFloat64(136, isLittleEndian),
    toSemiMajorAxis: view.getFloat64(152, isLittleEndian),
    toSemiMinorAxis: view.getFloat64(168, isLittleEndian)
  };
}
function decodeString(view, start2, end) {
  return String.fromCharCode.apply(null, new Uint8Array(view.buffer.slice(start2, end)));
}
function readSubgrids(view, header, isLittleEndian) {
  var gridOffset = 176;
  var grids = [];
  for (var i = 0; i < header.nSubgrids; i++) {
    var subHeader = readGridHeader(view, gridOffset, isLittleEndian);
    var nodes = readGridNodes(view, gridOffset, subHeader, isLittleEndian);
    var lngColumnCount = Math.round(
      1 + (subHeader.upperLongitude - subHeader.lowerLongitude) / subHeader.longitudeInterval
    );
    var latColumnCount = Math.round(
      1 + (subHeader.upperLatitude - subHeader.lowerLatitude) / subHeader.latitudeInterval
    );
    grids.push({
      ll: [secondsToRadians(subHeader.lowerLongitude), secondsToRadians(subHeader.lowerLatitude)],
      del: [secondsToRadians(subHeader.longitudeInterval), secondsToRadians(subHeader.latitudeInterval)],
      lim: [lngColumnCount, latColumnCount],
      count: subHeader.gridNodeCount,
      cvs: mapNodes(nodes)
    });
  }
  return grids;
}
function mapNodes(nodes) {
  return nodes.map(function(r) {
    return [secondsToRadians(r.longitudeShift), secondsToRadians(r.latitudeShift)];
  });
}
function readGridHeader(view, offset, isLittleEndian) {
  return {
    name: decodeString(view, offset + 8, offset + 16).trim(),
    parent: decodeString(view, offset + 24, offset + 24 + 8).trim(),
    lowerLatitude: view.getFloat64(offset + 72, isLittleEndian),
    upperLatitude: view.getFloat64(offset + 88, isLittleEndian),
    lowerLongitude: view.getFloat64(offset + 104, isLittleEndian),
    upperLongitude: view.getFloat64(offset + 120, isLittleEndian),
    latitudeInterval: view.getFloat64(offset + 136, isLittleEndian),
    longitudeInterval: view.getFloat64(offset + 152, isLittleEndian),
    gridNodeCount: view.getInt32(offset + 168, isLittleEndian)
  };
}
function readGridNodes(view, offset, gridHeader, isLittleEndian) {
  var nodesOffset = offset + 176;
  var gridRecordLength = 16;
  var gridShiftRecords = [];
  for (var i = 0; i < gridHeader.gridNodeCount; i++) {
    var record = {
      latitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength, isLittleEndian),
      longitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength + 4, isLittleEndian),
      latitudeAccuracy: view.getFloat32(nodesOffset + i * gridRecordLength + 8, isLittleEndian),
      longitudeAccuracy: view.getFloat32(nodesOffset + i * gridRecordLength + 12, isLittleEndian)
    };
    gridShiftRecords.push(record);
  }
  return gridShiftRecords;
}
var loadedNadgrids;
var init_nadgrid = __esm({
  "node_modules/proj4/lib/nadgrid.js"() {
    loadedNadgrids = {};
  }
});

// node_modules/proj4/lib/Proj.js
function Projection(srsCode, callback) {
  if (!(this instanceof Projection)) {
    return new Projection(srsCode);
  }
  callback = callback || function(error) {
    if (error) {
      throw error;
    }
  };
  var json = parseCode_default(srsCode);
  if (typeof json !== "object") {
    callback(srsCode);
    return;
  }
  var ourProj = Projection.projections.get(json.projName);
  if (!ourProj) {
    callback(srsCode);
    return;
  }
  if (json.datumCode && json.datumCode !== "none") {
    var datumDef = match(exports3, json.datumCode);
    if (datumDef) {
      json.datum_params = json.datum_params || (datumDef.towgs84 ? datumDef.towgs84.split(",") : null);
      json.ellps = datumDef.ellipse;
      json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;
    }
  }
  json.k0 = json.k0 || 1;
  json.axis = json.axis || "enu";
  json.ellps = json.ellps || "wgs84";
  json.lat1 = json.lat1 || json.lat0;
  var sphere_ = sphere(json.a, json.b, json.rf, json.ellps, json.sphere);
  var ecc = eccentricity(sphere_.a, sphere_.b, sphere_.rf, json.R_A);
  var nadgrids = getNadgrids(json.nadgrids);
  var datumObj = json.datum || datum_default(
    json.datumCode,
    json.datum_params,
    sphere_.a,
    sphere_.b,
    ecc.es,
    ecc.ep2,
    nadgrids
  );
  extend_default(this, json);
  extend_default(this, ourProj);
  this.a = sphere_.a;
  this.b = sphere_.b;
  this.rf = sphere_.rf;
  this.sphere = sphere_.sphere;
  this.es = ecc.es;
  this.e = ecc.e;
  this.ep2 = ecc.ep2;
  this.datum = datumObj;
  this.init();
  callback(null, this);
}
var Proj_default;
var init_Proj = __esm({
  "node_modules/proj4/lib/Proj.js"() {
    init_parseCode();
    init_extend();
    init_projections();
    init_deriveConstants();
    init_Datum();
    init_datum();
    init_match();
    init_nadgrid();
    Projection.projections = projections_default;
    Projection.projections.start();
    Proj_default = Projection;
  }
});

// node_modules/proj4/lib/datumUtils.js
function compareDatums(source, dest) {
  if (source.datum_type !== dest.datum_type) {
    return false;
  } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 5e-11) {
    return false;
  } else if (source.datum_type === PJD_3PARAM) {
    return source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2];
  } else if (source.datum_type === PJD_7PARAM) {
    return source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6];
  } else {
    return true;
  }
}
function geodeticToGeocentric(p, es, a) {
  var Longitude = p.x;
  var Latitude = p.y;
  var Height = p.z ? p.z : 0;
  var Rn;
  var Sin_Lat;
  var Sin2_Lat;
  var Cos_Lat;
  if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {
    Latitude = -HALF_PI;
  } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {
    Latitude = HALF_PI;
  } else if (Latitude < -HALF_PI) {
    return { x: -Infinity, y: -Infinity, z: p.z };
  } else if (Latitude > HALF_PI) {
    return { x: Infinity, y: Infinity, z: p.z };
  }
  if (Longitude > Math.PI) {
    Longitude -= 2 * Math.PI;
  }
  Sin_Lat = Math.sin(Latitude);
  Cos_Lat = Math.cos(Latitude);
  Sin2_Lat = Sin_Lat * Sin_Lat;
  Rn = a / Math.sqrt(1 - es * Sin2_Lat);
  return {
    x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),
    y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),
    z: (Rn * (1 - es) + Height) * Sin_Lat
  };
}
function geocentricToGeodetic(p, es, a, b) {
  var genau = 1e-12;
  var genau2 = genau * genau;
  var maxiter = 30;
  var P;
  var RR;
  var CT;
  var ST;
  var RX;
  var RK;
  var RN;
  var CPHI0;
  var SPHI0;
  var CPHI;
  var SPHI;
  var SDPHI;
  var iter;
  var X = p.x;
  var Y = p.y;
  var Z2 = p.z ? p.z : 0;
  var Longitude;
  var Latitude;
  var Height;
  P = Math.sqrt(X * X + Y * Y);
  RR = Math.sqrt(X * X + Y * Y + Z2 * Z2);
  if (P / a < genau) {
    Longitude = 0;
    if (RR / a < genau) {
      Latitude = HALF_PI;
      Height = -b;
      return {
        x: p.x,
        y: p.y,
        z: p.z
      };
    }
  } else {
    Longitude = Math.atan2(Y, X);
  }
  CT = Z2 / RR;
  ST = P / RR;
  RX = 1 / Math.sqrt(1 - es * (2 - es) * ST * ST);
  CPHI0 = ST * (1 - es) * RX;
  SPHI0 = CT * RX;
  iter = 0;
  do {
    iter++;
    RN = a / Math.sqrt(1 - es * SPHI0 * SPHI0);
    Height = P * CPHI0 + Z2 * SPHI0 - RN * (1 - es * SPHI0 * SPHI0);
    RK = es * RN / (RN + Height);
    RX = 1 / Math.sqrt(1 - RK * (2 - RK) * ST * ST);
    CPHI = ST * (1 - RK) * RX;
    SPHI = CT * RX;
    SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
    CPHI0 = CPHI;
    SPHI0 = SPHI;
  } while (SDPHI * SDPHI > genau2 && iter < maxiter);
  Latitude = Math.atan(SPHI / Math.abs(CPHI));
  return {
    x: Longitude,
    y: Latitude,
    z: Height
  };
}
function geocentricToWgs84(p, datum_type, datum_params) {
  if (datum_type === PJD_3PARAM) {
    return {
      x: p.x + datum_params[0],
      y: p.y + datum_params[1],
      z: p.z + datum_params[2]
    };
  } else if (datum_type === PJD_7PARAM) {
    var Dx_BF = datum_params[0];
    var Dy_BF = datum_params[1];
    var Dz_BF = datum_params[2];
    var Rx_BF = datum_params[3];
    var Ry_BF = datum_params[4];
    var Rz_BF = datum_params[5];
    var M_BF = datum_params[6];
    return {
      x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,
      y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,
      z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF
    };
  }
}
function geocentricFromWgs84(p, datum_type, datum_params) {
  if (datum_type === PJD_3PARAM) {
    return {
      x: p.x - datum_params[0],
      y: p.y - datum_params[1],
      z: p.z - datum_params[2]
    };
  } else if (datum_type === PJD_7PARAM) {
    var Dx_BF = datum_params[0];
    var Dy_BF = datum_params[1];
    var Dz_BF = datum_params[2];
    var Rx_BF = datum_params[3];
    var Ry_BF = datum_params[4];
    var Rz_BF = datum_params[5];
    var M_BF = datum_params[6];
    var x_tmp = (p.x - Dx_BF) / M_BF;
    var y_tmp = (p.y - Dy_BF) / M_BF;
    var z_tmp = (p.z - Dz_BF) / M_BF;
    return {
      x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,
      y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,
      z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp
    };
  }
}
var init_datumUtils = __esm({
  "node_modules/proj4/lib/datumUtils.js"() {
    "use strict";
    init_values();
  }
});

// node_modules/proj4/lib/datum_transform.js
function checkParams(type) {
  return type === PJD_3PARAM || type === PJD_7PARAM;
}
function datum_transform_default(source, dest, point3) {
  if (compareDatums(source, dest)) {
    return point3;
  }
  if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {
    return point3;
  }
  var source_a = source.a;
  var source_es = source.es;
  if (source.datum_type === PJD_GRIDSHIFT) {
    var gridShiftCode = applyGridShift(source, false, point3);
    if (gridShiftCode !== 0) {
      return void 0;
    }
    source_a = SRS_WGS84_SEMIMAJOR;
    source_es = SRS_WGS84_ESQUARED;
  }
  var dest_a = dest.a;
  var dest_b = dest.b;
  var dest_es = dest.es;
  if (dest.datum_type === PJD_GRIDSHIFT) {
    dest_a = SRS_WGS84_SEMIMAJOR;
    dest_b = SRS_WGS84_SEMIMINOR;
    dest_es = SRS_WGS84_ESQUARED;
  }
  if (source_es === dest_es && source_a === dest_a && !checkParams(source.datum_type) && !checkParams(dest.datum_type)) {
    return point3;
  }
  point3 = geodeticToGeocentric(point3, source_es, source_a);
  if (checkParams(source.datum_type)) {
    point3 = geocentricToWgs84(point3, source.datum_type, source.datum_params);
  }
  if (checkParams(dest.datum_type)) {
    point3 = geocentricFromWgs84(point3, dest.datum_type, dest.datum_params);
  }
  point3 = geocentricToGeodetic(point3, dest_es, dest_a, dest_b);
  if (dest.datum_type === PJD_GRIDSHIFT) {
    var destGridShiftResult = applyGridShift(dest, true, point3);
    if (destGridShiftResult !== 0) {
      return void 0;
    }
  }
  return point3;
}
function applyGridShift(source, inverse32, point3) {
  if (source.grids === null || source.grids.length === 0) {
    console.log("Grid shift grids not found");
    return -1;
  }
  var input = { x: -point3.x, y: point3.y };
  var output = { x: Number.NaN, y: Number.NaN };
  var onlyMandatoryGrids = false;
  var attemptedGrids = [];
  for (var i = 0; i < source.grids.length; i++) {
    var grid = source.grids[i];
    attemptedGrids.push(grid.name);
    if (grid.isNull) {
      output = input;
      break;
    }
    onlyMandatoryGrids = grid.mandatory;
    if (grid.grid === null) {
      if (grid.mandatory) {
        console.log("Unable to find mandatory grid '" + grid.name + "'");
        return -1;
      }
      continue;
    }
    var subgrid = grid.grid.subgrids[0];
    var epsilon = (Math.abs(subgrid.del[1]) + Math.abs(subgrid.del[0])) / 1e4;
    var minX = subgrid.ll[0] - epsilon;
    var minY = subgrid.ll[1] - epsilon;
    var maxX = subgrid.ll[0] + (subgrid.lim[0] - 1) * subgrid.del[0] + epsilon;
    var maxY = subgrid.ll[1] + (subgrid.lim[1] - 1) * subgrid.del[1] + epsilon;
    if (minY > input.y || minX > input.x || maxY < input.y || maxX < input.x) {
      continue;
    }
    output = applySubgridShift(input, inverse32, subgrid);
    if (!isNaN(output.x)) {
      break;
    }
  }
  if (isNaN(output.x)) {
    console.log("Failed to find a grid shift table for location '" + -input.x * R2D + " " + input.y * R2D + " tried: '" + attemptedGrids + "'");
    return -1;
  }
  point3.x = -output.x;
  point3.y = output.y;
  return 0;
}
function applySubgridShift(pin, inverse32, ct) {
  var val = { x: Number.NaN, y: Number.NaN };
  if (isNaN(pin.x)) {
    return val;
  }
  var tb = { x: pin.x, y: pin.y };
  tb.x -= ct.ll[0];
  tb.y -= ct.ll[1];
  tb.x = adjust_lon_default(tb.x - Math.PI) + Math.PI;
  var t = nadInterpolate(tb, ct);
  if (inverse32) {
    if (isNaN(t.x)) {
      return val;
    }
    t.x = tb.x - t.x;
    t.y = tb.y - t.y;
    var i = 9, tol = 1e-12;
    var dif, del;
    do {
      del = nadInterpolate(t, ct);
      if (isNaN(del.x)) {
        console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
        break;
      }
      dif = { x: tb.x - (del.x + t.x), y: tb.y - (del.y + t.y) };
      t.x += dif.x;
      t.y += dif.y;
    } while (i-- && Math.abs(dif.x) > tol && Math.abs(dif.y) > tol);
    if (i < 0) {
      console.log("Inverse grid shift iterator failed to converge.");
      return val;
    }
    val.x = adjust_lon_default(t.x + ct.ll[0]);
    val.y = t.y + ct.ll[1];
  } else {
    if (!isNaN(t.x)) {
      val.x = pin.x + t.x;
      val.y = pin.y + t.y;
    }
  }
  return val;
}
function nadInterpolate(pin, ct) {
  var t = { x: pin.x / ct.del[0], y: pin.y / ct.del[1] };
  var indx = { x: Math.floor(t.x), y: Math.floor(t.y) };
  var frct = { x: t.x - 1 * indx.x, y: t.y - 1 * indx.y };
  var val = { x: Number.NaN, y: Number.NaN };
  var inx;
  if (indx.x < 0 || indx.x >= ct.lim[0]) {
    return val;
  }
  if (indx.y < 0 || indx.y >= ct.lim[1]) {
    return val;
  }
  inx = indx.y * ct.lim[0] + indx.x;
  var f00 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
  inx++;
  var f10 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
  inx += ct.lim[0];
  var f11 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
  inx--;
  var f01 = { x: ct.cvs[inx][0], y: ct.cvs[inx][1] };
  var m11 = frct.x * frct.y, m10 = frct.x * (1 - frct.y), m00 = (1 - frct.x) * (1 - frct.y), m01 = (1 - frct.x) * frct.y;
  val.x = m00 * f00.x + m10 * f10.x + m01 * f01.x + m11 * f11.x;
  val.y = m00 * f00.y + m10 * f10.y + m01 * f01.y + m11 * f11.y;
  return val;
}
var init_datum_transform = __esm({
  "node_modules/proj4/lib/datum_transform.js"() {
    init_values();
    init_datumUtils();
    init_adjust_lon();
  }
});

// node_modules/proj4/lib/adjust_axis.js
function adjust_axis_default(crs, denorm, point3) {
  var xin = point3.x, yin = point3.y, zin = point3.z || 0;
  var v, t, i;
  var out = {};
  for (i = 0; i < 3; i++) {
    if (denorm && i === 2 && point3.z === void 0) {
      continue;
    }
    if (i === 0) {
      v = xin;
      if ("ew".indexOf(crs.axis[i]) !== -1) {
        t = "x";
      } else {
        t = "y";
      }
    } else if (i === 1) {
      v = yin;
      if ("ns".indexOf(crs.axis[i]) !== -1) {
        t = "y";
      } else {
        t = "x";
      }
    } else {
      v = zin;
      t = "z";
    }
    switch (crs.axis[i]) {
      case "e":
        out[t] = v;
        break;
      case "w":
        out[t] = -v;
        break;
      case "n":
        out[t] = v;
        break;
      case "s":
        out[t] = -v;
        break;
      case "u":
        if (point3[t] !== void 0) {
          out.z = v;
        }
        break;
      case "d":
        if (point3[t] !== void 0) {
          out.z = -v;
        }
        break;
      default:
        return null;
    }
  }
  return out;
}
var init_adjust_axis = __esm({
  "node_modules/proj4/lib/adjust_axis.js"() {
  }
});

// node_modules/proj4/lib/common/toPoint.js
function toPoint_default(array) {
  var out = {
    x: array[0],
    y: array[1]
  };
  if (array.length > 2) {
    out.z = array[2];
  }
  if (array.length > 3) {
    out.m = array[3];
  }
  return out;
}
var init_toPoint = __esm({
  "node_modules/proj4/lib/common/toPoint.js"() {
  }
});

// node_modules/proj4/lib/checkSanity.js
function checkSanity_default(point3) {
  checkCoord(point3.x);
  checkCoord(point3.y);
}
function checkCoord(num) {
  if (typeof Number.isFinite === "function") {
    if (Number.isFinite(num)) {
      return;
    }
    throw new TypeError("coordinates must be finite numbers");
  }
  if (typeof num !== "number" || num !== num || !isFinite(num)) {
    throw new TypeError("coordinates must be finite numbers");
  }
}
var init_checkSanity = __esm({
  "node_modules/proj4/lib/checkSanity.js"() {
  }
});

// node_modules/proj4/lib/transform.js
function checkNotWGS(source, dest) {
  return (source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM || source.datum.datum_type === PJD_GRIDSHIFT) && dest.datumCode !== "WGS84" || (dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM || dest.datum.datum_type === PJD_GRIDSHIFT) && source.datumCode !== "WGS84";
}
function transform(source, dest, point3, enforceAxis) {
  var wgs842;
  if (Array.isArray(point3)) {
    point3 = toPoint_default(point3);
  } else {
    point3 = {
      x: point3.x,
      y: point3.y,
      z: point3.z,
      m: point3.m
    };
  }
  var hasZ = point3.z !== void 0;
  checkSanity_default(point3);
  if (source.datum && dest.datum && checkNotWGS(source, dest)) {
    wgs842 = new Proj_default("WGS84");
    point3 = transform(source, wgs842, point3, enforceAxis);
    source = wgs842;
  }
  if (enforceAxis && source.axis !== "enu") {
    point3 = adjust_axis_default(source, false, point3);
  }
  if (source.projName === "longlat") {
    point3 = {
      x: point3.x * D2R,
      y: point3.y * D2R,
      z: point3.z || 0
    };
  } else {
    if (source.to_meter) {
      point3 = {
        x: point3.x * source.to_meter,
        y: point3.y * source.to_meter,
        z: point3.z || 0
      };
    }
    point3 = source.inverse(point3);
    if (!point3) {
      return;
    }
  }
  if (source.from_greenwich) {
    point3.x += source.from_greenwich;
  }
  point3 = datum_transform_default(source.datum, dest.datum, point3);
  if (!point3) {
    return;
  }
  if (dest.from_greenwich) {
    point3 = {
      x: point3.x - dest.from_greenwich,
      y: point3.y,
      z: point3.z || 0
    };
  }
  if (dest.projName === "longlat") {
    point3 = {
      x: point3.x * R2D,
      y: point3.y * R2D,
      z: point3.z || 0
    };
  } else {
    point3 = dest.forward(point3);
    if (dest.to_meter) {
      point3 = {
        x: point3.x / dest.to_meter,
        y: point3.y / dest.to_meter,
        z: point3.z || 0
      };
    }
  }
  if (enforceAxis && dest.axis !== "enu") {
    return adjust_axis_default(dest, true, point3);
  }
  if (!hasZ) {
    delete point3.z;
  }
  return point3;
}
var init_transform = __esm({
  "node_modules/proj4/lib/transform.js"() {
    init_values();
    init_datum_transform();
    init_adjust_axis();
    init_Proj();
    init_toPoint();
    init_checkSanity();
  }
});

// node_modules/proj4/lib/core.js
function transformer(from, to, coords, enforceAxis) {
  var transformedArray, out, keys;
  if (Array.isArray(coords)) {
    transformedArray = transform(from, to, coords, enforceAxis) || { x: NaN, y: NaN };
    if (coords.length > 2) {
      if (typeof from.name !== "undefined" && from.name === "geocent" || typeof to.name !== "undefined" && to.name === "geocent") {
        if (typeof transformedArray.z === "number") {
          return [transformedArray.x, transformedArray.y, transformedArray.z].concat(coords.splice(3));
        } else {
          return [transformedArray.x, transformedArray.y, coords[2]].concat(coords.splice(3));
        }
      } else {
        return [transformedArray.x, transformedArray.y].concat(coords.splice(2));
      }
    } else {
      return [transformedArray.x, transformedArray.y];
    }
  } else {
    out = transform(from, to, coords, enforceAxis);
    keys = Object.keys(coords);
    if (keys.length === 2) {
      return out;
    }
    keys.forEach(function(key) {
      if (typeof from.name !== "undefined" && from.name === "geocent" || typeof to.name !== "undefined" && to.name === "geocent") {
        if (key === "x" || key === "y" || key === "z") {
          return;
        }
      } else {
        if (key === "x" || key === "y") {
          return;
        }
      }
      out[key] = coords[key];
    });
    return out;
  }
}
function checkProj(item) {
  if (item instanceof Proj_default) {
    return item;
  }
  if (item.oProj) {
    return item.oProj;
  }
  return Proj_default(item);
}
function proj42(fromProj, toProj, coord) {
  fromProj = checkProj(fromProj);
  var single = false;
  var obj2;
  if (typeof toProj === "undefined") {
    toProj = fromProj;
    fromProj = wgs84;
    single = true;
  } else if (typeof toProj.x !== "undefined" || Array.isArray(toProj)) {
    coord = toProj;
    toProj = fromProj;
    fromProj = wgs84;
    single = true;
  }
  toProj = checkProj(toProj);
  if (coord) {
    return transformer(fromProj, toProj, coord);
  } else {
    obj2 = {
      forward: function(coords, enforceAxis) {
        return transformer(fromProj, toProj, coords, enforceAxis);
      },
      inverse: function(coords, enforceAxis) {
        return transformer(toProj, fromProj, coords, enforceAxis);
      }
    };
    if (single) {
      obj2.oProj = toProj;
    }
    return obj2;
  }
}
var wgs84, core_default;
var init_core = __esm({
  "node_modules/proj4/lib/core.js"() {
    init_Proj();
    init_transform();
    wgs84 = Proj_default("WGS84");
    core_default = proj42;
  }
});

// node_modules/mgrs/mgrs.js
function forward2(ll, accuracy) {
  accuracy = accuracy || 5;
  return encode(LLtoUTM({
    lat: ll[1],
    lon: ll[0]
  }), accuracy);
}
function inverse2(mgrs) {
  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
  if (bbox.lat && bbox.lon) {
    return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];
  }
  return [bbox.left, bbox.bottom, bbox.right, bbox.top];
}
function toPoint(mgrs) {
  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
  if (bbox.lat && bbox.lon) {
    return [bbox.lon, bbox.lat];
  }
  return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];
}
function degToRad(deg) {
  return deg * (Math.PI / 180);
}
function radToDeg(rad) {
  return 180 * (rad / Math.PI);
}
function LLtoUTM(ll) {
  var Lat = ll.lat;
  var Long = ll.lon;
  var a = 6378137;
  var eccSquared = 669438e-8;
  var k0 = 0.9996;
  var LongOrigin;
  var eccPrimeSquared;
  var N, T, C, A2, M;
  var LatRad = degToRad(Lat);
  var LongRad = degToRad(Long);
  var LongOriginRad;
  var ZoneNumber;
  ZoneNumber = Math.floor((Long + 180) / 6) + 1;
  if (Long === 180) {
    ZoneNumber = 60;
  }
  if (Lat >= 56 && Lat < 64 && Long >= 3 && Long < 12) {
    ZoneNumber = 32;
  }
  if (Lat >= 72 && Lat < 84) {
    if (Long >= 0 && Long < 9) {
      ZoneNumber = 31;
    } else if (Long >= 9 && Long < 21) {
      ZoneNumber = 33;
    } else if (Long >= 21 && Long < 33) {
      ZoneNumber = 35;
    } else if (Long >= 33 && Long < 42) {
      ZoneNumber = 37;
    }
  }
  LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3;
  LongOriginRad = degToRad(LongOrigin);
  eccPrimeSquared = eccSquared / (1 - eccSquared);
  N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
  T = Math.tan(LatRad) * Math.tan(LatRad);
  C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
  A2 = Math.cos(LatRad) * (LongRad - LongOriginRad);
  M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - 35 * eccSquared * eccSquared * eccSquared / 3072 * Math.sin(6 * LatRad));
  var UTMEasting = k0 * N * (A2 + (1 - T + C) * A2 * A2 * A2 / 6 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A2 * A2 * A2 * A2 * A2 / 120) + 5e5;
  var UTMNorthing = k0 * (M + N * Math.tan(LatRad) * (A2 * A2 / 2 + (5 - T + 9 * C + 4 * C * C) * A2 * A2 * A2 * A2 / 24 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A2 * A2 * A2 * A2 * A2 * A2 / 720));
  if (Lat < 0) {
    UTMNorthing += 1e7;
  }
  return {
    northing: Math.round(UTMNorthing),
    easting: Math.round(UTMEasting),
    zoneNumber: ZoneNumber,
    zoneLetter: getLetterDesignator(Lat)
  };
}
function UTMtoLL(utm) {
  var UTMNorthing = utm.northing;
  var UTMEasting = utm.easting;
  var zoneLetter = utm.zoneLetter;
  var zoneNumber = utm.zoneNumber;
  if (zoneNumber < 0 || zoneNumber > 60) {
    return null;
  }
  var k0 = 0.9996;
  var a = 6378137;
  var eccSquared = 669438e-8;
  var eccPrimeSquared;
  var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
  var N1, T1, C12, R1, D, M;
  var LongOrigin;
  var mu, phi1Rad;
  var x = UTMEasting - 5e5;
  var y = UTMNorthing;
  if (zoneLetter < "N") {
    y -= 1e7;
  }
  LongOrigin = (zoneNumber - 1) * 6 - 180 + 3;
  eccPrimeSquared = eccSquared / (1 - eccSquared);
  M = y / k0;
  mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));
  phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + 151 * e1 * e1 * e1 / 96 * Math.sin(6 * mu);
  N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
  T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
  C12 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
  R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
  D = x / (N1 * k0);
  var lat = phi1Rad - N1 * Math.tan(phi1Rad) / R1 * (D * D / 2 - (5 + 3 * T1 + 10 * C12 - 4 * C12 * C12 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C12 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C12 * C12) * D * D * D * D * D * D / 720);
  lat = radToDeg(lat);
  var lon = (D - (1 + 2 * T1 + C12) * D * D * D / 6 + (5 - 2 * C12 + 28 * T1 - 3 * C12 * C12 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);
  lon = LongOrigin + radToDeg(lon);
  var result2;
  if (utm.accuracy) {
    var topRight = UTMtoLL({
      northing: utm.northing + utm.accuracy,
      easting: utm.easting + utm.accuracy,
      zoneLetter: utm.zoneLetter,
      zoneNumber: utm.zoneNumber
    });
    result2 = {
      top: topRight.lat,
      right: topRight.lon,
      bottom: lat,
      left: lon
    };
  } else {
    result2 = {
      lat,
      lon
    };
  }
  return result2;
}
function getLetterDesignator(lat) {
  var LetterDesignator = "Z";
  if (84 >= lat && lat >= 72) {
    LetterDesignator = "X";
  } else if (72 > lat && lat >= 64) {
    LetterDesignator = "W";
  } else if (64 > lat && lat >= 56) {
    LetterDesignator = "V";
  } else if (56 > lat && lat >= 48) {
    LetterDesignator = "U";
  } else if (48 > lat && lat >= 40) {
    LetterDesignator = "T";
  } else if (40 > lat && lat >= 32) {
    LetterDesignator = "S";
  } else if (32 > lat && lat >= 24) {
    LetterDesignator = "R";
  } else if (24 > lat && lat >= 16) {
    LetterDesignator = "Q";
  } else if (16 > lat && lat >= 8) {
    LetterDesignator = "P";
  } else if (8 > lat && lat >= 0) {
    LetterDesignator = "N";
  } else if (0 > lat && lat >= -8) {
    LetterDesignator = "M";
  } else if (-8 > lat && lat >= -16) {
    LetterDesignator = "L";
  } else if (-16 > lat && lat >= -24) {
    LetterDesignator = "K";
  } else if (-24 > lat && lat >= -32) {
    LetterDesignator = "J";
  } else if (-32 > lat && lat >= -40) {
    LetterDesignator = "H";
  } else if (-40 > lat && lat >= -48) {
    LetterDesignator = "G";
  } else if (-48 > lat && lat >= -56) {
    LetterDesignator = "F";
  } else if (-56 > lat && lat >= -64) {
    LetterDesignator = "E";
  } else if (-64 > lat && lat >= -72) {
    LetterDesignator = "D";
  } else if (-72 > lat && lat >= -80) {
    LetterDesignator = "C";
  }
  return LetterDesignator;
}
function encode(utm, accuracy) {
  var seasting = "00000" + utm.easting, snorthing = "00000" + utm.northing;
  return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
}
function get100kID(easting, northing, zoneNumber) {
  var setParm = get100kSetForZone(zoneNumber);
  var setColumn = Math.floor(easting / 1e5);
  var setRow = Math.floor(northing / 1e5) % 20;
  return getLetter100kID(setColumn, setRow, setParm);
}
function get100kSetForZone(i) {
  var setParm = i % NUM_100K_SETS;
  if (setParm === 0) {
    setParm = NUM_100K_SETS;
  }
  return setParm;
}
function getLetter100kID(column, row, parm) {
  var index = parm - 1;
  var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);
  var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);
  var colInt = colOrigin + column - 1;
  var rowInt = rowOrigin + row;
  var rollover = false;
  if (colInt > Z) {
    colInt = colInt - Z + A - 1;
    rollover = true;
  }
  if (colInt === I || colOrigin < I && colInt > I || (colInt > I || colOrigin < I) && rollover) {
    colInt++;
  }
  if (colInt === O || colOrigin < O && colInt > O || (colInt > O || colOrigin < O) && rollover) {
    colInt++;
    if (colInt === I) {
      colInt++;
    }
  }
  if (colInt > Z) {
    colInt = colInt - Z + A - 1;
  }
  if (rowInt > V) {
    rowInt = rowInt - V + A - 1;
    rollover = true;
  } else {
    rollover = false;
  }
  if (rowInt === I || rowOrigin < I && rowInt > I || (rowInt > I || rowOrigin < I) && rollover) {
    rowInt++;
  }
  if (rowInt === O || rowOrigin < O && rowInt > O || (rowInt > O || rowOrigin < O) && rollover) {
    rowInt++;
    if (rowInt === I) {
      rowInt++;
    }
  }
  if (rowInt > V) {
    rowInt = rowInt - V + A - 1;
  }
  var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
  return twoLetter;
}
function decode(mgrsString) {
  if (mgrsString && mgrsString.length === 0) {
    throw "MGRSPoint coverting from nothing";
  }
  var length = mgrsString.length;
  var hunK = null;
  var sb = "";
  var testChar;
  var i = 0;
  while (!/[A-Z]/.test(testChar = mgrsString.charAt(i))) {
    if (i >= 2) {
      throw "MGRSPoint bad conversion from: " + mgrsString;
    }
    sb += testChar;
    i++;
  }
  var zoneNumber = parseInt(sb, 10);
  if (i === 0 || i + 3 > length) {
    throw "MGRSPoint bad conversion from: " + mgrsString;
  }
  var zoneLetter = mgrsString.charAt(i++);
  if (zoneLetter <= "A" || zoneLetter === "B" || zoneLetter === "Y" || zoneLetter >= "Z" || zoneLetter === "I" || zoneLetter === "O") {
    throw "MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString;
  }
  hunK = mgrsString.substring(i, i += 2);
  var set = get100kSetForZone(zoneNumber);
  var east100k = getEastingFromChar(hunK.charAt(0), set);
  var north100k = getNorthingFromChar(hunK.charAt(1), set);
  while (north100k < getMinNorthing(zoneLetter)) {
    north100k += 2e6;
  }
  var remainder = length - i;
  if (remainder % 2 !== 0) {
    throw "MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString;
  }
  var sep = remainder / 2;
  var sepEasting = 0;
  var sepNorthing = 0;
  var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;
  if (sep > 0) {
    accuracyBonus = 1e5 / Math.pow(10, sep);
    sepEastingString = mgrsString.substring(i, i + sep);
    sepEasting = parseFloat(sepEastingString) * accuracyBonus;
    sepNorthingString = mgrsString.substring(i + sep);
    sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
  }
  easting = sepEasting + east100k;
  northing = sepNorthing + north100k;
  return {
    easting,
    northing,
    zoneLetter,
    zoneNumber,
    accuracy: accuracyBonus
  };
}
function getEastingFromChar(e, set) {
  var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);
  var eastingValue = 1e5;
  var rewindMarker = false;
  while (curCol !== e.charCodeAt(0)) {
    curCol++;
    if (curCol === I) {
      curCol++;
    }
    if (curCol === O) {
      curCol++;
    }
    if (curCol > Z) {
      if (rewindMarker) {
        throw "Bad character: " + e;
      }
      curCol = A;
      rewindMarker = true;
    }
    eastingValue += 1e5;
  }
  return eastingValue;
}
function getNorthingFromChar(n, set) {
  if (n > "V") {
    throw "MGRSPoint given invalid Northing " + n;
  }
  var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);
  var northingValue = 0;
  var rewindMarker = false;
  while (curRow !== n.charCodeAt(0)) {
    curRow++;
    if (curRow === I) {
      curRow++;
    }
    if (curRow === O) {
      curRow++;
    }
    if (curRow > V) {
      if (rewindMarker) {
        throw "Bad character: " + n;
      }
      curRow = A;
      rewindMarker = true;
    }
    northingValue += 1e5;
  }
  return northingValue;
}
function getMinNorthing(zoneLetter) {
  var northing;
  switch (zoneLetter) {
    case "C":
      northing = 11e5;
      break;
    case "D":
      northing = 2e6;
      break;
    case "E":
      northing = 28e5;
      break;
    case "F":
      northing = 37e5;
      break;
    case "G":
      northing = 46e5;
      break;
    case "H":
      northing = 55e5;
      break;
    case "J":
      northing = 64e5;
      break;
    case "K":
      northing = 73e5;
      break;
    case "L":
      northing = 82e5;
      break;
    case "M":
      northing = 91e5;
      break;
    case "N":
      northing = 0;
      break;
    case "P":
      northing = 8e5;
      break;
    case "Q":
      northing = 17e5;
      break;
    case "R":
      northing = 26e5;
      break;
    case "S":
      northing = 35e5;
      break;
    case "T":
      northing = 44e5;
      break;
    case "U":
      northing = 53e5;
      break;
    case "V":
      northing = 62e5;
      break;
    case "W":
      northing = 7e6;
      break;
    case "X":
      northing = 79e5;
      break;
    default:
      northing = -1;
  }
  if (northing >= 0) {
    return northing;
  } else {
    throw "Invalid zone letter: " + zoneLetter;
  }
}
var NUM_100K_SETS, SET_ORIGIN_COLUMN_LETTERS, SET_ORIGIN_ROW_LETTERS, A, I, O, V, Z, mgrs_default;
var init_mgrs = __esm({
  "node_modules/mgrs/mgrs.js"() {
    NUM_100K_SETS = 6;
    SET_ORIGIN_COLUMN_LETTERS = "AJSAJS";
    SET_ORIGIN_ROW_LETTERS = "AFAFAF";
    A = 65;
    I = 73;
    O = 79;
    V = 86;
    Z = 90;
    mgrs_default = {
      forward: forward2,
      inverse: inverse2,
      toPoint
    };
  }
});

// node_modules/proj4/lib/Point.js
function Point(x, y, z) {
  if (!(this instanceof Point)) {
    return new Point(x, y, z);
  }
  if (Array.isArray(x)) {
    this.x = x[0];
    this.y = x[1];
    this.z = x[2] || 0;
  } else if (typeof x === "object") {
    this.x = x.x;
    this.y = x.y;
    this.z = x.z || 0;
  } else if (typeof x === "string" && typeof y === "undefined") {
    var coords = x.split(",");
    this.x = parseFloat(coords[0], 10);
    this.y = parseFloat(coords[1], 10);
    this.z = parseFloat(coords[2], 10) || 0;
  } else {
    this.x = x;
    this.y = y;
    this.z = z || 0;
  }
  console.warn("proj4.Point will be removed in version 3, use proj4.toPoint");
}
var Point_default;
var init_Point = __esm({
  "node_modules/proj4/lib/Point.js"() {
    init_mgrs();
    Point.fromMGRS = function(mgrsStr) {
      return new Point(toPoint(mgrsStr));
    };
    Point.prototype.toMGRS = function(accuracy) {
      return forward2([this.x, this.y], accuracy);
    };
    Point_default = Point;
  }
});

// node_modules/proj4/lib/common/pj_enfn.js
function pj_enfn_default(es) {
  var en = [];
  en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));
  en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));
  var t = es * es;
  en[2] = t * (C44 - es * (C46 + es * C48));
  t *= es;
  en[3] = t * (C66 - es * C68);
  en[4] = t * es * C88;
  return en;
}
var C00, C02, C04, C06, C08, C22, C44, C46, C48, C66, C68, C88;
var init_pj_enfn = __esm({
  "node_modules/proj4/lib/common/pj_enfn.js"() {
    C00 = 1;
    C02 = 0.25;
    C04 = 0.046875;
    C06 = 0.01953125;
    C08 = 0.01068115234375;
    C22 = 0.75;
    C44 = 0.46875;
    C46 = 0.013020833333333334;
    C48 = 0.007120768229166667;
    C66 = 0.3645833333333333;
    C68 = 0.005696614583333333;
    C88 = 0.3076171875;
  }
});

// node_modules/proj4/lib/common/pj_mlfn.js
function pj_mlfn_default(phi, sphi, cphi, en) {
  cphi *= sphi;
  sphi *= sphi;
  return en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4])));
}
var init_pj_mlfn = __esm({
  "node_modules/proj4/lib/common/pj_mlfn.js"() {
  }
});

// node_modules/proj4/lib/common/pj_inv_mlfn.js
function pj_inv_mlfn_default(arg, es, en) {
  var k = 1 / (1 - es);
  var phi = arg;
  for (var i = MAX_ITER; i; --i) {
    var s = Math.sin(phi);
    var t = 1 - es * s * s;
    t = (pj_mlfn_default(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;
    phi -= t;
    if (Math.abs(t) < EPSLN) {
      return phi;
    }
  }
  return phi;
}
var MAX_ITER;
var init_pj_inv_mlfn = __esm({
  "node_modules/proj4/lib/common/pj_inv_mlfn.js"() {
    init_pj_mlfn();
    init_values();
    MAX_ITER = 20;
  }
});

// node_modules/proj4/lib/projections/tmerc.js
function init3() {
  this.x0 = this.x0 !== void 0 ? this.x0 : 0;
  this.y0 = this.y0 !== void 0 ? this.y0 : 0;
  this.long0 = this.long0 !== void 0 ? this.long0 : 0;
  this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0;
  if (this.es) {
    this.en = pj_enfn_default(this.es);
    this.ml0 = pj_mlfn_default(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en);
  }
}
function forward3(p) {
  var lon = p.x;
  var lat = p.y;
  var delta_lon = adjust_lon_default(lon - this.long0);
  var con;
  var x, y;
  var sin_phi = Math.sin(lat);
  var cos_phi = Math.cos(lat);
  if (!this.es) {
    var b = cos_phi * Math.sin(delta_lon);
    if (Math.abs(Math.abs(b) - 1) < EPSLN) {
      return 93;
    } else {
      x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b)) + this.x0;
      y = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b, 2));
      b = Math.abs(y);
      if (b >= 1) {
        if (b - 1 > EPSLN) {
          return 93;
        } else {
          y = 0;
        }
      } else {
        y = Math.acos(y);
      }
      if (lat < 0) {
        y = -y;
      }
      y = this.a * this.k0 * (y - this.lat0) + this.y0;
    }
  } else {
    var al = cos_phi * delta_lon;
    var als = Math.pow(al, 2);
    var c = this.ep2 * Math.pow(cos_phi, 2);
    var cs = Math.pow(c, 2);
    var tq = Math.abs(cos_phi) > EPSLN ? Math.tan(lat) : 0;
    var t = Math.pow(tq, 2);
    var ts = Math.pow(t, 2);
    con = 1 - this.es * Math.pow(sin_phi, 2);
    al = al / Math.sqrt(con);
    var ml = pj_mlfn_default(lat, sin_phi, cos_phi, this.en);
    x = this.a * (this.k0 * al * (1 + als / 6 * (1 - t + c + als / 20 * (5 - 18 * t + ts + 14 * c - 58 * t * c + als / 42 * (61 + 179 * ts - ts * t - 479 * t))))) + this.x0;
    y = this.a * (this.k0 * (ml - this.ml0 + sin_phi * delta_lon * al / 2 * (1 + als / 12 * (5 - t + 9 * c + 4 * cs + als / 30 * (61 + ts - 58 * t + 270 * c - 330 * t * c + als / 56 * (1385 + 543 * ts - ts * t - 3111 * t)))))) + this.y0;
  }
  p.x = x;
  p.y = y;
  return p;
}
function inverse3(p) {
  var con, phi;
  var lat, lon;
  var x = (p.x - this.x0) * (1 / this.a);
  var y = (p.y - this.y0) * (1 / this.a);
  if (!this.es) {
    var f = Math.exp(x / this.k0);
    var g = 0.5 * (f - 1 / f);
    var temp = this.lat0 + y / this.k0;
    var h = Math.cos(temp);
    con = Math.sqrt((1 - Math.pow(h, 2)) / (1 + Math.pow(g, 2)));
    lat = Math.asin(con);
    if (y < 0) {
      lat = -lat;
    }
    if (g === 0 && h === 0) {
      lon = 0;
    } else {
      lon = adjust_lon_default(Math.atan2(g, h) + this.long0);
    }
  } else {
    con = this.ml0 + y / this.k0;
    phi = pj_inv_mlfn_default(con, this.es, this.en);
    if (Math.abs(phi) < HALF_PI) {
      var sin_phi = Math.sin(phi);
      var cos_phi = Math.cos(phi);
      var tan_phi = Math.abs(cos_phi) > EPSLN ? Math.tan(phi) : 0;
      var c = this.ep2 * Math.pow(cos_phi, 2);
      var cs = Math.pow(c, 2);
      var t = Math.pow(tan_phi, 2);
      var ts = Math.pow(t, 2);
      con = 1 - this.es * Math.pow(sin_phi, 2);
      var d = x * Math.sqrt(con) / this.k0;
      var ds = Math.pow(d, 2);
      con = con * tan_phi;
      lat = phi - con * ds / (1 - this.es) * 0.5 * (1 - ds / 12 * (5 + 3 * t - 9 * c * t + c - 4 * cs - ds / 30 * (61 + 90 * t - 252 * c * t + 45 * ts + 46 * c - ds / 56 * (1385 + 3633 * t + 4095 * ts + 1574 * ts * t))));
      lon = adjust_lon_default(this.long0 + d * (1 - ds / 6 * (1 + 2 * t + c - ds / 20 * (5 + 28 * t + 24 * ts + 8 * c * t + 6 * c - ds / 42 * (61 + 662 * t + 1320 * ts + 720 * ts * t)))) / cos_phi);
    } else {
      lat = HALF_PI * sign_default(y);
      lon = 0;
    }
  }
  p.x = lon;
  p.y = lat;
  return p;
}
var names4, tmerc_default;
var init_tmerc = __esm({
  "node_modules/proj4/lib/projections/tmerc.js"() {
    init_pj_enfn();
    init_pj_mlfn();
    init_pj_inv_mlfn();
    init_adjust_lon();
    init_values();
    init_sign();
    names4 = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];
    tmerc_default = {
      init: init3,
      forward: forward3,
      inverse: inverse3,
      names: names4
    };
  }
});

// node_modules/proj4/lib/common/sinh.js
function sinh_default(x) {
  var r = Math.exp(x);
  r = (r - 1 / r) / 2;
  return r;
}
var init_sinh = __esm({
  "node_modules/proj4/lib/common/sinh.js"() {
  }
});

// node_modules/proj4/lib/common/hypot.js
function hypot_default(x, y) {
  x = Math.abs(x);
  y = Math.abs(y);
  var a = Math.max(x, y);
  var b = Math.min(x, y) / (a ? a : 1);
  return a * Math.sqrt(1 + Math.pow(b, 2));
}
var init_hypot = __esm({
  "node_modules/proj4/lib/common/hypot.js"() {
  }
});

// node_modules/proj4/lib/common/log1py.js
function log1py_default(x) {
  var y = 1 + x;
  var z = y - 1;
  return z === 0 ? x : x * Math.log(y) / z;
}
var init_log1py = __esm({
  "node_modules/proj4/lib/common/log1py.js"() {
  }
});

// node_modules/proj4/lib/common/asinhy.js
function asinhy_default(x) {
  var y = Math.abs(x);
  y = log1py_default(y * (1 + y / (hypot_default(1, y) + 1)));
  return x < 0 ? -y : y;
}
var init_asinhy = __esm({
  "node_modules/proj4/lib/common/asinhy.js"() {
    init_hypot();
    init_log1py();
  }
});

// node_modules/proj4/lib/common/gatg.js
function gatg_default(pp, B) {
  var cos_2B = 2 * Math.cos(2 * B);
  var i = pp.length - 1;
  var h1 = pp[i];
  var h2 = 0;
  var h;
  while (--i >= 0) {
    h = -h2 + cos_2B * h1 + pp[i];
    h2 = h1;
    h1 = h;
  }
  return B + h * Math.sin(2 * B);
}
var init_gatg = __esm({
  "node_modules/proj4/lib/common/gatg.js"() {
  }
});

// node_modules/proj4/lib/common/clens.js
function clens_default(pp, arg_r) {
  var r = 2 * Math.cos(arg_r);
  var i = pp.length - 1;
  var hr1 = pp[i];
  var hr2 = 0;
  var hr;
  while (--i >= 0) {
    hr = -hr2 + r * hr1 + pp[i];
    hr2 = hr1;
    hr1 = hr;
  }
  return Math.sin(arg_r) * hr;
}
var init_clens = __esm({
  "node_modules/proj4/lib/common/clens.js"() {
  }
});

// node_modules/proj4/lib/common/cosh.js
function cosh_default(x) {
  var r = Math.exp(x);
  r = (r + 1 / r) / 2;
  return r;
}
var init_cosh = __esm({
  "node_modules/proj4/lib/common/cosh.js"() {
  }
});

// node_modules/proj4/lib/common/clens_cmplx.js
function clens_cmplx_default(pp, arg_r, arg_i) {
  var sin_arg_r = Math.sin(arg_r);
  var cos_arg_r = Math.cos(arg_r);
  var sinh_arg_i = sinh_default(arg_i);
  var cosh_arg_i = cosh_default(arg_i);
  var r = 2 * cos_arg_r * cosh_arg_i;
  var i = -2 * sin_arg_r * sinh_arg_i;
  var j = pp.length - 1;
  var hr = pp[j];
  var hi1 = 0;
  var hr1 = 0;
  var hi = 0;
  var hr2;
  var hi2;
  while (--j >= 0) {
    hr2 = hr1;
    hi2 = hi1;
    hr1 = hr;
    hi1 = hi;
    hr = -hr2 + r * hr1 - i * hi1 + pp[j];
    hi = -hi2 + i * hr1 + r * hi1;
  }
  r = sin_arg_r * cosh_arg_i;
  i = cos_arg_r * sinh_arg_i;
  return [r * hr - i * hi, r * hi + i * hr];
}
var init_clens_cmplx = __esm({
  "node_modules/proj4/lib/common/clens_cmplx.js"() {
    init_sinh();
    init_cosh();
  }
});

// node_modules/proj4/lib/projections/etmerc.js
function init4() {
  if (!this.approx && (isNaN(this.es) || this.es <= 0)) {
    throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
  }
  if (this.approx) {
    tmerc_default.init.apply(this);
    this.forward = tmerc_default.forward;
    this.inverse = tmerc_default.inverse;
  }
  this.x0 = this.x0 !== void 0 ? this.x0 : 0;
  this.y0 = this.y0 !== void 0 ? this.y0 : 0;
  this.long0 = this.long0 !== void 0 ? this.long0 : 0;
  this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0;
  this.cgb = [];
  this.cbg = [];
  this.utg = [];
  this.gtu = [];
  var f = this.es / (1 + Math.sqrt(1 - this.es));
  var n = f / (2 - f);
  var np = n;
  this.cgb[0] = n * (2 + n * (-2 / 3 + n * (-2 + n * (116 / 45 + n * (26 / 45 + n * (-2854 / 675))))));
  this.cbg[0] = n * (-2 + n * (2 / 3 + n * (4 / 3 + n * (-82 / 45 + n * (32 / 45 + n * (4642 / 4725))))));
  np = np * n;
  this.cgb[1] = np * (7 / 3 + n * (-8 / 5 + n * (-227 / 45 + n * (2704 / 315 + n * (2323 / 945)))));
  this.cbg[1] = np * (5 / 3 + n * (-16 / 15 + n * (-13 / 9 + n * (904 / 315 + n * (-1522 / 945)))));
  np = np * n;
  this.cgb[2] = np * (56 / 15 + n * (-136 / 35 + n * (-1262 / 105 + n * (73814 / 2835))));
  this.cbg[2] = np * (-26 / 15 + n * (34 / 21 + n * (8 / 5 + n * (-12686 / 2835))));
  np = np * n;
  this.cgb[3] = np * (4279 / 630 + n * (-332 / 35 + n * (-399572 / 14175)));
  this.cbg[3] = np * (1237 / 630 + n * (-12 / 5 + n * (-24832 / 14175)));
  np = np * n;
  this.cgb[4] = np * (4174 / 315 + n * (-144838 / 6237));
  this.cbg[4] = np * (-734 / 315 + n * (109598 / 31185));
  np = np * n;
  this.cgb[5] = np * (601676 / 22275);
  this.cbg[5] = np * (444337 / 155925);
  np = Math.pow(n, 2);
  this.Qn = this.k0 / (1 + n) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));
  this.utg[0] = n * (-0.5 + n * (2 / 3 + n * (-37 / 96 + n * (1 / 360 + n * (81 / 512 + n * (-96199 / 604800))))));
  this.gtu[0] = n * (0.5 + n * (-2 / 3 + n * (5 / 16 + n * (41 / 180 + n * (-127 / 288 + n * (7891 / 37800))))));
  this.utg[1] = np * (-1 / 48 + n * (-1 / 15 + n * (437 / 1440 + n * (-46 / 105 + n * (1118711 / 3870720)))));
  this.gtu[1] = np * (13 / 48 + n * (-3 / 5 + n * (557 / 1440 + n * (281 / 630 + n * (-1983433 / 1935360)))));
  np = np * n;
  this.utg[2] = np * (-17 / 480 + n * (37 / 840 + n * (209 / 4480 + n * (-5569 / 90720))));
  this.gtu[2] = np * (61 / 240 + n * (-103 / 140 + n * (15061 / 26880 + n * (167603 / 181440))));
  np = np * n;
  this.utg[3] = np * (-4397 / 161280 + n * (11 / 504 + n * (830251 / 7257600)));
  this.gtu[3] = np * (49561 / 161280 + n * (-179 / 168 + n * (6601661 / 7257600)));
  np = np * n;
  this.utg[4] = np * (-4583 / 161280 + n * (108847 / 3991680));
  this.gtu[4] = np * (34729 / 80640 + n * (-3418889 / 1995840));
  np = np * n;
  this.utg[5] = np * (-20648693 / 638668800);
  this.gtu[5] = np * (212378941 / 319334400);
  var Z2 = gatg_default(this.cbg, this.lat0);
  this.Zb = -this.Qn * (Z2 + clens_default(this.gtu, 2 * Z2));
}
function forward4(p) {
  var Ce = adjust_lon_default(p.x - this.long0);
  var Cn = p.y;
  Cn = gatg_default(this.cbg, Cn);
  var sin_Cn = Math.sin(Cn);
  var cos_Cn = Math.cos(Cn);
  var sin_Ce = Math.sin(Ce);
  var cos_Ce = Math.cos(Ce);
  Cn = Math.atan2(sin_Cn, cos_Ce * cos_Cn);
  Ce = Math.atan2(sin_Ce * cos_Cn, hypot_default(sin_Cn, cos_Cn * cos_Ce));
  Ce = asinhy_default(Math.tan(Ce));
  var tmp = clens_cmplx_default(this.gtu, 2 * Cn, 2 * Ce);
  Cn = Cn + tmp[0];
  Ce = Ce + tmp[1];
  var x;
  var y;
  if (Math.abs(Ce) <= 2.623395162778) {
    x = this.a * (this.Qn * Ce) + this.x0;
    y = this.a * (this.Qn * Cn + this.Zb) + this.y0;
  } else {
    x = Infinity;
    y = Infinity;
  }
  p.x = x;
  p.y = y;
  return p;
}
function inverse4(p) {
  var Ce = (p.x - this.x0) * (1 / this.a);
  var Cn = (p.y - this.y0) * (1 / this.a);
  Cn = (Cn - this.Zb) / this.Qn;
  Ce = Ce / this.Qn;
  var lon;
  var lat;
  if (Math.abs(Ce) <= 2.623395162778) {
    var tmp = clens_cmplx_default(this.utg, 2 * Cn, 2 * Ce);
    Cn = Cn + tmp[0];
    Ce = Ce + tmp[1];
    Ce = Math.atan(sinh_default(Ce));
    var sin_Cn = Math.sin(Cn);
    var cos_Cn = Math.cos(Cn);
    var sin_Ce = Math.sin(Ce);
    var cos_Ce = Math.cos(Ce);
    Cn = Math.atan2(sin_Cn * cos_Ce, hypot_default(sin_Ce, cos_Ce * cos_Cn));
    Ce = Math.atan2(sin_Ce, cos_Ce * cos_Cn);
    lon = adjust_lon_default(Ce + this.long0);
    lat = gatg_default(this.cgb, Cn);
  } else {
    lon = Infinity;
    lat = Infinity;
  }
  p.x = lon;
  p.y = lat;
  return p;
}
var names5, etmerc_default;
var init_etmerc = __esm({
  "node_modules/proj4/lib/projections/etmerc.js"() {
    init_tmerc();
    init_sinh();
    init_hypot();
    init_asinhy();
    init_gatg();
    init_clens();
    init_clens_cmplx();
    init_adjust_lon();
    names5 = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "tmerc"];
    etmerc_default = {
      init: init4,
      forward: forward4,
      inverse: inverse4,
      names: names5
    };
  }
});

// node_modules/proj4/lib/common/adjust_zone.js
function adjust_zone_default(zone, lon) {
  if (zone === void 0) {
    zone = Math.floor((adjust_lon_default(lon) + Math.PI) * 30 / Math.PI) + 1;
    if (zone < 0) {
      return 0;
    } else if (zone > 60) {
      return 60;
    }
  }
  return zone;
}
var init_adjust_zone = __esm({
  "node_modules/proj4/lib/common/adjust_zone.js"() {
    init_adjust_lon();
  }
});

// node_modules/proj4/lib/projections/utm.js
function init5() {
  var zone = adjust_zone_default(this.zone, this.long0);
  if (zone === void 0) {
    throw new Error("unknown utm zone");
  }
  this.lat0 = 0;
  this.long0 = (6 * Math.abs(zone) - 183) * D2R;
  this.x0 = 5e5;
  this.y0 = this.utmSouth ? 1e7 : 0;
  this.k0 = 0.9996;
  etmerc_default.init.apply(this);
  this.forward = etmerc_default.forward;
  this.inverse = etmerc_default.inverse;
}
var dependsOn, names6, utm_default;
var init_utm = __esm({
  "node_modules/proj4/lib/projections/utm.js"() {
    init_adjust_zone();
    init_etmerc();
    init_values();
    dependsOn = "etmerc";
    names6 = ["Universal Transverse Mercator System", "utm"];
    utm_default = {
      init: init5,
      names: names6,
      dependsOn
    };
  }
});

// node_modules/proj4/lib/common/srat.js
function srat_default(esinp, exp) {
  return Math.pow((1 - esinp) / (1 + esinp), exp);
}
var init_srat = __esm({
  "node_modules/proj4/lib/common/srat.js"() {
  }
});

// node_modules/proj4/lib/projections/gauss.js
function init6() {
  var sphi = Math.sin(this.lat0);
  var cphi = Math.cos(this.lat0);
  cphi *= cphi;
  this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);
  this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));
  this.phic0 = Math.asin(sphi / this.C);
  this.ratexp = 0.5 * this.C * this.e;
  this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat_default(this.e * sphi, this.ratexp));
}
function forward5(p) {
  var lon = p.x;
  var lat = p.y;
  p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat_default(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;
  p.x = this.C * lon;
  return p;
}
function inverse5(p) {
  var DEL_TOL = 1e-14;
  var lon = p.x / this.C;
  var lat = p.y;
  var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);
  for (var i = MAX_ITER2; i > 0; --i) {
    lat = 2 * Math.atan(num * srat_default(this.e * Math.sin(p.y), -0.5 * this.e)) - HALF_PI;
    if (Math.abs(lat - p.y) < DEL_TOL) {
      break;
    }
    p.y = lat;
  }
  if (!i) {
    return null;
  }
  p.x = lon;
  p.y = lat;
  return p;
}
var MAX_ITER2, names7, gauss_default;
var init_gauss = __esm({
  "node_modules/proj4/lib/projections/gauss.js"() {
    init_srat();
    init_values();
    MAX_ITER2 = 20;
    names7 = ["gauss"];
    gauss_default = {
      init: init6,
      forward: forward5,
      inverse: inverse5,
      names: names7
    };
  }
});

// node_modules/proj4/lib/projections/sterea.js
function init7() {
  gauss_default.init.apply(this);
  if (!this.rc) {
    return;
  }
  this.sinc0 = Math.sin(this.phic0);
  this.cosc0 = Math.cos(this.phic0);
  this.R2 = 2 * this.rc;
  if (!this.title) {
    this.title = "Oblique Stereographic Alternative";
  }
}
function forward6(p) {
  var sinc, cosc, cosl, k;
  p.x = adjust_lon_default(p.x - this.long0);
  gauss_default.forward.apply(this, [p]);
  sinc = Math.sin(p.y);
  cosc = Math.cos(p.y);
  cosl = Math.cos(p.x);
  k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);
  p.x = k * cosc * Math.sin(p.x);
  p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);
  p.x = this.a * p.x + this.x0;
  p.y = this.a * p.y + this.y0;
  return p;
}
function inverse6(p) {
  var sinc, cosc, lon, lat, rho;
  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;
  p.x /= this.k0;
  p.y /= this.k0;
  if (rho = Math.sqrt(p.x * p.x + p.y * p.y)) {
    var c = 2 * Math.atan2(rho, this.R2);
    sinc = Math.sin(c);
    cosc = Math.cos(c);
    lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);
    lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);
  } else {
    lat = this.phic0;
    lon = 0;
  }
  p.x = lon;
  p.y = lat;
  gauss_default.inverse.apply(this, [p]);
  p.x = adjust_lon_default(p.x + this.long0);
  return p;
}
var names8, sterea_default;
var init_sterea = __esm({
  "node_modules/proj4/lib/projections/sterea.js"() {
    init_gauss();
    init_adjust_lon();
    names8 = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"];
    sterea_default = {
      init: init7,
      forward: forward6,
      inverse: inverse6,
      names: names8
    };
  }
});

// node_modules/proj4/lib/projections/stere.js
function ssfn_(phit, sinphi, eccen) {
  sinphi *= eccen;
  return Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen);
}
function init8() {
  this.coslat0 = Math.cos(this.lat0);
  this.sinlat0 = Math.sin(this.lat0);
  if (this.sphere) {
    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
      this.k0 = 0.5 * (1 + sign_default(this.lat0) * Math.sin(this.lat_ts));
    }
  } else {
    if (Math.abs(this.coslat0) <= EPSLN) {
      if (this.lat0 > 0) {
        this.con = 1;
      } else {
        this.con = -1;
      }
    }
    this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));
    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
      this.k0 = 0.5 * this.cons * msfnz_default(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz_default(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));
    }
    this.ms1 = msfnz_default(this.e, this.sinlat0, this.coslat0);
    this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;
    this.cosX0 = Math.cos(this.X0);
    this.sinX0 = Math.sin(this.X0);
  }
}
function forward7(p) {
  var lon = p.x;
  var lat = p.y;
  var sinlat = Math.sin(lat);
  var coslat = Math.cos(lat);
  var A2, X, sinX, cosX, ts, rh;
  var dlon = adjust_lon_default(lon - this.long0);
  if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {
    p.x = NaN;
    p.y = NaN;
    return p;
  }
  if (this.sphere) {
    A2 = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));
    p.x = this.a * A2 * coslat * Math.sin(dlon) + this.x0;
    p.y = this.a * A2 * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;
    return p;
  } else {
    X = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - HALF_PI;
    cosX = Math.cos(X);
    sinX = Math.sin(X);
    if (Math.abs(this.coslat0) <= EPSLN) {
      ts = tsfnz_default(this.e, lat * this.con, this.con * sinlat);
      rh = 2 * this.a * this.k0 * ts / this.cons;
      p.x = this.x0 + rh * Math.sin(lon - this.long0);
      p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);
      return p;
    } else if (Math.abs(this.sinlat0) < EPSLN) {
      A2 = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));
      p.y = A2 * sinX;
    } else {
      A2 = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));
      p.y = A2 * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;
    }
    p.x = A2 * cosX * Math.sin(dlon) + this.x0;
  }
  return p;
}
function inverse7(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var lon, lat, ts, ce, Chi;
  var rh = Math.sqrt(p.x * p.x + p.y * p.y);
  if (this.sphere) {
    var c = 2 * Math.atan(rh / (2 * this.a * this.k0));
    lon = this.long0;
    lat = this.lat0;
    if (rh <= EPSLN) {
      p.x = lon;
      p.y = lat;
      return p;
    }
    lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh);
    if (Math.abs(this.coslat0) < EPSLN) {
      if (this.lat0 > 0) {
        lon = adjust_lon_default(this.long0 + Math.atan2(p.x, -1 * p.y));
      } else {
        lon = adjust_lon_default(this.long0 + Math.atan2(p.x, p.y));
      }
    } else {
      lon = adjust_lon_default(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c)));
    }
    p.x = lon;
    p.y = lat;
    return p;
  } else {
    if (Math.abs(this.coslat0) <= EPSLN) {
      if (rh <= EPSLN) {
        lat = this.lat0;
        lon = this.long0;
        p.x = lon;
        p.y = lat;
        return p;
      }
      p.x *= this.con;
      p.y *= this.con;
      ts = rh * this.cons / (2 * this.a * this.k0);
      lat = this.con * phi2z_default(this.e, ts);
      lon = this.con * adjust_lon_default(this.con * this.long0 + Math.atan2(p.x, -1 * p.y));
    } else {
      ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));
      lon = this.long0;
      if (rh <= EPSLN) {
        Chi = this.X0;
      } else {
        Chi = Math.asin(Math.cos(ce) * this.sinX0 + p.y * Math.sin(ce) * this.cosX0 / rh);
        lon = adjust_lon_default(this.long0 + Math.atan2(p.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p.y * this.sinX0 * Math.sin(ce)));
      }
      lat = -1 * phi2z_default(this.e, Math.tan(0.5 * (HALF_PI + Chi)));
    }
  }
  p.x = lon;
  p.y = lat;
  return p;
}
var names9, stere_default;
var init_stere = __esm({
  "node_modules/proj4/lib/projections/stere.js"() {
    init_values();
    init_sign();
    init_msfnz();
    init_tsfnz();
    init_phi2z();
    init_adjust_lon();
    names9 = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"];
    stere_default = {
      init: init8,
      forward: forward7,
      inverse: inverse7,
      names: names9,
      ssfn_
    };
  }
});

// node_modules/proj4/lib/projections/somerc.js
function init9() {
  var phy0 = this.lat0;
  this.lambda0 = this.long0;
  var sinPhy0 = Math.sin(phy0);
  var semiMajorAxis = this.a;
  var invF = this.rf;
  var flattening = 1 / invF;
  var e2 = 2 * flattening - Math.pow(flattening, 2);
  var e = this.e = Math.sqrt(e2);
  this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));
  this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));
  this.b0 = Math.asin(sinPhy0 / this.alpha);
  var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));
  var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));
  var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));
  this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;
}
function forward8(p) {
  var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));
  var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));
  var S = -this.alpha * (Sa1 + Sa2) + this.K;
  var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4);
  var I2 = this.alpha * (p.x - this.lambda0);
  var rotI = Math.atan(Math.sin(I2) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I2)));
  var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I2));
  p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;
  p.x = this.R * rotI + this.x0;
  return p;
}
function inverse8(p) {
  var Y = p.x - this.x0;
  var X = p.y - this.y0;
  var rotI = Y / this.R;
  var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);
  var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));
  var I2 = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));
  var lambda = this.lambda0 + I2 / this.alpha;
  var S = 0;
  var phy = b;
  var prevPhy = -1e3;
  var iteration = 0;
  while (Math.abs(phy - prevPhy) > 1e-7) {
    if (++iteration > 20) {
      return;
    }
    S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));
    prevPhy = phy;
    phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;
  }
  p.x = lambda;
  p.y = phy;
  return p;
}
var names10, somerc_default;
var init_somerc = __esm({
  "node_modules/proj4/lib/projections/somerc.js"() {
    names10 = ["somerc"];
    somerc_default = {
      init: init9,
      forward: forward8,
      inverse: inverse8,
      names: names10
    };
  }
});

// node_modules/proj4/lib/projections/omerc.js
function isTypeA(P) {
  var typeAProjections = ["Hotine_Oblique_Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin"];
  var projectionName = typeof P.PROJECTION === "object" ? Object.keys(P.PROJECTION)[0] : P.PROJECTION;
  return "no_uoff" in P || "no_off" in P || typeAProjections.indexOf(projectionName) !== -1;
}
function init10() {
  var con, com, cosph0, D, F, H, L3, sinph0, p, J, gamma = 0, gamma0, lamc = 0, lam1 = 0, lam2 = 0, phi1 = 0, phi2 = 0, alpha_c = 0, AB;
  this.no_off = isTypeA(this);
  this.no_rot = "no_rot" in this;
  var alp = false;
  if ("alpha" in this) {
    alp = true;
  }
  var gam = false;
  if ("rectified_grid_angle" in this) {
    gam = true;
  }
  if (alp) {
    alpha_c = this.alpha;
  }
  if (gam) {
    gamma = this.rectified_grid_angle * D2R;
  }
  if (alp || gam) {
    lamc = this.longc;
  } else {
    lam1 = this.long1;
    phi1 = this.lat1;
    lam2 = this.long2;
    phi2 = this.lat2;
    if (Math.abs(phi1 - phi2) <= TOL || (con = Math.abs(phi1)) <= TOL || Math.abs(con - HALF_PI) <= TOL || Math.abs(Math.abs(this.lat0) - HALF_PI) <= TOL || Math.abs(Math.abs(phi2) - HALF_PI) <= TOL) {
      throw new Error();
    }
  }
  var one_es = 1 - this.es;
  com = Math.sqrt(one_es);
  if (Math.abs(this.lat0) > EPSLN) {
    sinph0 = Math.sin(this.lat0);
    cosph0 = Math.cos(this.lat0);
    con = 1 - this.es * sinph0 * sinph0;
    this.B = cosph0 * cosph0;
    this.B = Math.sqrt(1 + this.es * this.B * this.B / one_es);
    this.A = this.B * this.k0 * com / con;
    D = this.B * com / (cosph0 * Math.sqrt(con));
    F = D * D - 1;
    if (F <= 0) {
      F = 0;
    } else {
      F = Math.sqrt(F);
      if (this.lat0 < 0) {
        F = -F;
      }
    }
    this.E = F += D;
    this.E *= Math.pow(tsfnz_default(this.e, this.lat0, sinph0), this.B);
  } else {
    this.B = 1 / com;
    this.A = this.k0;
    this.E = D = F = 1;
  }
  if (alp || gam) {
    if (alp) {
      gamma0 = Math.asin(Math.sin(alpha_c) / D);
      if (!gam) {
        gamma = alpha_c;
      }
    } else {
      gamma0 = gamma;
      alpha_c = Math.asin(D * Math.sin(gamma0));
    }
    this.lam0 = lamc - Math.asin(0.5 * (F - 1 / F) * Math.tan(gamma0)) / this.B;
  } else {
    H = Math.pow(tsfnz_default(this.e, phi1, Math.sin(phi1)), this.B);
    L3 = Math.pow(tsfnz_default(this.e, phi2, Math.sin(phi2)), this.B);
    F = this.E / H;
    p = (L3 - H) / (L3 + H);
    J = this.E * this.E;
    J = (J - L3 * H) / (J + L3 * H);
    con = lam1 - lam2;
    if (con < -Math.pi) {
      lam2 -= TWO_PI;
    } else if (con > Math.pi) {
      lam2 += TWO_PI;
    }
    this.lam0 = adjust_lon_default(0.5 * (lam1 + lam2) - Math.atan(J * Math.tan(0.5 * this.B * (lam1 - lam2)) / p) / this.B);
    gamma0 = Math.atan(2 * Math.sin(this.B * adjust_lon_default(lam1 - this.lam0)) / (F - 1 / F));
    gamma = alpha_c = Math.asin(D * Math.sin(gamma0));
  }
  this.singam = Math.sin(gamma0);
  this.cosgam = Math.cos(gamma0);
  this.sinrot = Math.sin(gamma);
  this.cosrot = Math.cos(gamma);
  this.rB = 1 / this.B;
  this.ArB = this.A * this.rB;
  this.BrA = 1 / this.ArB;
  AB = this.A * this.B;
  if (this.no_off) {
    this.u_0 = 0;
  } else {
    this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(D * D - 1) / Math.cos(alpha_c)));
    if (this.lat0 < 0) {
      this.u_0 = -this.u_0;
    }
  }
  F = 0.5 * gamma0;
  this.v_pole_n = this.ArB * Math.log(Math.tan(FORTPI - F));
  this.v_pole_s = this.ArB * Math.log(Math.tan(FORTPI + F));
}
function forward9(p) {
  var coords = {};
  var S, T, U, V2, W, temp, u, v;
  p.x = p.x - this.lam0;
  if (Math.abs(Math.abs(p.y) - HALF_PI) > EPSLN) {
    W = this.E / Math.pow(tsfnz_default(this.e, p.y, Math.sin(p.y)), this.B);
    temp = 1 / W;
    S = 0.5 * (W - temp);
    T = 0.5 * (W + temp);
    V2 = Math.sin(this.B * p.x);
    U = (S * this.singam - V2 * this.cosgam) / T;
    if (Math.abs(Math.abs(U) - 1) < EPSLN) {
      throw new Error();
    }
    v = 0.5 * this.ArB * Math.log((1 - U) / (1 + U));
    temp = Math.cos(this.B * p.x);
    if (Math.abs(temp) < TOL) {
      u = this.A * p.x;
    } else {
      u = this.ArB * Math.atan2(S * this.cosgam + V2 * this.singam, temp);
    }
  } else {
    v = p.y > 0 ? this.v_pole_n : this.v_pole_s;
    u = this.ArB * p.y;
  }
  if (this.no_rot) {
    coords.x = u;
    coords.y = v;
  } else {
    u -= this.u_0;
    coords.x = v * this.cosrot + u * this.sinrot;
    coords.y = u * this.cosrot - v * this.sinrot;
  }
  coords.x = this.a * coords.x + this.x0;
  coords.y = this.a * coords.y + this.y0;
  return coords;
}
function inverse9(p) {
  var u, v, Qp, Sp, Tp, Vp, Up;
  var coords = {};
  p.x = (p.x - this.x0) * (1 / this.a);
  p.y = (p.y - this.y0) * (1 / this.a);
  if (this.no_rot) {
    v = p.y;
    u = p.x;
  } else {
    v = p.x * this.cosrot - p.y * this.sinrot;
    u = p.y * this.cosrot + p.x * this.sinrot + this.u_0;
  }
  Qp = Math.exp(-this.BrA * v);
  Sp = 0.5 * (Qp - 1 / Qp);
  Tp = 0.5 * (Qp + 1 / Qp);
  Vp = Math.sin(this.BrA * u);
  Up = (Vp * this.cosgam + Sp * this.singam) / Tp;
  if (Math.abs(Math.abs(Up) - 1) < EPSLN) {
    coords.x = 0;
    coords.y = Up < 0 ? -HALF_PI : HALF_PI;
  } else {
    coords.y = this.E / Math.sqrt((1 + Up) / (1 - Up));
    coords.y = phi2z_default(this.e, Math.pow(coords.y, 1 / this.B));
    if (coords.y === Infinity) {
      throw new Error();
    }
    coords.x = -this.rB * Math.atan2(Sp * this.cosgam - Vp * this.singam, Math.cos(this.BrA * u));
  }
  coords.x += this.lam0;
  return coords;
}
var TOL, names11, omerc_default;
var init_omerc = __esm({
  "node_modules/proj4/lib/projections/omerc.js"() {
    init_tsfnz();
    init_adjust_lon();
    init_phi2z();
    init_values();
    TOL = 1e-7;
    names11 = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"];
    omerc_default = {
      init: init10,
      forward: forward9,
      inverse: inverse9,
      names: names11
    };
  }
});

// node_modules/proj4/lib/projections/lcc.js
function init11() {
  if (!this.lat2) {
    this.lat2 = this.lat1;
  }
  if (!this.k0) {
    this.k0 = 1;
  }
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }
  var temp = this.b / this.a;
  this.e = Math.sqrt(1 - temp * temp);
  var sin1 = Math.sin(this.lat1);
  var cos1 = Math.cos(this.lat1);
  var ms1 = msfnz_default(this.e, sin1, cos1);
  var ts1 = tsfnz_default(this.e, this.lat1, sin1);
  var sin2 = Math.sin(this.lat2);
  var cos2 = Math.cos(this.lat2);
  var ms2 = msfnz_default(this.e, sin2, cos2);
  var ts2 = tsfnz_default(this.e, this.lat2, sin2);
  var ts0 = tsfnz_default(this.e, this.lat0, Math.sin(this.lat0));
  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
    this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);
  } else {
    this.ns = sin1;
  }
  if (isNaN(this.ns)) {
    this.ns = sin1;
  }
  this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));
  this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);
  if (!this.title) {
    this.title = "Lambert Conformal Conic";
  }
}
function forward10(p) {
  var lon = p.x;
  var lat = p.y;
  if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {
    lat = sign_default(lat) * (HALF_PI - 2 * EPSLN);
  }
  var con = Math.abs(Math.abs(lat) - HALF_PI);
  var ts, rh1;
  if (con > EPSLN) {
    ts = tsfnz_default(this.e, lat, Math.sin(lat));
    rh1 = this.a * this.f0 * Math.pow(ts, this.ns);
  } else {
    con = lat * this.ns;
    if (con <= 0) {
      return null;
    }
    rh1 = 0;
  }
  var theta = this.ns * adjust_lon_default(lon - this.long0);
  p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;
  p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;
  return p;
}
function inverse10(p) {
  var rh1, con, ts;
  var lat, lon;
  var x = (p.x - this.x0) / this.k0;
  var y = this.rh - (p.y - this.y0) / this.k0;
  if (this.ns > 0) {
    rh1 = Math.sqrt(x * x + y * y);
    con = 1;
  } else {
    rh1 = -Math.sqrt(x * x + y * y);
    con = -1;
  }
  var theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * x, con * y);
  }
  if (rh1 !== 0 || this.ns > 0) {
    con = 1 / this.ns;
    ts = Math.pow(rh1 / (this.a * this.f0), con);
    lat = phi2z_default(this.e, ts);
    if (lat === -9999) {
      return null;
    }
  } else {
    lat = -HALF_PI;
  }
  lon = adjust_lon_default(theta / this.ns + this.long0);
  p.x = lon;
  p.y = lat;
  return p;
}
var names12, lcc_default;
var init_lcc = __esm({
  "node_modules/proj4/lib/projections/lcc.js"() {
    init_msfnz();
    init_tsfnz();
    init_sign();
    init_adjust_lon();
    init_phi2z();
    init_values();
    names12 = [
      "Lambert Tangential Conformal Conic Projection",
      "Lambert_Conformal_Conic",
      "Lambert_Conformal_Conic_1SP",
      "Lambert_Conformal_Conic_2SP",
      "lcc",
      "Lambert Conic Conformal (1SP)",
      "Lambert Conic Conformal (2SP)"
    ];
    lcc_default = {
      init: init11,
      forward: forward10,
      inverse: inverse10,
      names: names12
    };
  }
});

// node_modules/proj4/lib/projections/krovak.js
function init12() {
  this.a = 6377397155e-3;
  this.es = 0.006674372230614;
  this.e = Math.sqrt(this.es);
  if (!this.lat0) {
    this.lat0 = 0.863937979737193;
  }
  if (!this.long0) {
    this.long0 = 0.7417649320975901 - 0.308341501185665;
  }
  if (!this.k0) {
    this.k0 = 0.9999;
  }
  this.s45 = 0.785398163397448;
  this.s90 = 2 * this.s45;
  this.fi0 = this.lat0;
  this.e2 = this.es;
  this.e = Math.sqrt(this.e2);
  this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2));
  this.uq = 1.04216856380474;
  this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);
  this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);
  this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;
  this.k1 = this.k0;
  this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));
  this.s0 = 1.37008346281555;
  this.n = Math.sin(this.s0);
  this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);
  this.ad = this.s90 - this.uq;
}
function forward11(p) {
  var gfi, u, deltav, s, d, eps, ro;
  var lon = p.x;
  var lat = p.y;
  var delta_lon = adjust_lon_default(lon - this.long0);
  gfi = Math.pow((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat)), this.alfa * this.e / 2);
  u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);
  deltav = -delta_lon * this.alfa;
  s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));
  d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));
  eps = this.n * d;
  ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);
  p.y = ro * Math.cos(eps) / 1;
  p.x = ro * Math.sin(eps) / 1;
  if (!this.czech) {
    p.y *= -1;
    p.x *= -1;
  }
  return p;
}
function inverse11(p) {
  var u, deltav, s, d, eps, ro, fi1;
  var ok;
  var tmp = p.x;
  p.x = p.y;
  p.y = tmp;
  if (!this.czech) {
    p.y *= -1;
    p.x *= -1;
  }
  ro = Math.sqrt(p.x * p.x + p.y * p.y);
  eps = Math.atan2(p.y, p.x);
  d = eps / Math.sin(this.s0);
  s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);
  u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));
  deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u));
  p.x = this.long0 - deltav / this.alfa;
  fi1 = u;
  ok = 0;
  var iter = 0;
  do {
    p.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);
    if (Math.abs(fi1 - p.y) < 1e-10) {
      ok = 1;
    }
    fi1 = p.y;
    iter += 1;
  } while (ok === 0 && iter < 15);
  if (iter >= 15) {
    return null;
  }
  return p;
}
var names13, krovak_default;
var init_krovak = __esm({
  "node_modules/proj4/lib/projections/krovak.js"() {
    init_adjust_lon();
    names13 = ["Krovak", "krovak"];
    krovak_default = {
      init: init12,
      forward: forward11,
      inverse: inverse11,
      names: names13
    };
  }
});

// node_modules/proj4/lib/common/mlfn.js
function mlfn_default(e0, e1, e2, e3, phi) {
  return e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi);
}
var init_mlfn = __esm({
  "node_modules/proj4/lib/common/mlfn.js"() {
  }
});

// node_modules/proj4/lib/common/e0fn.js
function e0fn_default(x) {
  return 1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x));
}
var init_e0fn = __esm({
  "node_modules/proj4/lib/common/e0fn.js"() {
  }
});

// node_modules/proj4/lib/common/e1fn.js
function e1fn_default(x) {
  return 0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x));
}
var init_e1fn = __esm({
  "node_modules/proj4/lib/common/e1fn.js"() {
  }
});

// node_modules/proj4/lib/common/e2fn.js
function e2fn_default(x) {
  return 0.05859375 * x * x * (1 + 0.75 * x);
}
var init_e2fn = __esm({
  "node_modules/proj4/lib/common/e2fn.js"() {
  }
});

// node_modules/proj4/lib/common/e3fn.js
function e3fn_default(x) {
  return x * x * x * (35 / 3072);
}
var init_e3fn = __esm({
  "node_modules/proj4/lib/common/e3fn.js"() {
  }
});

// node_modules/proj4/lib/common/gN.js
function gN_default(a, e, sinphi) {
  var temp = e * sinphi;
  return a / Math.sqrt(1 - temp * temp);
}
var init_gN = __esm({
  "node_modules/proj4/lib/common/gN.js"() {
  }
});

// node_modules/proj4/lib/common/adjust_lat.js
function adjust_lat_default(x) {
  return Math.abs(x) < HALF_PI ? x : x - sign_default(x) * Math.PI;
}
var init_adjust_lat = __esm({
  "node_modules/proj4/lib/common/adjust_lat.js"() {
    init_values();
    init_sign();
  }
});

// node_modules/proj4/lib/common/imlfn.js
function imlfn_default(ml, e0, e1, e2, e3) {
  var phi;
  var dphi;
  phi = ml / e0;
  for (var i = 0; i < 15; i++) {
    dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));
    phi += dphi;
    if (Math.abs(dphi) <= 1e-10) {
      return phi;
    }
  }
  return NaN;
}
var init_imlfn = __esm({
  "node_modules/proj4/lib/common/imlfn.js"() {
  }
});

// node_modules/proj4/lib/projections/cass.js
function init13() {
  if (!this.sphere) {
    this.e0 = e0fn_default(this.es);
    this.e1 = e1fn_default(this.es);
    this.e2 = e2fn_default(this.es);
    this.e3 = e3fn_default(this.es);
    this.ml0 = this.a * mlfn_default(this.e0, this.e1, this.e2, this.e3, this.lat0);
  }
}
function forward12(p) {
  var x, y;
  var lam = p.x;
  var phi = p.y;
  lam = adjust_lon_default(lam - this.long0);
  if (this.sphere) {
    x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));
    y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);
  } else {
    var sinphi = Math.sin(phi);
    var cosphi = Math.cos(phi);
    var nl = gN_default(this.a, this.e, sinphi);
    var tl = Math.tan(phi) * Math.tan(phi);
    var al = lam * Math.cos(phi);
    var asq = al * al;
    var cl = this.es * cosphi * cosphi / (1 - this.es);
    var ml = this.a * mlfn_default(this.e0, this.e1, this.e2, this.e3, phi);
    x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));
    y = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);
  }
  p.x = x + this.x0;
  p.y = y + this.y0;
  return p;
}
function inverse12(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var x = p.x / this.a;
  var y = p.y / this.a;
  var phi, lam;
  if (this.sphere) {
    var dd = y + this.lat0;
    phi = Math.asin(Math.sin(dd) * Math.cos(x));
    lam = Math.atan2(Math.tan(x), Math.cos(dd));
  } else {
    var ml1 = this.ml0 / this.a + y;
    var phi1 = imlfn_default(ml1, this.e0, this.e1, this.e2, this.e3);
    if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {
      p.x = this.long0;
      p.y = HALF_PI;
      if (y < 0) {
        p.y *= -1;
      }
      return p;
    }
    var nl1 = gN_default(this.a, this.e, Math.sin(phi1));
    var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);
    var tl1 = Math.pow(Math.tan(phi1), 2);
    var dl = x * this.a / nl1;
    var dsq = dl * dl;
    phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);
    lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);
  }
  p.x = adjust_lon_default(lam + this.long0);
  p.y = adjust_lat_default(phi);
  return p;
}
var names14, cass_default;
var init_cass = __esm({
  "node_modules/proj4/lib/projections/cass.js"() {
    init_mlfn();
    init_e0fn();
    init_e1fn();
    init_e2fn();
    init_e3fn();
    init_gN();
    init_adjust_lon();
    init_adjust_lat();
    init_imlfn();
    init_values();
    names14 = ["Cassini", "Cassini_Soldner", "cass"];
    cass_default = {
      init: init13,
      forward: forward12,
      inverse: inverse12,
      names: names14
    };
  }
});

// node_modules/proj4/lib/common/qsfnz.js
function qsfnz_default(eccent, sinphi) {
  var con;
  if (eccent > 1e-7) {
    con = eccent * sinphi;
    return (1 - eccent * eccent) * (sinphi / (1 - con * con) - 0.5 / eccent * Math.log((1 - con) / (1 + con)));
  } else {
    return 2 * sinphi;
  }
}
var init_qsfnz = __esm({
  "node_modules/proj4/lib/common/qsfnz.js"() {
  }
});

// node_modules/proj4/lib/projections/laea.js
function init14() {
  var t = Math.abs(this.lat0);
  if (Math.abs(t - HALF_PI) < EPSLN) {
    this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;
  } else if (Math.abs(t) < EPSLN) {
    this.mode = this.EQUIT;
  } else {
    this.mode = this.OBLIQ;
  }
  if (this.es > 0) {
    var sinphi;
    this.qp = qsfnz_default(this.e, 1);
    this.mmf = 0.5 / (1 - this.es);
    this.apa = authset(this.es);
    switch (this.mode) {
      case this.N_POLE:
        this.dd = 1;
        break;
      case this.S_POLE:
        this.dd = 1;
        break;
      case this.EQUIT:
        this.rq = Math.sqrt(0.5 * this.qp);
        this.dd = 1 / this.rq;
        this.xmf = 1;
        this.ymf = 0.5 * this.qp;
        break;
      case this.OBLIQ:
        this.rq = Math.sqrt(0.5 * this.qp);
        sinphi = Math.sin(this.lat0);
        this.sinb1 = qsfnz_default(this.e, sinphi) / this.qp;
        this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);
        this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);
        this.ymf = (this.xmf = this.rq) / this.dd;
        this.xmf *= this.dd;
        break;
    }
  } else {
    if (this.mode === this.OBLIQ) {
      this.sinph0 = Math.sin(this.lat0);
      this.cosph0 = Math.cos(this.lat0);
    }
  }
}
function forward13(p) {
  var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;
  var lam = p.x;
  var phi = p.y;
  lam = adjust_lon_default(lam - this.long0);
  if (this.sphere) {
    sinphi = Math.sin(phi);
    cosphi = Math.cos(phi);
    coslam = Math.cos(lam);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      y = this.mode === this.EQUIT ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
      if (y <= EPSLN) {
        return null;
      }
      y = Math.sqrt(2 / y);
      x = y * cosphi * Math.sin(lam);
      y *= this.mode === this.EQUIT ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE) {
        coslam = -coslam;
      }
      if (Math.abs(phi + this.lat0) < EPSLN) {
        return null;
      }
      y = FORTPI - phi * 0.5;
      y = 2 * (this.mode === this.S_POLE ? Math.cos(y) : Math.sin(y));
      x = y * Math.sin(lam);
      y *= coslam;
    }
  } else {
    sinb = 0;
    cosb = 0;
    b = 0;
    coslam = Math.cos(lam);
    sinlam = Math.sin(lam);
    sinphi = Math.sin(phi);
    q = qsfnz_default(this.e, sinphi);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      sinb = q / this.qp;
      cosb = Math.sqrt(1 - sinb * sinb);
    }
    switch (this.mode) {
      case this.OBLIQ:
        b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
        break;
      case this.EQUIT:
        b = 1 + cosb * coslam;
        break;
      case this.N_POLE:
        b = HALF_PI + phi;
        q = this.qp - q;
        break;
      case this.S_POLE:
        b = phi - HALF_PI;
        q = this.qp + q;
        break;
    }
    if (Math.abs(b) < EPSLN) {
      return null;
    }
    switch (this.mode) {
      case this.OBLIQ:
      case this.EQUIT:
        b = Math.sqrt(2 / b);
        if (this.mode === this.OBLIQ) {
          y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);
        } else {
          y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;
        }
        x = this.xmf * b * cosb * sinlam;
        break;
      case this.N_POLE:
      case this.S_POLE:
        if (q >= 0) {
          x = (b = Math.sqrt(q)) * sinlam;
          y = coslam * (this.mode === this.S_POLE ? b : -b);
        } else {
          x = y = 0;
        }
        break;
    }
  }
  p.x = this.a * x + this.x0;
  p.y = this.a * y + this.y0;
  return p;
}
function inverse13(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var x = p.x / this.a;
  var y = p.y / this.a;
  var lam, phi, cCe, sCe, q, rho, ab;
  if (this.sphere) {
    var cosz = 0, rh, sinz = 0;
    rh = Math.sqrt(x * x + y * y);
    phi = rh * 0.5;
    if (phi > 1) {
      return null;
    }
    phi = 2 * Math.asin(phi);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      sinz = Math.sin(phi);
      cosz = Math.cos(phi);
    }
    switch (this.mode) {
      case this.EQUIT:
        phi = Math.abs(rh) <= EPSLN ? 0 : Math.asin(y * sinz / rh);
        x *= sinz;
        y = cosz * rh;
        break;
      case this.OBLIQ:
        phi = Math.abs(rh) <= EPSLN ? this.lat0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);
        x *= sinz * this.cosph0;
        y = (cosz - Math.sin(phi) * this.sinph0) * rh;
        break;
      case this.N_POLE:
        y = -y;
        phi = HALF_PI - phi;
        break;
      case this.S_POLE:
        phi -= HALF_PI;
        break;
    }
    lam = y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ) ? 0 : Math.atan2(x, y);
  } else {
    ab = 0;
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      x /= this.dd;
      y *= this.dd;
      rho = Math.sqrt(x * x + y * y);
      if (rho < EPSLN) {
        p.x = this.long0;
        p.y = this.lat0;
        return p;
      }
      sCe = 2 * Math.asin(0.5 * rho / this.rq);
      cCe = Math.cos(sCe);
      x *= sCe = Math.sin(sCe);
      if (this.mode === this.OBLIQ) {
        ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;
        q = this.qp * ab;
        y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;
      } else {
        ab = y * sCe / rho;
        q = this.qp * ab;
        y = rho * cCe;
      }
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE) {
        y = -y;
      }
      q = x * x + y * y;
      if (!q) {
        p.x = this.long0;
        p.y = this.lat0;
        return p;
      }
      ab = 1 - q / this.qp;
      if (this.mode === this.S_POLE) {
        ab = -ab;
      }
    }
    lam = Math.atan2(x, y);
    phi = authlat(Math.asin(ab), this.apa);
  }
  p.x = adjust_lon_default(this.long0 + lam);
  p.y = phi;
  return p;
}
function authset(es) {
  var t;
  var APA = [];
  APA[0] = es * P00;
  t = es * es;
  APA[0] += t * P01;
  APA[1] = t * P10;
  t *= es;
  APA[0] += t * P02;
  APA[1] += t * P11;
  APA[2] = t * P20;
  return APA;
}
function authlat(beta, APA) {
  var t = beta + beta;
  return beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t);
}
var S_POLE, N_POLE, EQUIT, OBLIQ, P00, P01, P02, P10, P11, P20, names15, laea_default;
var init_laea = __esm({
  "node_modules/proj4/lib/projections/laea.js"() {
    init_values();
    init_qsfnz();
    init_adjust_lon();
    S_POLE = 1;
    N_POLE = 2;
    EQUIT = 3;
    OBLIQ = 4;
    P00 = 0.3333333333333333;
    P01 = 0.17222222222222222;
    P02 = 0.10257936507936508;
    P10 = 0.06388888888888888;
    P11 = 0.0664021164021164;
    P20 = 0.016415012942191543;
    names15 = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
    laea_default = {
      init: init14,
      forward: forward13,
      inverse: inverse13,
      names: names15,
      S_POLE,
      N_POLE,
      EQUIT,
      OBLIQ
    };
  }
});

// node_modules/proj4/lib/common/asinz.js
function asinz_default(x) {
  if (Math.abs(x) > 1) {
    x = x > 1 ? 1 : -1;
  }
  return Math.asin(x);
}
var init_asinz = __esm({
  "node_modules/proj4/lib/common/asinz.js"() {
  }
});

// node_modules/proj4/lib/projections/aea.js
function init15() {
  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e3 = Math.sqrt(this.es);
  this.sin_po = Math.sin(this.lat1);
  this.cos_po = Math.cos(this.lat1);
  this.t1 = this.sin_po;
  this.con = this.sin_po;
  this.ms1 = msfnz_default(this.e3, this.sin_po, this.cos_po);
  this.qs1 = qsfnz_default(this.e3, this.sin_po);
  this.sin_po = Math.sin(this.lat2);
  this.cos_po = Math.cos(this.lat2);
  this.t2 = this.sin_po;
  this.ms2 = msfnz_default(this.e3, this.sin_po, this.cos_po);
  this.qs2 = qsfnz_default(this.e3, this.sin_po);
  this.sin_po = Math.sin(this.lat0);
  this.cos_po = Math.cos(this.lat0);
  this.t3 = this.sin_po;
  this.qs0 = qsfnz_default(this.e3, this.sin_po);
  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
    this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);
  } else {
    this.ns0 = this.con;
  }
  this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;
  this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;
}
function forward14(p) {
  var lon = p.x;
  var lat = p.y;
  this.sin_phi = Math.sin(lat);
  this.cos_phi = Math.cos(lat);
  var qs = qsfnz_default(this.e3, this.sin_phi);
  var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;
  var theta = this.ns0 * adjust_lon_default(lon - this.long0);
  var x = rh1 * Math.sin(theta) + this.x0;
  var y = this.rh - rh1 * Math.cos(theta) + this.y0;
  p.x = x;
  p.y = y;
  return p;
}
function inverse14(p) {
  var rh1, qs, con, theta, lon, lat;
  p.x -= this.x0;
  p.y = this.rh - p.y + this.y0;
  if (this.ns0 >= 0) {
    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
    con = 1;
  } else {
    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
    con = -1;
  }
  theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * p.x, con * p.y);
  }
  con = rh1 * this.ns0 / this.a;
  if (this.sphere) {
    lat = Math.asin((this.c - con * con) / (2 * this.ns0));
  } else {
    qs = (this.c - con * con) / this.ns0;
    lat = this.phi1z(this.e3, qs);
  }
  lon = adjust_lon_default(theta / this.ns0 + this.long0);
  p.x = lon;
  p.y = lat;
  return p;
}
function phi1z(eccent, qs) {
  var sinphi, cosphi, con, com, dphi;
  var phi = asinz_default(0.5 * qs);
  if (eccent < EPSLN) {
    return phi;
  }
  var eccnts = eccent * eccent;
  for (var i = 1; i <= 25; i++) {
    sinphi = Math.sin(phi);
    cosphi = Math.cos(phi);
    con = eccent * sinphi;
    com = 1 - con * con;
    dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    phi = phi + dphi;
    if (Math.abs(dphi) <= 1e-7) {
      return phi;
    }
  }
  return null;
}
var names16, aea_default;
var init_aea = __esm({
  "node_modules/proj4/lib/projections/aea.js"() {
    init_msfnz();
    init_qsfnz();
    init_adjust_lon();
    init_asinz();
    init_values();
    names16 = ["Albers_Conic_Equal_Area", "Albers", "aea"];
    aea_default = {
      init: init15,
      forward: forward14,
      inverse: inverse14,
      names: names16,
      phi1z
    };
  }
});

// node_modules/proj4/lib/projections/gnom.js
function init16() {
  this.sin_p14 = Math.sin(this.lat0);
  this.cos_p14 = Math.cos(this.lat0);
  this.infinity_dist = 1e3 * this.a;
  this.rc = 1;
}
function forward15(p) {
  var sinphi, cosphi;
  var dlon;
  var coslon;
  var ksp;
  var g;
  var x, y;
  var lon = p.x;
  var lat = p.y;
  dlon = adjust_lon_default(lon - this.long0);
  sinphi = Math.sin(lat);
  cosphi = Math.cos(lat);
  coslon = Math.cos(dlon);
  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
  ksp = 1;
  if (g > 0 || Math.abs(g) <= EPSLN) {
    x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;
    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;
  } else {
    x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);
    y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
  }
  p.x = x;
  p.y = y;
  return p;
}
function inverse15(p) {
  var rh;
  var sinc, cosc;
  var c;
  var lon, lat;
  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;
  p.x /= this.k0;
  p.y /= this.k0;
  if (rh = Math.sqrt(p.x * p.x + p.y * p.y)) {
    c = Math.atan2(rh, this.rc);
    sinc = Math.sin(c);
    cosc = Math.cos(c);
    lat = asinz_default(cosc * this.sin_p14 + p.y * sinc * this.cos_p14 / rh);
    lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);
    lon = adjust_lon_default(this.long0 + lon);
  } else {
    lat = this.phic0;
    lon = 0;
  }
  p.x = lon;
  p.y = lat;
  return p;
}
var names17, gnom_default;
var init_gnom = __esm({
  "node_modules/proj4/lib/projections/gnom.js"() {
    init_adjust_lon();
    init_asinz();
    init_values();
    names17 = ["gnom"];
    gnom_default = {
      init: init16,
      forward: forward15,
      inverse: inverse15,
      names: names17
    };
  }
});

// node_modules/proj4/lib/common/iqsfnz.js
function iqsfnz_default(eccent, q) {
  var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));
  if (Math.abs(Math.abs(q) - temp) < 1e-6) {
    if (q < 0) {
      return -1 * HALF_PI;
    } else {
      return HALF_PI;
    }
  }
  var phi = Math.asin(0.5 * q);
  var dphi;
  var sin_phi;
  var cos_phi;
  var con;
  for (var i = 0; i < 30; i++) {
    sin_phi = Math.sin(phi);
    cos_phi = Math.cos(phi);
    con = eccent * sin_phi;
    dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    phi += dphi;
    if (Math.abs(dphi) <= 1e-10) {
      return phi;
    }
  }
  return NaN;
}
var init_iqsfnz = __esm({
  "node_modules/proj4/lib/common/iqsfnz.js"() {
    init_values();
  }
});

// node_modules/proj4/lib/projections/cea.js
function init17() {
  if (!this.sphere) {
    this.k0 = msfnz_default(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
  }
}
function forward16(p) {
  var lon = p.x;
  var lat = p.y;
  var x, y;
  var dlon = adjust_lon_default(lon - this.long0);
  if (this.sphere) {
    x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);
    y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);
  } else {
    var qs = qsfnz_default(this.e, Math.sin(lat));
    x = this.x0 + this.a * this.k0 * dlon;
    y = this.y0 + this.a * qs * 0.5 / this.k0;
  }
  p.x = x;
  p.y = y;
  return p;
}
function inverse16(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var lon, lat;
  if (this.sphere) {
    lon = adjust_lon_default(this.long0 + p.x / this.a / Math.cos(this.lat_ts));
    lat = Math.asin(p.y / this.a * Math.cos(this.lat_ts));
  } else {
    lat = iqsfnz_default(this.e, 2 * p.y * this.k0 / this.a);
    lon = adjust_lon_default(this.long0 + p.x / (this.a * this.k0));
  }
  p.x = lon;
  p.y = lat;
  return p;
}
var names18, cea_default;
var init_cea = __esm({
  "node_modules/proj4/lib/projections/cea.js"() {
    init_adjust_lon();
    init_qsfnz();
    init_msfnz();
    init_iqsfnz();
    names18 = ["cea"];
    cea_default = {
      init: init17,
      forward: forward16,
      inverse: inverse16,
      names: names18
    };
  }
});

// node_modules/proj4/lib/projections/eqc.js
function init18() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.lat_ts = this.lat_ts || 0;
  this.title = this.title || "Equidistant Cylindrical (Plate Carre)";
  this.rc = Math.cos(this.lat_ts);
}
function forward17(p) {
  var lon = p.x;
  var lat = p.y;
  var dlon = adjust_lon_default(lon - this.long0);
  var dlat = adjust_lat_default(lat - this.lat0);
  p.x = this.x0 + this.a * dlon * this.rc;
  p.y = this.y0 + this.a * dlat;
  return p;
}
function inverse17(p) {
  var x = p.x;
  var y = p.y;
  p.x = adjust_lon_default(this.long0 + (x - this.x0) / (this.a * this.rc));
  p.y = adjust_lat_default(this.lat0 + (y - this.y0) / this.a);
  return p;
}
var names19, eqc_default;
var init_eqc = __esm({
  "node_modules/proj4/lib/projections/eqc.js"() {
    init_adjust_lon();
    init_adjust_lat();
    names19 = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
    eqc_default = {
      init: init18,
      forward: forward17,
      inverse: inverse17,
      names: names19
    };
  }
});

// node_modules/proj4/lib/projections/poly.js
function init19() {
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e = Math.sqrt(this.es);
  this.e0 = e0fn_default(this.es);
  this.e1 = e1fn_default(this.es);
  this.e2 = e2fn_default(this.es);
  this.e3 = e3fn_default(this.es);
  this.ml0 = this.a * mlfn_default(this.e0, this.e1, this.e2, this.e3, this.lat0);
}
function forward18(p) {
  var lon = p.x;
  var lat = p.y;
  var x, y, el;
  var dlon = adjust_lon_default(lon - this.long0);
  el = dlon * Math.sin(lat);
  if (this.sphere) {
    if (Math.abs(lat) <= EPSLN) {
      x = this.a * dlon;
      y = -1 * this.a * this.lat0;
    } else {
      x = this.a * Math.sin(el) / Math.tan(lat);
      y = this.a * (adjust_lat_default(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));
    }
  } else {
    if (Math.abs(lat) <= EPSLN) {
      x = this.a * dlon;
      y = -1 * this.ml0;
    } else {
      var nl = gN_default(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
      x = nl * Math.sin(el);
      y = this.a * mlfn_default(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
    }
  }
  p.x = x + this.x0;
  p.y = y + this.y0;
  return p;
}
function inverse18(p) {
  var lon, lat, x, y, i;
  var al, bl;
  var phi, dphi;
  x = p.x - this.x0;
  y = p.y - this.y0;
  if (this.sphere) {
    if (Math.abs(y + this.a * this.lat0) <= EPSLN) {
      lon = adjust_lon_default(x / this.a + this.long0);
      lat = 0;
    } else {
      al = this.lat0 + y / this.a;
      bl = x * x / this.a / this.a + al * al;
      phi = al;
      var tanphi;
      for (i = MAX_ITER3; i; --i) {
        tanphi = Math.tan(phi);
        dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);
        phi += dphi;
        if (Math.abs(dphi) <= EPSLN) {
          lat = phi;
          break;
        }
      }
      lon = adjust_lon_default(this.long0 + Math.asin(x * Math.tan(phi) / this.a) / Math.sin(lat));
    }
  } else {
    if (Math.abs(y + this.ml0) <= EPSLN) {
      lat = 0;
      lon = adjust_lon_default(this.long0 + x / this.a);
    } else {
      al = (this.ml0 + y) / this.a;
      bl = x * x / this.a / this.a + al * al;
      phi = al;
      var cl, mln, mlnp, ma;
      var con;
      for (i = MAX_ITER3; i; --i) {
        con = this.e * Math.sin(phi);
        cl = Math.sqrt(1 - con * con) * Math.tan(phi);
        mln = this.a * mlfn_default(this.e0, this.e1, this.e2, this.e3, phi);
        mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);
        ma = mln / this.a;
        dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);
        phi -= dphi;
        if (Math.abs(dphi) <= EPSLN) {
          lat = phi;
          break;
        }
      }
      cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);
      lon = adjust_lon_default(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));
    }
  }
  p.x = lon;
  p.y = lat;
  return p;
}
var MAX_ITER3, names20, poly_default;
var init_poly = __esm({
  "node_modules/proj4/lib/projections/poly.js"() {
    init_e0fn();
    init_e1fn();
    init_e2fn();
    init_e3fn();
    init_adjust_lon();
    init_adjust_lat();
    init_mlfn();
    init_values();
    init_gN();
    MAX_ITER3 = 20;
    names20 = ["Polyconic", "poly"];
    poly_default = {
      init: init19,
      forward: forward18,
      inverse: inverse18,
      names: names20
    };
  }
});

// node_modules/proj4/lib/projections/nzmg.js
function init20() {
  this.A = [];
  this.A[1] = 0.6399175073;
  this.A[2] = -0.1358797613;
  this.A[3] = 0.063294409;
  this.A[4] = -0.02526853;
  this.A[5] = 0.0117879;
  this.A[6] = -55161e-7;
  this.A[7] = 26906e-7;
  this.A[8] = -1333e-6;
  this.A[9] = 67e-5;
  this.A[10] = -34e-5;
  this.B_re = [];
  this.B_im = [];
  this.B_re[1] = 0.7557853228;
  this.B_im[1] = 0;
  this.B_re[2] = 0.249204646;
  this.B_im[2] = 3371507e-9;
  this.B_re[3] = -1541739e-9;
  this.B_im[3] = 0.04105856;
  this.B_re[4] = -0.10162907;
  this.B_im[4] = 0.01727609;
  this.B_re[5] = -0.26623489;
  this.B_im[5] = -0.36249218;
  this.B_re[6] = -0.6870983;
  this.B_im[6] = -1.1651967;
  this.C_re = [];
  this.C_im = [];
  this.C_re[1] = 1.3231270439;
  this.C_im[1] = 0;
  this.C_re[2] = -0.577245789;
  this.C_im[2] = -7809598e-9;
  this.C_re[3] = 0.508307513;
  this.C_im[3] = -0.112208952;
  this.C_re[4] = -0.15094762;
  this.C_im[4] = 0.18200602;
  this.C_re[5] = 1.01418179;
  this.C_im[5] = 1.64497696;
  this.C_re[6] = 1.9660549;
  this.C_im[6] = 2.5127645;
  this.D = [];
  this.D[1] = 1.5627014243;
  this.D[2] = 0.5185406398;
  this.D[3] = -0.03333098;
  this.D[4] = -0.1052906;
  this.D[5] = -0.0368594;
  this.D[6] = 7317e-6;
  this.D[7] = 0.0122;
  this.D[8] = 394e-5;
  this.D[9] = -13e-4;
}
function forward19(p) {
  var n;
  var lon = p.x;
  var lat = p.y;
  var delta_lat = lat - this.lat0;
  var delta_lon = lon - this.long0;
  var d_phi = delta_lat / SEC_TO_RAD * 1e-5;
  var d_lambda = delta_lon;
  var d_phi_n = 1;
  var d_psi = 0;
  for (n = 1; n <= 10; n++) {
    d_phi_n = d_phi_n * d_phi;
    d_psi = d_psi + this.A[n] * d_phi_n;
  }
  var th_re = d_psi;
  var th_im = d_lambda;
  var th_n_re = 1;
  var th_n_im = 0;
  var th_n_re1;
  var th_n_im1;
  var z_re = 0;
  var z_im = 0;
  for (n = 1; n <= 6; n++) {
    th_n_re1 = th_n_re * th_re - th_n_im * th_im;
    th_n_im1 = th_n_im * th_re + th_n_re * th_im;
    th_n_re = th_n_re1;
    th_n_im = th_n_im1;
    z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;
    z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;
  }
  p.x = z_im * this.a + this.x0;
  p.y = z_re * this.a + this.y0;
  return p;
}
function inverse19(p) {
  var n;
  var x = p.x;
  var y = p.y;
  var delta_x = x - this.x0;
  var delta_y = y - this.y0;
  var z_re = delta_y / this.a;
  var z_im = delta_x / this.a;
  var z_n_re = 1;
  var z_n_im = 0;
  var z_n_re1;
  var z_n_im1;
  var th_re = 0;
  var th_im = 0;
  for (n = 1; n <= 6; n++) {
    z_n_re1 = z_n_re * z_re - z_n_im * z_im;
    z_n_im1 = z_n_im * z_re + z_n_re * z_im;
    z_n_re = z_n_re1;
    z_n_im = z_n_im1;
    th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;
    th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;
  }
  for (var i = 0; i < this.iterations; i++) {
    var th_n_re = th_re;
    var th_n_im = th_im;
    var th_n_re1;
    var th_n_im1;
    var num_re = z_re;
    var num_im = z_im;
    for (n = 2; n <= 6; n++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
      num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
    }
    th_n_re = 1;
    th_n_im = 0;
    var den_re = this.B_re[1];
    var den_im = this.B_im[1];
    for (n = 2; n <= 6; n++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
      den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
    }
    var den2 = den_re * den_re + den_im * den_im;
    th_re = (num_re * den_re + num_im * den_im) / den2;
    th_im = (num_im * den_re - num_re * den_im) / den2;
  }
  var d_psi = th_re;
  var d_lambda = th_im;
  var d_psi_n = 1;
  var d_phi = 0;
  for (n = 1; n <= 9; n++) {
    d_psi_n = d_psi_n * d_psi;
    d_phi = d_phi + this.D[n] * d_psi_n;
  }
  var lat = this.lat0 + d_phi * SEC_TO_RAD * 1e5;
  var lon = this.long0 + d_lambda;
  p.x = lon;
  p.y = lat;
  return p;
}
var names21, nzmg_default;
var init_nzmg = __esm({
  "node_modules/proj4/lib/projections/nzmg.js"() {
    init_values();
    names21 = ["New_Zealand_Map_Grid", "nzmg"];
    nzmg_default = {
      init: init20,
      forward: forward19,
      inverse: inverse19,
      names: names21
    };
  }
});

// node_modules/proj4/lib/projections/mill.js
function init21() {
}
function forward20(p) {
  var lon = p.x;
  var lat = p.y;
  var dlon = adjust_lon_default(lon - this.long0);
  var x = this.x0 + this.a * dlon;
  var y = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + lat / 2.5)) * 1.25;
  p.x = x;
  p.y = y;
  return p;
}
function inverse20(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var lon = adjust_lon_default(this.long0 + p.x / this.a);
  var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);
  p.x = lon;
  p.y = lat;
  return p;
}
var names22, mill_default;
var init_mill = __esm({
  "node_modules/proj4/lib/projections/mill.js"() {
    init_adjust_lon();
    names22 = ["Miller_Cylindrical", "mill"];
    mill_default = {
      init: init21,
      forward: forward20,
      inverse: inverse20,
      names: names22
    };
  }
});

// node_modules/proj4/lib/projections/sinu.js
function init22() {
  if (!this.sphere) {
    this.en = pj_enfn_default(this.es);
  } else {
    this.n = 1;
    this.m = 0;
    this.es = 0;
    this.C_y = Math.sqrt((this.m + 1) / this.n);
    this.C_x = this.C_y / (this.m + 1);
  }
}
function forward21(p) {
  var x, y;
  var lon = p.x;
  var lat = p.y;
  lon = adjust_lon_default(lon - this.long0);
  if (this.sphere) {
    if (!this.m) {
      lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;
    } else {
      var k = this.n * Math.sin(lat);
      for (var i = MAX_ITER4; i; --i) {
        var V2 = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));
        lat -= V2;
        if (Math.abs(V2) < EPSLN) {
          break;
        }
      }
    }
    x = this.a * this.C_x * lon * (this.m + Math.cos(lat));
    y = this.a * this.C_y * lat;
  } else {
    var s = Math.sin(lat);
    var c = Math.cos(lat);
    y = this.a * pj_mlfn_default(lat, s, c, this.en);
    x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);
  }
  p.x = x;
  p.y = y;
  return p;
}
function inverse21(p) {
  var lat, temp, lon, s;
  p.x -= this.x0;
  lon = p.x / this.a;
  p.y -= this.y0;
  lat = p.y / this.a;
  if (this.sphere) {
    lat /= this.C_y;
    lon = lon / (this.C_x * (this.m + Math.cos(lat)));
    if (this.m) {
      lat = asinz_default((this.m * lat + Math.sin(lat)) / this.n);
    } else if (this.n !== 1) {
      lat = asinz_default(Math.sin(lat) / this.n);
    }
    lon = adjust_lon_default(lon + this.long0);
    lat = adjust_lat_default(lat);
  } else {
    lat = pj_inv_mlfn_default(p.y / this.a, this.es, this.en);
    s = Math.abs(lat);
    if (s < HALF_PI) {
      s = Math.sin(lat);
      temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat));
      lon = adjust_lon_default(temp);
    } else if (s - EPSLN < HALF_PI) {
      lon = this.long0;
    }
  }
  p.x = lon;
  p.y = lat;
  return p;
}
var MAX_ITER4, names23, sinu_default;
var init_sinu = __esm({
  "node_modules/proj4/lib/projections/sinu.js"() {
    init_adjust_lon();
    init_adjust_lat();
    init_pj_enfn();
    init_pj_mlfn();
    init_pj_inv_mlfn();
    init_values();
    init_asinz();
    MAX_ITER4 = 20;
    names23 = ["Sinusoidal", "sinu"];
    sinu_default = {
      init: init22,
      forward: forward21,
      inverse: inverse21,
      names: names23
    };
  }
});

// node_modules/proj4/lib/projections/moll.js
function init23() {
}
function forward22(p) {
  var lon = p.x;
  var lat = p.y;
  var delta_lon = adjust_lon_default(lon - this.long0);
  var theta = lat;
  var con = Math.PI * Math.sin(lat);
  while (true) {
    var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
    theta += delta_theta;
    if (Math.abs(delta_theta) < EPSLN) {
      break;
    }
  }
  theta /= 2;
  if (Math.PI / 2 - Math.abs(lat) < EPSLN) {
    delta_lon = 0;
  }
  var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;
  var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;
  p.x = x;
  p.y = y;
  return p;
}
function inverse22(p) {
  var theta;
  var arg;
  p.x -= this.x0;
  p.y -= this.y0;
  arg = p.y / (1.4142135623731 * this.a);
  if (Math.abs(arg) > 0.999999999999) {
    arg = 0.999999999999;
  }
  theta = Math.asin(arg);
  var lon = adjust_lon_default(this.long0 + p.x / (0.900316316158 * this.a * Math.cos(theta)));
  if (lon < -Math.PI) {
    lon = -Math.PI;
  }
  if (lon > Math.PI) {
    lon = Math.PI;
  }
  arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;
  if (Math.abs(arg) > 1) {
    arg = 1;
  }
  var lat = Math.asin(arg);
  p.x = lon;
  p.y = lat;
  return p;
}
var names24, moll_default;
var init_moll = __esm({
  "node_modules/proj4/lib/projections/moll.js"() {
    init_adjust_lon();
    init_values();
    names24 = ["Mollweide", "moll"];
    moll_default = {
      init: init23,
      forward: forward22,
      inverse: inverse22,
      names: names24
    };
  }
});

// node_modules/proj4/lib/projections/eqdc.js
function init24() {
  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }
  this.lat2 = this.lat2 || this.lat1;
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e = Math.sqrt(this.es);
  this.e0 = e0fn_default(this.es);
  this.e1 = e1fn_default(this.es);
  this.e2 = e2fn_default(this.es);
  this.e3 = e3fn_default(this.es);
  this.sinphi = Math.sin(this.lat1);
  this.cosphi = Math.cos(this.lat1);
  this.ms1 = msfnz_default(this.e, this.sinphi, this.cosphi);
  this.ml1 = mlfn_default(this.e0, this.e1, this.e2, this.e3, this.lat1);
  if (Math.abs(this.lat1 - this.lat2) < EPSLN) {
    this.ns = this.sinphi;
  } else {
    this.sinphi = Math.sin(this.lat2);
    this.cosphi = Math.cos(this.lat2);
    this.ms2 = msfnz_default(this.e, this.sinphi, this.cosphi);
    this.ml2 = mlfn_default(this.e0, this.e1, this.e2, this.e3, this.lat2);
    this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);
  }
  this.g = this.ml1 + this.ms1 / this.ns;
  this.ml0 = mlfn_default(this.e0, this.e1, this.e2, this.e3, this.lat0);
  this.rh = this.a * (this.g - this.ml0);
}
function forward23(p) {
  var lon = p.x;
  var lat = p.y;
  var rh1;
  if (this.sphere) {
    rh1 = this.a * (this.g - lat);
  } else {
    var ml = mlfn_default(this.e0, this.e1, this.e2, this.e3, lat);
    rh1 = this.a * (this.g - ml);
  }
  var theta = this.ns * adjust_lon_default(lon - this.long0);
  var x = this.x0 + rh1 * Math.sin(theta);
  var y = this.y0 + this.rh - rh1 * Math.cos(theta);
  p.x = x;
  p.y = y;
  return p;
}
function inverse23(p) {
  p.x -= this.x0;
  p.y = this.rh - p.y + this.y0;
  var con, rh1, lat, lon;
  if (this.ns >= 0) {
    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
    con = 1;
  } else {
    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
    con = -1;
  }
  var theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * p.x, con * p.y);
  }
  if (this.sphere) {
    lon = adjust_lon_default(this.long0 + theta / this.ns);
    lat = adjust_lat_default(this.g - rh1 / this.a);
    p.x = lon;
    p.y = lat;
    return p;
  } else {
    var ml = this.g - rh1 / this.a;
    lat = imlfn_default(ml, this.e0, this.e1, this.e2, this.e3);
    lon = adjust_lon_default(this.long0 + theta / this.ns);
    p.x = lon;
    p.y = lat;
    return p;
  }
}
var names25, eqdc_default;
var init_eqdc = __esm({
  "node_modules/proj4/lib/projections/eqdc.js"() {
    init_e0fn();
    init_e1fn();
    init_e2fn();
    init_e3fn();
    init_msfnz();
    init_mlfn();
    init_adjust_lon();
    init_adjust_lat();
    init_imlfn();
    init_values();
    names25 = ["Equidistant_Conic", "eqdc"];
    eqdc_default = {
      init: init24,
      forward: forward23,
      inverse: inverse23,
      names: names25
    };
  }
});

// node_modules/proj4/lib/projections/vandg.js
function init25() {
  this.R = this.a;
}
function forward24(p) {
  var lon = p.x;
  var lat = p.y;
  var dlon = adjust_lon_default(lon - this.long0);
  var x, y;
  if (Math.abs(lat) <= EPSLN) {
    x = this.x0 + this.R * dlon;
    y = this.y0;
  }
  var theta = asinz_default(2 * Math.abs(lat / Math.PI));
  if (Math.abs(dlon) <= EPSLN || Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
    x = this.x0;
    if (lat >= 0) {
      y = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);
    } else {
      y = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);
    }
  }
  var al = 0.5 * Math.abs(Math.PI / dlon - dlon / Math.PI);
  var asq = al * al;
  var sinth = Math.sin(theta);
  var costh = Math.cos(theta);
  var g = costh / (sinth + costh - 1);
  var gsq = g * g;
  var m = g * (2 / sinth - 1);
  var msq = m * m;
  var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);
  if (dlon < 0) {
    con = -con;
  }
  x = this.x0 + con;
  var q = asq + g;
  con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);
  if (lat >= 0) {
    y = this.y0 + con;
  } else {
    y = this.y0 - con;
  }
  p.x = x;
  p.y = y;
  return p;
}
function inverse24(p) {
  var lon, lat;
  var xx, yy, xys, c1, c2, c3;
  var a1;
  var m1;
  var con;
  var th1;
  var d;
  p.x -= this.x0;
  p.y -= this.y0;
  con = Math.PI * this.R;
  xx = p.x / con;
  yy = p.y / con;
  xys = xx * xx + yy * yy;
  c1 = -Math.abs(yy) * (1 + xys);
  c2 = c1 - 2 * yy * yy + xx * xx;
  c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;
  d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;
  a1 = (c1 - c2 * c2 / 3 / c3) / c3;
  m1 = 2 * Math.sqrt(-a1 / 3);
  con = 3 * d / a1 / m1;
  if (Math.abs(con) > 1) {
    if (con >= 0) {
      con = 1;
    } else {
      con = -1;
    }
  }
  th1 = Math.acos(con) / 3;
  if (p.y >= 0) {
    lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
  } else {
    lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
  }
  if (Math.abs(xx) < EPSLN) {
    lon = this.long0;
  } else {
    lon = adjust_lon_default(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);
  }
  p.x = lon;
  p.y = lat;
  return p;
}
var names26, vandg_default;
var init_vandg = __esm({
  "node_modules/proj4/lib/projections/vandg.js"() {
    init_adjust_lon();
    init_values();
    init_asinz();
    names26 = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
    vandg_default = {
      init: init25,
      forward: forward24,
      inverse: inverse24,
      names: names26
    };
  }
});

// node_modules/proj4/lib/projections/aeqd.js
function init26() {
  this.sin_p12 = Math.sin(this.lat0);
  this.cos_p12 = Math.cos(this.lat0);
}
function forward25(p) {
  var lon = p.x;
  var lat = p.y;
  var sinphi = Math.sin(p.y);
  var cosphi = Math.cos(p.y);
  var dlon = adjust_lon_default(lon - this.long0);
  var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G, H, GH, Hs, c, kp, cos_c, s, s2, s3, s4, s5;
  if (this.sphere) {
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      p.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);
      p.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);
      return p;
    } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      p.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);
      p.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);
      return p;
    } else {
      cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);
      c = Math.acos(cos_c);
      kp = c ? c / Math.sin(c) : 1;
      p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);
      p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));
      return p;
    }
  } else {
    e0 = e0fn_default(this.es);
    e1 = e1fn_default(this.es);
    e2 = e2fn_default(this.es);
    e3 = e3fn_default(this.es);
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      Mlp = this.a * mlfn_default(e0, e1, e2, e3, HALF_PI);
      Ml = this.a * mlfn_default(e0, e1, e2, e3, lat);
      p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);
      p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);
      return p;
    } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      Mlp = this.a * mlfn_default(e0, e1, e2, e3, HALF_PI);
      Ml = this.a * mlfn_default(e0, e1, e2, e3, lat);
      p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);
      p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);
      return p;
    } else {
      tanphi = sinphi / cosphi;
      Nl1 = gN_default(this.a, this.e, this.sin_p12);
      Nl = gN_default(this.a, this.e, sinphi);
      psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));
      Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));
      if (Az === 0) {
        s = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
      } else if (Math.abs(Math.abs(Az) - Math.PI) <= EPSLN) {
        s = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
      } else {
        s = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));
      }
      G = this.e * this.sin_p12 / Math.sqrt(1 - this.es);
      H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);
      GH = G * H;
      Hs = H * H;
      s2 = s * s;
      s3 = s2 * s;
      s4 = s3 * s;
      s5 = s4 * s;
      c = Nl1 * s * (1 - s2 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) - s5 / 48 * GH);
      p.x = this.x0 + c * Math.sin(Az);
      p.y = this.y0 + c * Math.cos(Az);
      return p;
    }
  }
}
function inverse25(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M, N1, psi, Az, cosAz, tmp, A2, B, D, Ee, F, sinpsi;
  if (this.sphere) {
    rh = Math.sqrt(p.x * p.x + p.y * p.y);
    if (rh > 2 * HALF_PI * this.a) {
      return;
    }
    z = rh / this.a;
    sinz = Math.sin(z);
    cosz = Math.cos(z);
    lon = this.long0;
    if (Math.abs(rh) <= EPSLN) {
      lat = this.lat0;
    } else {
      lat = asinz_default(cosz * this.sin_p12 + p.y * sinz * this.cos_p12 / rh);
      con = Math.abs(this.lat0) - HALF_PI;
      if (Math.abs(con) <= EPSLN) {
        if (this.lat0 >= 0) {
          lon = adjust_lon_default(this.long0 + Math.atan2(p.x, -p.y));
        } else {
          lon = adjust_lon_default(this.long0 - Math.atan2(-p.x, p.y));
        }
      } else {
        lon = adjust_lon_default(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz));
      }
    }
    p.x = lon;
    p.y = lat;
    return p;
  } else {
    e0 = e0fn_default(this.es);
    e1 = e1fn_default(this.es);
    e2 = e2fn_default(this.es);
    e3 = e3fn_default(this.es);
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      Mlp = this.a * mlfn_default(e0, e1, e2, e3, HALF_PI);
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      M = Mlp - rh;
      lat = imlfn_default(M / this.a, e0, e1, e2, e3);
      lon = adjust_lon_default(this.long0 + Math.atan2(p.x, -1 * p.y));
      p.x = lon;
      p.y = lat;
      return p;
    } else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      Mlp = this.a * mlfn_default(e0, e1, e2, e3, HALF_PI);
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      M = rh - Mlp;
      lat = imlfn_default(M / this.a, e0, e1, e2, e3);
      lon = adjust_lon_default(this.long0 + Math.atan2(p.x, p.y));
      p.x = lon;
      p.y = lat;
      return p;
    } else {
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      Az = Math.atan2(p.x, p.y);
      N1 = gN_default(this.a, this.e, this.sin_p12);
      cosAz = Math.cos(Az);
      tmp = this.e * this.cos_p12 * cosAz;
      A2 = -tmp * tmp / (1 - this.es);
      B = 3 * this.es * (1 - A2) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);
      D = rh / N1;
      Ee = D - A2 * (1 + A2) * Math.pow(D, 3) / 6 - B * (1 + 3 * A2) * Math.pow(D, 4) / 24;
      F = 1 - A2 * Ee * Ee / 2 - D * Ee * Ee * Ee / 6;
      psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);
      lon = adjust_lon_default(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));
      sinpsi = Math.sin(psi);
      lat = Math.atan2((sinpsi - this.es * F * this.sin_p12) * Math.tan(psi), sinpsi * (1 - this.es));
      p.x = lon;
      p.y = lat;
      return p;
    }
  }
}
var names27, aeqd_default;
var init_aeqd = __esm({
  "node_modules/proj4/lib/projections/aeqd.js"() {
    init_adjust_lon();
    init_values();
    init_mlfn();
    init_e0fn();
    init_e1fn();
    init_e2fn();
    init_e3fn();
    init_gN();
    init_asinz();
    init_imlfn();
    names27 = ["Azimuthal_Equidistant", "aeqd"];
    aeqd_default = {
      init: init26,
      forward: forward25,
      inverse: inverse25,
      names: names27
    };
  }
});

// node_modules/proj4/lib/projections/ortho.js
function init27() {
  this.sin_p14 = Math.sin(this.lat0);
  this.cos_p14 = Math.cos(this.lat0);
}
function forward26(p) {
  var sinphi, cosphi;
  var dlon;
  var coslon;
  var ksp;
  var g, x, y;
  var lon = p.x;
  var lat = p.y;
  dlon = adjust_lon_default(lon - this.long0);
  sinphi = Math.sin(lat);
  cosphi = Math.cos(lat);
  coslon = Math.cos(dlon);
  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
  ksp = 1;
  if (g > 0 || Math.abs(g) <= EPSLN) {
    x = this.a * ksp * cosphi * Math.sin(dlon);
    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
  }
  p.x = x;
  p.y = y;
  return p;
}
function inverse26(p) {
  var rh;
  var z;
  var sinz, cosz;
  var con;
  var lon, lat;
  p.x -= this.x0;
  p.y -= this.y0;
  rh = Math.sqrt(p.x * p.x + p.y * p.y);
  z = asinz_default(rh / this.a);
  sinz = Math.sin(z);
  cosz = Math.cos(z);
  lon = this.long0;
  if (Math.abs(rh) <= EPSLN) {
    lat = this.lat0;
    p.x = lon;
    p.y = lat;
    return p;
  }
  lat = asinz_default(cosz * this.sin_p14 + p.y * sinz * this.cos_p14 / rh);
  con = Math.abs(this.lat0) - HALF_PI;
  if (Math.abs(con) <= EPSLN) {
    if (this.lat0 >= 0) {
      lon = adjust_lon_default(this.long0 + Math.atan2(p.x, -p.y));
    } else {
      lon = adjust_lon_default(this.long0 - Math.atan2(-p.x, p.y));
    }
    p.x = lon;
    p.y = lat;
    return p;
  }
  lon = adjust_lon_default(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p14 * cosz - p.y * this.sin_p14 * sinz));
  p.x = lon;
  p.y = lat;
  return p;
}
var names28, ortho_default;
var init_ortho = __esm({
  "node_modules/proj4/lib/projections/ortho.js"() {
    init_adjust_lon();
    init_asinz();
    init_values();
    names28 = ["ortho"];
    ortho_default = {
      init: init27,
      forward: forward26,
      inverse: inverse26,
      names: names28
    };
  }
});

// node_modules/proj4/lib/projections/qsc.js
function init28() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.lat_ts = this.lat_ts || 0;
  this.title = this.title || "Quadrilateralized Spherical Cube";
  if (this.lat0 >= HALF_PI - FORTPI / 2) {
    this.face = FACE_ENUM.TOP;
  } else if (this.lat0 <= -(HALF_PI - FORTPI / 2)) {
    this.face = FACE_ENUM.BOTTOM;
  } else if (Math.abs(this.long0) <= FORTPI) {
    this.face = FACE_ENUM.FRONT;
  } else if (Math.abs(this.long0) <= HALF_PI + FORTPI) {
    this.face = this.long0 > 0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;
  } else {
    this.face = FACE_ENUM.BACK;
  }
  if (this.es !== 0) {
    this.one_minus_f = 1 - (this.a - this.b) / this.a;
    this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;
  }
}
function forward27(p) {
  var xy = { x: 0, y: 0 };
  var lat, lon;
  var theta, phi;
  var t, mu;
  var area = { value: 0 };
  p.x -= this.long0;
  if (this.es !== 0) {
    lat = Math.atan(this.one_minus_f_squared * Math.tan(p.y));
  } else {
    lat = p.y;
  }
  lon = p.x;
  if (this.face === FACE_ENUM.TOP) {
    phi = HALF_PI - lat;
    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
      area.value = AREA_ENUM.AREA_0;
      theta = lon - HALF_PI;
    } else if (lon > HALF_PI + FORTPI || lon <= -(HALF_PI + FORTPI)) {
      area.value = AREA_ENUM.AREA_1;
      theta = lon > 0 ? lon - SPI : lon + SPI;
    } else if (lon > -(HALF_PI + FORTPI) && lon <= -FORTPI) {
      area.value = AREA_ENUM.AREA_2;
      theta = lon + HALF_PI;
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta = lon;
    }
  } else if (this.face === FACE_ENUM.BOTTOM) {
    phi = HALF_PI + lat;
    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
      area.value = AREA_ENUM.AREA_0;
      theta = -lon + HALF_PI;
    } else if (lon < FORTPI && lon >= -FORTPI) {
      area.value = AREA_ENUM.AREA_1;
      theta = -lon;
    } else if (lon < -FORTPI && lon >= -(HALF_PI + FORTPI)) {
      area.value = AREA_ENUM.AREA_2;
      theta = -lon - HALF_PI;
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta = lon > 0 ? -lon + SPI : -lon - SPI;
    }
  } else {
    var q, r, s;
    var sinlat, coslat;
    var sinlon, coslon;
    if (this.face === FACE_ENUM.RIGHT) {
      lon = qsc_shift_lon_origin(lon, +HALF_PI);
    } else if (this.face === FACE_ENUM.BACK) {
      lon = qsc_shift_lon_origin(lon, +SPI);
    } else if (this.face === FACE_ENUM.LEFT) {
      lon = qsc_shift_lon_origin(lon, -HALF_PI);
    }
    sinlat = Math.sin(lat);
    coslat = Math.cos(lat);
    sinlon = Math.sin(lon);
    coslon = Math.cos(lon);
    q = coslat * coslon;
    r = coslat * sinlon;
    s = sinlat;
    if (this.face === FACE_ENUM.FRONT) {
      phi = Math.acos(q);
      theta = qsc_fwd_equat_face_theta(phi, s, r, area);
    } else if (this.face === FACE_ENUM.RIGHT) {
      phi = Math.acos(r);
      theta = qsc_fwd_equat_face_theta(phi, s, -q, area);
    } else if (this.face === FACE_ENUM.BACK) {
      phi = Math.acos(-q);
      theta = qsc_fwd_equat_face_theta(phi, s, -r, area);
    } else if (this.face === FACE_ENUM.LEFT) {
      phi = Math.acos(-r);
      theta = qsc_fwd_equat_face_theta(phi, s, q, area);
    } else {
      phi = theta = 0;
      area.value = AREA_ENUM.AREA_0;
    }
  }
  mu = Math.atan(12 / SPI * (theta + Math.acos(Math.sin(theta) * Math.cos(FORTPI)) - HALF_PI));
  t = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));
  if (area.value === AREA_ENUM.AREA_1) {
    mu += HALF_PI;
  } else if (area.value === AREA_ENUM.AREA_2) {
    mu += SPI;
  } else if (area.value === AREA_ENUM.AREA_3) {
    mu += 1.5 * SPI;
  }
  xy.x = t * Math.cos(mu);
  xy.y = t * Math.sin(mu);
  xy.x = xy.x * this.a + this.x0;
  xy.y = xy.y * this.a + this.y0;
  p.x = xy.x;
  p.y = xy.y;
  return p;
}
function inverse27(p) {
  var lp = { lam: 0, phi: 0 };
  var mu, nu, cosmu, tannu;
  var tantheta, theta, cosphi, phi;
  var t;
  var area = { value: 0 };
  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;
  nu = Math.atan(Math.sqrt(p.x * p.x + p.y * p.y));
  mu = Math.atan2(p.y, p.x);
  if (p.x >= 0 && p.x >= Math.abs(p.y)) {
    area.value = AREA_ENUM.AREA_0;
  } else if (p.y >= 0 && p.y >= Math.abs(p.x)) {
    area.value = AREA_ENUM.AREA_1;
    mu -= HALF_PI;
  } else if (p.x < 0 && -p.x >= Math.abs(p.y)) {
    area.value = AREA_ENUM.AREA_2;
    mu = mu < 0 ? mu + SPI : mu - SPI;
  } else {
    area.value = AREA_ENUM.AREA_3;
    mu += HALF_PI;
  }
  t = SPI / 12 * Math.tan(mu);
  tantheta = Math.sin(t) / (Math.cos(t) - 1 / Math.sqrt(2));
  theta = Math.atan(tantheta);
  cosmu = Math.cos(mu);
  tannu = Math.tan(nu);
  cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));
  if (cosphi < -1) {
    cosphi = -1;
  } else if (cosphi > 1) {
    cosphi = 1;
  }
  if (this.face === FACE_ENUM.TOP) {
    phi = Math.acos(cosphi);
    lp.phi = HALF_PI - phi;
    if (area.value === AREA_ENUM.AREA_0) {
      lp.lam = theta + HALF_PI;
    } else if (area.value === AREA_ENUM.AREA_1) {
      lp.lam = theta < 0 ? theta + SPI : theta - SPI;
    } else if (area.value === AREA_ENUM.AREA_2) {
      lp.lam = theta - HALF_PI;
    } else {
      lp.lam = theta;
    }
  } else if (this.face === FACE_ENUM.BOTTOM) {
    phi = Math.acos(cosphi);
    lp.phi = phi - HALF_PI;
    if (area.value === AREA_ENUM.AREA_0) {
      lp.lam = -theta + HALF_PI;
    } else if (area.value === AREA_ENUM.AREA_1) {
      lp.lam = -theta;
    } else if (area.value === AREA_ENUM.AREA_2) {
      lp.lam = -theta - HALF_PI;
    } else {
      lp.lam = theta < 0 ? -theta - SPI : -theta + SPI;
    }
  } else {
    var q, r, s;
    q = cosphi;
    t = q * q;
    if (t >= 1) {
      s = 0;
    } else {
      s = Math.sqrt(1 - t) * Math.sin(theta);
    }
    t += s * s;
    if (t >= 1) {
      r = 0;
    } else {
      r = Math.sqrt(1 - t);
    }
    if (area.value === AREA_ENUM.AREA_1) {
      t = r;
      r = -s;
      s = t;
    } else if (area.value === AREA_ENUM.AREA_2) {
      r = -r;
      s = -s;
    } else if (area.value === AREA_ENUM.AREA_3) {
      t = r;
      r = s;
      s = -t;
    }
    if (this.face === FACE_ENUM.RIGHT) {
      t = q;
      q = -r;
      r = t;
    } else if (this.face === FACE_ENUM.BACK) {
      q = -q;
      r = -r;
    } else if (this.face === FACE_ENUM.LEFT) {
      t = q;
      q = r;
      r = -t;
    }
    lp.phi = Math.acos(-s) - HALF_PI;
    lp.lam = Math.atan2(r, q);
    if (this.face === FACE_ENUM.RIGHT) {
      lp.lam = qsc_shift_lon_origin(lp.lam, -HALF_PI);
    } else if (this.face === FACE_ENUM.BACK) {
      lp.lam = qsc_shift_lon_origin(lp.lam, -SPI);
    } else if (this.face === FACE_ENUM.LEFT) {
      lp.lam = qsc_shift_lon_origin(lp.lam, +HALF_PI);
    }
  }
  if (this.es !== 0) {
    var invert_sign;
    var tanphi, xa;
    invert_sign = lp.phi < 0 ? 1 : 0;
    tanphi = Math.tan(lp.phi);
    xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);
    lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));
    if (invert_sign) {
      lp.phi = -lp.phi;
    }
  }
  lp.lam += this.long0;
  p.x = lp.lam;
  p.y = lp.phi;
  return p;
}
function qsc_fwd_equat_face_theta(phi, y, x, area) {
  var theta;
  if (phi < EPSLN) {
    area.value = AREA_ENUM.AREA_0;
    theta = 0;
  } else {
    theta = Math.atan2(y, x);
    if (Math.abs(theta) <= FORTPI) {
      area.value = AREA_ENUM.AREA_0;
    } else if (theta > FORTPI && theta <= HALF_PI + FORTPI) {
      area.value = AREA_ENUM.AREA_1;
      theta -= HALF_PI;
    } else if (theta > HALF_PI + FORTPI || theta <= -(HALF_PI + FORTPI)) {
      area.value = AREA_ENUM.AREA_2;
      theta = theta >= 0 ? theta - SPI : theta + SPI;
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta += HALF_PI;
    }
  }
  return theta;
}
function qsc_shift_lon_origin(lon, offset) {
  var slon = lon + offset;
  if (slon < -SPI) {
    slon += TWO_PI;
  } else if (slon > +SPI) {
    slon -= TWO_PI;
  }
  return slon;
}
var FACE_ENUM, AREA_ENUM, names29, qsc_default;
var init_qsc = __esm({
  "node_modules/proj4/lib/projections/qsc.js"() {
    init_values();
    FACE_ENUM = {
      FRONT: 1,
      RIGHT: 2,
      BACK: 3,
      LEFT: 4,
      TOP: 5,
      BOTTOM: 6
    };
    AREA_ENUM = {
      AREA_0: 1,
      AREA_1: 2,
      AREA_2: 3,
      AREA_3: 4
    };
    names29 = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
    qsc_default = {
      init: init28,
      forward: forward27,
      inverse: inverse27,
      names: names29
    };
  }
});

// node_modules/proj4/lib/projections/robin.js
function newton_rapshon(f_df, start2, max_err, iters) {
  var x = start2;
  for (; iters; --iters) {
    var upd = f_df(x);
    x -= upd;
    if (Math.abs(upd) < max_err) {
      break;
    }
  }
  return x;
}
function init29() {
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.long0 = this.long0 || 0;
  this.es = 0;
  this.title = this.title || "Robinson";
}
function forward28(ll) {
  var lon = adjust_lon_default(ll.x - this.long0);
  var dphi = Math.abs(ll.y);
  var i = Math.floor(dphi * C1);
  if (i < 0) {
    i = 0;
  } else if (i >= NODES) {
    i = NODES - 1;
  }
  dphi = R2D * (dphi - RC1 * i);
  var xy = {
    x: poly3_val(COEFS_X[i], dphi) * lon,
    y: poly3_val(COEFS_Y[i], dphi)
  };
  if (ll.y < 0) {
    xy.y = -xy.y;
  }
  xy.x = xy.x * this.a * FXC + this.x0;
  xy.y = xy.y * this.a * FYC + this.y0;
  return xy;
}
function inverse28(xy) {
  var ll = {
    x: (xy.x - this.x0) / (this.a * FXC),
    y: Math.abs(xy.y - this.y0) / (this.a * FYC)
  };
  if (ll.y >= 1) {
    ll.x /= COEFS_X[NODES][0];
    ll.y = xy.y < 0 ? -HALF_PI : HALF_PI;
  } else {
    var i = Math.floor(ll.y * NODES);
    if (i < 0) {
      i = 0;
    } else if (i >= NODES) {
      i = NODES - 1;
    }
    for (; ; ) {
      if (COEFS_Y[i][0] > ll.y) {
        --i;
      } else if (COEFS_Y[i + 1][0] <= ll.y) {
        ++i;
      } else {
        break;
      }
    }
    var coefs = COEFS_Y[i];
    var t = 5 * (ll.y - coefs[0]) / (COEFS_Y[i + 1][0] - coefs[0]);
    t = newton_rapshon(function(x) {
      return (poly3_val(coefs, x) - ll.y) / poly3_der(coefs, x);
    }, t, EPSLN, 100);
    ll.x /= poly3_val(COEFS_X[i], t);
    ll.y = (5 * i + t) * D2R;
    if (xy.y < 0) {
      ll.y = -ll.y;
    }
  }
  ll.x = adjust_lon_default(ll.x + this.long0);
  return ll;
}
var COEFS_X, COEFS_Y, FXC, FYC, C1, RC1, NODES, poly3_val, poly3_der, names30, robin_default;
var init_robin = __esm({
  "node_modules/proj4/lib/projections/robin.js"() {
    init_values();
    init_adjust_lon();
    COEFS_X = [
      [1, 22199e-21, -715515e-10, 31103e-10],
      [0.9986, -482243e-9, -24897e-9, -13309e-10],
      [0.9954, -83103e-8, -448605e-10, -986701e-12],
      [0.99, -135364e-8, -59661e-9, 36777e-10],
      [0.9822, -167442e-8, -449547e-11, -572411e-11],
      [0.973, -214868e-8, -903571e-10, 18736e-12],
      [0.96, -305085e-8, -900761e-10, 164917e-11],
      [0.9427, -382792e-8, -653386e-10, -26154e-10],
      [0.9216, -467746e-8, -10457e-8, 481243e-11],
      [0.8962, -536223e-8, -323831e-10, -543432e-11],
      [0.8679, -609363e-8, -113898e-9, 332484e-11],
      [0.835, -698325e-8, -640253e-10, 934959e-12],
      [0.7986, -755338e-8, -500009e-10, 935324e-12],
      [0.7597, -798324e-8, -35971e-9, -227626e-11],
      [0.7186, -851367e-8, -701149e-10, -86303e-10],
      [0.6732, -986209e-8, -199569e-9, 191974e-10],
      [0.6213, -0.010418, 883923e-10, 624051e-11],
      [0.5722, -906601e-8, 182e-6, 624051e-11],
      [0.5322, -677797e-8, 275608e-9, 624051e-11]
    ];
    COEFS_Y = [
      [-520417e-23, 0.0124, 121431e-23, -845284e-16],
      [0.062, 0.0124, -126793e-14, 422642e-15],
      [0.124, 0.0124, 507171e-14, -160604e-14],
      [0.186, 0.0123999, -190189e-13, 600152e-14],
      [0.248, 0.0124002, 710039e-13, -224e-10],
      [0.31, 0.0123992, -264997e-12, 835986e-13],
      [0.372, 0.0124029, 988983e-12, -311994e-12],
      [0.434, 0.0123893, -369093e-11, -435621e-12],
      [0.4958, 0.0123198, -102252e-10, -345523e-12],
      [0.5571, 0.0121916, -154081e-10, -582288e-12],
      [0.6176, 0.0119938, -241424e-10, -525327e-12],
      [0.6769, 0.011713, -320223e-10, -516405e-12],
      [0.7346, 0.0113541, -397684e-10, -609052e-12],
      [0.7903, 0.0109107, -489042e-10, -104739e-11],
      [0.8435, 0.0103431, -64615e-9, -140374e-14],
      [0.8936, 969686e-8, -64636e-9, -8547e-9],
      [0.9394, 840947e-8, -192841e-9, -42106e-10],
      [0.9761, 616527e-8, -256e-6, -42106e-10],
      [1, 328947e-8, -319159e-9, -42106e-10]
    ];
    FXC = 0.8487;
    FYC = 1.3523;
    C1 = R2D / 5;
    RC1 = 1 / C1;
    NODES = 18;
    poly3_val = function(coefs, x) {
      return coefs[0] + x * (coefs[1] + x * (coefs[2] + x * coefs[3]));
    };
    poly3_der = function(coefs, x) {
      return coefs[1] + x * (2 * coefs[2] + x * 3 * coefs[3]);
    };
    names30 = ["Robinson", "robin"];
    robin_default = {
      init: init29,
      forward: forward28,
      inverse: inverse28,
      names: names30
    };
  }
});

// node_modules/proj4/lib/projections/geocent.js
function init30() {
  this.name = "geocent";
}
function forward29(p) {
  var point3 = geodeticToGeocentric(p, this.es, this.a);
  return point3;
}
function inverse29(p) {
  var point3 = geocentricToGeodetic(p, this.es, this.a, this.b);
  return point3;
}
var names31, geocent_default;
var init_geocent = __esm({
  "node_modules/proj4/lib/projections/geocent.js"() {
    init_datumUtils();
    names31 = ["Geocentric", "geocentric", "geocent", "Geocent"];
    geocent_default = {
      init: init30,
      forward: forward29,
      inverse: inverse29,
      names: names31
    };
  }
});

// node_modules/proj4/lib/projections/tpers.js
function init31() {
  Object.keys(params).forEach(function(p) {
    if (typeof this[p] === "undefined") {
      this[p] = params[p].def;
    } else if (params[p].num && isNaN(this[p])) {
      throw new Error("Invalid parameter value, must be numeric " + p + " = " + this[p]);
    } else if (params[p].num) {
      this[p] = parseFloat(this[p]);
    }
    if (params[p].degrees) {
      this[p] = this[p] * D2R;
    }
  }.bind(this));
  if (Math.abs(Math.abs(this.lat0) - HALF_PI) < EPSLN) {
    this.mode = this.lat0 < 0 ? mode.S_POLE : mode.N_POLE;
  } else if (Math.abs(this.lat0) < EPSLN) {
    this.mode = mode.EQUIT;
  } else {
    this.mode = mode.OBLIQ;
    this.sinph0 = Math.sin(this.lat0);
    this.cosph0 = Math.cos(this.lat0);
  }
  this.pn1 = this.h / this.a;
  if (this.pn1 <= 0 || this.pn1 > 1e10) {
    throw new Error("Invalid height");
  }
  this.p = 1 + this.pn1;
  this.rp = 1 / this.p;
  this.h1 = 1 / this.pn1;
  this.pfact = (this.p + 1) * this.h1;
  this.es = 0;
  var omega = this.tilt;
  var gamma = this.azi;
  this.cg = Math.cos(gamma);
  this.sg = Math.sin(gamma);
  this.cw = Math.cos(omega);
  this.sw = Math.sin(omega);
}
function forward30(p) {
  p.x -= this.long0;
  var sinphi = Math.sin(p.y);
  var cosphi = Math.cos(p.y);
  var coslam = Math.cos(p.x);
  var x, y;
  switch (this.mode) {
    case mode.OBLIQ:
      y = this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
      break;
    case mode.EQUIT:
      y = cosphi * coslam;
      break;
    case mode.S_POLE:
      y = -sinphi;
      break;
    case mode.N_POLE:
      y = sinphi;
      break;
  }
  y = this.pn1 / (this.p - y);
  x = y * cosphi * Math.sin(p.x);
  switch (this.mode) {
    case mode.OBLIQ:
      y *= this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
      break;
    case mode.EQUIT:
      y *= sinphi;
      break;
    case mode.N_POLE:
      y *= -(cosphi * coslam);
      break;
    case mode.S_POLE:
      y *= cosphi * coslam;
      break;
  }
  var yt, ba;
  yt = y * this.cg + x * this.sg;
  ba = 1 / (yt * this.sw * this.h1 + this.cw);
  x = (x * this.cg - y * this.sg) * this.cw * ba;
  y = yt * ba;
  p.x = x * this.a;
  p.y = y * this.a;
  return p;
}
function inverse30(p) {
  p.x /= this.a;
  p.y /= this.a;
  var r = { x: p.x, y: p.y };
  var bm, bq, yt;
  yt = 1 / (this.pn1 - p.y * this.sw);
  bm = this.pn1 * p.x * yt;
  bq = this.pn1 * p.y * this.cw * yt;
  p.x = bm * this.cg + bq * this.sg;
  p.y = bq * this.cg - bm * this.sg;
  var rh = hypot_default(p.x, p.y);
  if (Math.abs(rh) < EPSLN) {
    r.x = 0;
    r.y = p.y;
  } else {
    var cosz, sinz;
    sinz = 1 - rh * rh * this.pfact;
    sinz = (this.p - Math.sqrt(sinz)) / (this.pn1 / rh + rh / this.pn1);
    cosz = Math.sqrt(1 - sinz * sinz);
    switch (this.mode) {
      case mode.OBLIQ:
        r.y = Math.asin(cosz * this.sinph0 + p.y * sinz * this.cosph0 / rh);
        p.y = (cosz - this.sinph0 * Math.sin(r.y)) * rh;
        p.x *= sinz * this.cosph0;
        break;
      case mode.EQUIT:
        r.y = Math.asin(p.y * sinz / rh);
        p.y = cosz * rh;
        p.x *= sinz;
        break;
      case mode.N_POLE:
        r.y = Math.asin(cosz);
        p.y = -p.y;
        break;
      case mode.S_POLE:
        r.y = -Math.asin(cosz);
        break;
    }
    r.x = Math.atan2(p.x, p.y);
  }
  p.x = r.x + this.long0;
  p.y = r.y;
  return p;
}
var mode, params, names32, tpers_default;
var init_tpers = __esm({
  "node_modules/proj4/lib/projections/tpers.js"() {
    init_values();
    init_hypot();
    mode = {
      N_POLE: 0,
      S_POLE: 1,
      EQUIT: 2,
      OBLIQ: 3
    };
    params = {
      h: { def: 1e5, num: true },
      azi: { def: 0, num: true, degrees: true },
      tilt: { def: 0, num: true, degrees: true },
      long0: { def: 0, num: true },
      lat0: { def: 0, num: true }
    };
    names32 = ["Tilted_Perspective", "tpers"];
    tpers_default = {
      init: init31,
      forward: forward30,
      inverse: inverse30,
      names: names32
    };
  }
});

// node_modules/proj4/lib/projections/geos.js
function init32() {
  this.flip_axis = this.sweep === "x" ? 1 : 0;
  this.h = Number(this.h);
  this.radius_g_1 = this.h / this.a;
  if (this.radius_g_1 <= 0 || this.radius_g_1 > 1e10) {
    throw new Error();
  }
  this.radius_g = 1 + this.radius_g_1;
  this.C = this.radius_g * this.radius_g - 1;
  if (this.es !== 0) {
    var one_es = 1 - this.es;
    var rone_es = 1 / one_es;
    this.radius_p = Math.sqrt(one_es);
    this.radius_p2 = one_es;
    this.radius_p_inv2 = rone_es;
    this.shape = "ellipse";
  } else {
    this.radius_p = 1;
    this.radius_p2 = 1;
    this.radius_p_inv2 = 1;
    this.shape = "sphere";
  }
  if (!this.title) {
    this.title = "Geostationary Satellite View";
  }
}
function forward31(p) {
  var lon = p.x;
  var lat = p.y;
  var tmp, v_x, v_y, v_z;
  lon = lon - this.long0;
  if (this.shape === "ellipse") {
    lat = Math.atan(this.radius_p2 * Math.tan(lat));
    var r = this.radius_p / hypot_default(this.radius_p * Math.cos(lat), Math.sin(lat));
    v_x = r * Math.cos(lon) * Math.cos(lat);
    v_y = r * Math.sin(lon) * Math.cos(lat);
    v_z = r * Math.sin(lat);
    if ((this.radius_g - v_x) * v_x - v_y * v_y - v_z * v_z * this.radius_p_inv2 < 0) {
      p.x = Number.NaN;
      p.y = Number.NaN;
      return p;
    }
    tmp = this.radius_g - v_x;
    if (this.flip_axis) {
      p.x = this.radius_g_1 * Math.atan(v_y / hypot_default(v_z, tmp));
      p.y = this.radius_g_1 * Math.atan(v_z / tmp);
    } else {
      p.x = this.radius_g_1 * Math.atan(v_y / tmp);
      p.y = this.radius_g_1 * Math.atan(v_z / hypot_default(v_y, tmp));
    }
  } else if (this.shape === "sphere") {
    tmp = Math.cos(lat);
    v_x = Math.cos(lon) * tmp;
    v_y = Math.sin(lon) * tmp;
    v_z = Math.sin(lat);
    tmp = this.radius_g - v_x;
    if (this.flip_axis) {
      p.x = this.radius_g_1 * Math.atan(v_y / hypot_default(v_z, tmp));
      p.y = this.radius_g_1 * Math.atan(v_z / tmp);
    } else {
      p.x = this.radius_g_1 * Math.atan(v_y / tmp);
      p.y = this.radius_g_1 * Math.atan(v_z / hypot_default(v_y, tmp));
    }
  }
  p.x = p.x * this.a;
  p.y = p.y * this.a;
  return p;
}
function inverse31(p) {
  var v_x = -1;
  var v_y = 0;
  var v_z = 0;
  var a, b, det, k;
  p.x = p.x / this.a;
  p.y = p.y / this.a;
  if (this.shape === "ellipse") {
    if (this.flip_axis) {
      v_z = Math.tan(p.y / this.radius_g_1);
      v_y = Math.tan(p.x / this.radius_g_1) * hypot_default(1, v_z);
    } else {
      v_y = Math.tan(p.x / this.radius_g_1);
      v_z = Math.tan(p.y / this.radius_g_1) * hypot_default(1, v_y);
    }
    var v_zp = v_z / this.radius_p;
    a = v_y * v_y + v_zp * v_zp + v_x * v_x;
    b = 2 * this.radius_g * v_x;
    det = b * b - 4 * a * this.C;
    if (det < 0) {
      p.x = Number.NaN;
      p.y = Number.NaN;
      return p;
    }
    k = (-b - Math.sqrt(det)) / (2 * a);
    v_x = this.radius_g + k * v_x;
    v_y *= k;
    v_z *= k;
    p.x = Math.atan2(v_y, v_x);
    p.y = Math.atan(v_z * Math.cos(p.x) / v_x);
    p.y = Math.atan(this.radius_p_inv2 * Math.tan(p.y));
  } else if (this.shape === "sphere") {
    if (this.flip_axis) {
      v_z = Math.tan(p.y / this.radius_g_1);
      v_y = Math.tan(p.x / this.radius_g_1) * Math.sqrt(1 + v_z * v_z);
    } else {
      v_y = Math.tan(p.x / this.radius_g_1);
      v_z = Math.tan(p.y / this.radius_g_1) * Math.sqrt(1 + v_y * v_y);
    }
    a = v_y * v_y + v_z * v_z + v_x * v_x;
    b = 2 * this.radius_g * v_x;
    det = b * b - 4 * a * this.C;
    if (det < 0) {
      p.x = Number.NaN;
      p.y = Number.NaN;
      return p;
    }
    k = (-b - Math.sqrt(det)) / (2 * a);
    v_x = this.radius_g + k * v_x;
    v_y *= k;
    v_z *= k;
    p.x = Math.atan2(v_y, v_x);
    p.y = Math.atan(v_z * Math.cos(p.x) / v_x);
  }
  p.x = p.x + this.long0;
  return p;
}
var names33, geos_default;
var init_geos = __esm({
  "node_modules/proj4/lib/projections/geos.js"() {
    init_hypot();
    names33 = ["Geostationary Satellite View", "Geostationary_Satellite", "geos"];
    geos_default = {
      init: init32,
      forward: forward31,
      inverse: inverse31,
      names: names33
    };
  }
});

// node_modules/proj4/projs.js
function projs_default(proj43) {
  proj43.Proj.projections.add(tmerc_default);
  proj43.Proj.projections.add(etmerc_default);
  proj43.Proj.projections.add(utm_default);
  proj43.Proj.projections.add(sterea_default);
  proj43.Proj.projections.add(stere_default);
  proj43.Proj.projections.add(somerc_default);
  proj43.Proj.projections.add(omerc_default);
  proj43.Proj.projections.add(lcc_default);
  proj43.Proj.projections.add(krovak_default);
  proj43.Proj.projections.add(cass_default);
  proj43.Proj.projections.add(laea_default);
  proj43.Proj.projections.add(aea_default);
  proj43.Proj.projections.add(gnom_default);
  proj43.Proj.projections.add(cea_default);
  proj43.Proj.projections.add(eqc_default);
  proj43.Proj.projections.add(poly_default);
  proj43.Proj.projections.add(nzmg_default);
  proj43.Proj.projections.add(mill_default);
  proj43.Proj.projections.add(sinu_default);
  proj43.Proj.projections.add(moll_default);
  proj43.Proj.projections.add(eqdc_default);
  proj43.Proj.projections.add(vandg_default);
  proj43.Proj.projections.add(aeqd_default);
  proj43.Proj.projections.add(ortho_default);
  proj43.Proj.projections.add(qsc_default);
  proj43.Proj.projections.add(robin_default);
  proj43.Proj.projections.add(geocent_default);
  proj43.Proj.projections.add(tpers_default);
  proj43.Proj.projections.add(geos_default);
}
var init_projs = __esm({
  "node_modules/proj4/projs.js"() {
    init_tmerc();
    init_etmerc();
    init_utm();
    init_sterea();
    init_stere();
    init_somerc();
    init_omerc();
    init_lcc();
    init_krovak();
    init_cass();
    init_laea();
    init_aea();
    init_gnom();
    init_cea();
    init_eqc();
    init_poly();
    init_nzmg();
    init_mill();
    init_sinu();
    init_moll();
    init_eqdc();
    init_vandg();
    init_aeqd();
    init_ortho();
    init_qsc();
    init_robin();
    init_geocent();
    init_tpers();
    init_geos();
  }
});

// node_modules/proj4/lib/index.js
var lib_exports = {};
__export(lib_exports, {
  default: () => lib_default
});
var lib_default;
var init_lib = __esm({
  "node_modules/proj4/lib/index.js"() {
    init_core();
    init_Proj();
    init_Point();
    init_toPoint();
    init_defs();
    init_nadgrid();
    init_transform();
    init_mgrs();
    init_projs();
    core_default.defaultDatum = "WGS84";
    core_default.Proj = Proj_default;
    core_default.WGS84 = new core_default.Proj("WGS84");
    core_default.Point = Point_default;
    core_default.toPoint = toPoint_default;
    core_default.defs = defs_default;
    core_default.nadgrid = nadgrid;
    core_default.transform = transform;
    core_default.mgrs = mgrs_default;
    core_default.version = "__VERSION__";
    projs_default(core_default);
    lib_default = core_default;
  }
});

// node_modules/proj4js-definitions/proj4js-definitions.js
var require_proj4js_definitions = __commonJS({
  "node_modules/proj4js-definitions/proj4js-definitions.js"(exports4, module) {
    var A2 = " +no_defs";
    var B = " +towgs84=0,0,0,0,0,0,0";
    var C = " +ellps=GRS80";
    var D = "+proj=tmerc";
    var E = " +units=m";
    var F = " +towgs84=23.92,-141.27,-80.9,-0,0.35,0.82,-0.12";
    var G = " +towgs84=24.47,-130.89,-81.56,-0,-0,0.13,-0.22";
    var H = "+proj=lcc";
    var I2 = "+proj=utm";
    var J = " +units=us-ft";
    var K = "+proj=longlat";
    var L3 = " +lat_0=0";
    var M = " +ellps=krass";
    var N = " +y_0=0";
    var O2 = " +x_0=500000";
    var P = " +towgs84=0,0,4.5,0,0,0.554,0.2263";
    var Q = " +towgs84=0,0,1.9,0,0,0.814,-0.38";
    var R = " +ellps=intl";
    var S = " +datum=WGS84";
    var T = " +ellps=WGS72";
    var U = " +towgs84=15.8,-154.4,-82.3,0,0,0,0";
    var V2 = " +k=0.9999";
    var W = " +towgs84=59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993";
    var X = " +datum=NAD27";
    var Y = " +ellps=bessel";
    var Z2 = " +x_0=609601.2192024384";
    var a = " +x_0=600000";
    var b = " +towgs84=33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84";
    var c = " +ellps=clrk80";
    var d = " +b=6356755.288157528";
    var e = " +x_0=152400.3048006096";
    var f = " +lat_0=36.66666666666666";
    var g = " +towgs84=-146.414,507.337,680.507,0,0,0,0";
    var h = " +x_0=200000";
    var i = " +ellps=clrk66";
    var j = " +ellps=WGS84";
    var k = " +x_0=500000.001016002";
    var l = " +x_0=240000";
    var m = " +lat_0=-90";
    var n = " +towgs84=-87,-98,-121,0,0,0,0";
    var o = " +south";
    var p = " +lat_0=41.66666666666666";
    var q = " +y_0=36000";
    var r = " +towgs84=-117.808,-51.536,137.784,0.303,0.446,0.234,-0.29";
    var s = " +x_0=0";
    var t = " +units=ft";
    var u = " +x_0=400000";
    var v = " +towgs84=-115.854,-99.0583,-152.462,0,0,0,0";
    var w = " +towgs84=-208.406,-109.878,-2.5764,0,0,0,0";
    var x = " +ellps=aust_SA";
    var y = " +lat_0=39.33333333333334";
    var z = " +towgs84=577.326,90.129,463.919,5.137,1.474,5.297,2.4232";
    var AA = " +lat_0=37.66666666666666";
    var AB = " +lat_0=36.33333333333334";
    var AC = " +towgs84=598.1,73.7,418.2,0.202,0.045,-2.455,6.7";
    var AD = " +y_0=500000.0001016001";
    var AE = " +x_0=200000.0001016002";
    var AF = " +x_0=500000.0001016001";
    var AG = " +x_0=500000.00001016";
    var AH = " +y_0=1000000";
    var AI = " +x_0=300000";
    var AJ = " +lon_0=-120.5";
    var AK = " +lat_0=43.66666666666666";
    var AL = " +lat_0=43.83333333333334";
    var AM = " +lat_1=-68.66666666666667";
    var AN = " +lat_2=-71.33333333333333";
    var AO = " +k=0.999966667";
    var AP = " +k=0.9996";
    var AQ = " +lat_0=38.33333333333334";
    var AR = " +lat_1=73.66666666666667";
    var AS = " +lat_2=70.33333333333333";
    var AT = " +lat_0=72.02500919444445";
    var AU = " +a=6378249.2";
    var AV = " +x_0=1500000";
    var AW = " +lat_ts=-80.23861111111111";
    var AX = " +towgs84=-288,175,-376,0,0,0,0";
    var AY = " +lat_1=41.78333333333333";
    var AZ = " +lat_2=-75.33333333333333";
    var Aa = " +towgs84=278.3,93,474.5,7.889,0.05,-6.61,6.21";
    var Ab = " +x_0=304800";
    var Ac = " +x_0=2000000.0001016";
    var Ad = " +k=0.9999375";
    var Ae = " +y_0=500000";
    var Af = " +towgs84=-209.362,-87.8162,404.62,0.0046,3.4784,0.5805,-1.4547";
    var Ag = " +lon_0=-100.3333333333333";
    var Ah = " +lat_1=-72.66666666666667";
    var Ai = " +lat_1=-76.66666666666667";
    var Aj = " +lat_2=-79.33333333333333";
    var Ak = " +y_0=10000000";
    var Al = " +towgs84=-57,1,-41,0,0,0,0";
    var Am = " +k=0.999941177";
    var An = " +x_0=800000.0000101599";
    var Ao = " +y_0=99999.99998983997";
    var Ap = " +lat_1=38.43333333333333";
    var Aq = " +lat_0=24.33333333333333";
    var Ar = " +towgs84=26,-121,-78,0,0,0,0";
    var As = " +a=6378140";
    var At = " +towgs84=-96.062,-82.428,-121.753,4.801,0.345,-1.376,1.496";
    var Au = " +x_0=399999.99998984";
    var Av = " +towgs84=-24,-15,5,0,0,0,0";
    var Aw = " +towgs84=682,-203,480,0,0,0,0";
    var Ax = " +towgs84=-136,-108,-292,0,0,0,0";
    var Ay = " +b=6356075.41314024";
    var Az = " +lat_1=37.96666666666667";
    var BA = " +lat_0=38.83333333333334";
    var BB = " +lat_0=40.16666666666666";
    var BC = " +lat_0=34.33333333333334";
    var BD = " +lat_0=42.83333333333334";
    var BE = " +lon_0=-84.36666666666666";
    var BF = " +x_0=300000.0000000001";
    var BG = " +k=0.999933333";
    var BH = " +lat_1=48.73333333333333";
    var BI = " +lon_0=-111.5";
    var BJ = " +k=0.9999473679999999";
    var BK = " +towgs84=-67.35,3.88,-38.22,0,0,0,0";
    var BL = " +lat_2=73.66666666666667";
    var BM = " +lat_0=75.36440330555556";
    var BN = " +b=6356515";
    var BO = " +towgs84=25,-141,-78.5,-0,0.35,0.736,0";
    var BP = "+proj=stere";
    var BQ = " +lat_1=-64.66666666666667";
    var BR = " +lat_2=-67.33333333333333";
    var BS = " +b=6356514.966398753";
    var BT = " +towgs84=295,736,257,0,0,0,0";
    var BU = " +x_0=100000";
    var BV = " +towgs84=-11,851,5,0,0,0,0";
    var BW = " +towgs84=414.1,41.3,603.1,-0.855,2.141,-7.023,0";
    var BX = " +towgs84=-127.62,-67.24,-47.04,-3.068,4.903,1.578,-1.06";
    var BY = " +lat_0=39.66666666666666";
    var BZ = " +x_0=1000000";
    var Ba = " +lon_0=-105.5";
    var Bb = " +towgs84=482.5,-130.6,564.6,-1.042,-0.214,-0.631,8.15";
    var Bc = " +a=6378249.145";
    var Bd = " +x_0=2000000";
    var Be = " +lat_0=45.66666666666666";
    var Bf = " +lat_1=80.33333333333333";
    var Bg = " +lat_0=78.70733752777778";
    var Bh = " +b=6356774.50408554";
    var Bi = " +lon_0=-91.33333333333333";
    var Bj = " +lon_0=-123.3333333333333";
    var Bk = " +towgs84=-168,-60,320,0,0,0,0";
    var Bl = " +lat_0=31";
    var Bm = " +towgs84=0.072,-0.507,-0.245,-0.0183,0.0003,-0.007,-0.0093";
    var Bn = " +x_0=150000";
    var Bo = " +x_0=3500000";
    var Bp = " +towgs84=213.11,9.37,-74.95,0,0,0,0";
    var Bq = " +lat_1=43.66666666666666";
    var Br = " +lat_0=40.33333333333334";
    var Bs = " +towgs84=-148,136,90,0,0,0,0";
    var Bt = " +towgs84=616,97,-251,0,0,0,0";
    var Bu = " +lon_0=-90";
    var Bv = " +x_0=250000";
    var Bw = " +x_0=914401.8288036576";
    var Bx = " +lon_0=-90.33333333333333";
    var By = " +a=6377276.345";
    var Bz = " +b=6356103.038993155";
    var CA = " +lat_0=40.5";
    var CB = " +towgs84=-134,-48,149,0,0,0,0";
    var CC = " +towgs84=25,-141,-78.5,0,0.35,0.736,0";
    var CD = " +lat_1=27.83333333333333";
    var CE = " +lat_2=26.16666666666667";
    var CF = " +lat_2=40.71666666666667";
    var CG = " +lat_2=39.01666666666667";
    var CH = " +lat_2=37.21666666666667";
    var CI = " +lat_1=70.33333333333333";
    var CJ = " +lat_0=68.68747555555557";
    var CK = " +towgs84=-104.1,-49.1,-9.9,0.971,-2.917,0.714,-11.68";
    var CL = " +y_0=304800.6096012192";
    var CM = " +x_0=699999.9998983998";
    var CN = " +y_0=999999.9998983998";
    var CO = " +y_0=800000";
    var CP = " +k=0.99995";
    var CQ = " +lat_0=34.75";
    var CR = " +lon_0=-81";
    var CS = " +lon_0=-100";
    var CT = " +b=6356098.145120132";
    var CU = "+proj=omerc";
    var CV = " +lon_0=-98.5";
    var CW = " +towgs84=-103.746,-9.614,-255.95,0,0,0,0";
    var CX = " +x_0=800000";
    var CY = " +lat_0=37.83333333333334";
    var CZ = " +lat_2=44.33333333333334";
    var Ca = " +lat_2=42.33333333333334";
    var Cb = " +lat_0=29.66666666666667";
    var Cc = " +lat_0=25.66666666666667";
    var Cd = " +lat_0=35.83333333333334";
    var Ce = " +lat_1=83.66666666666667";
    var Cf = " +lat_2=80.33333333333333";
    var Cg = " +lat_0=82.05842488888888";
    var Ch = " +lat_0=38";
    var Ci = " +x_0=2500000";
    var Cj = " +towgs84=-377,681,-50,0,0,0,0";
    var Ck = "+proj=cass";
    var Cl = " +y_0=2000000";
    var Cm = " +towgs84=-143,-236,7,0,0,0,0";
    var Cn = " +lon_0=-110.1666666666667";
    var Co = " +lon_0=-111.9166666666667";
    var Cp = " +lon_0=-75.41666666666667";
    var Cq = " +lon_0=-82.16666666666667";
    var Cr = " +lon_0=-84.16666666666667";
    var Cs = " +lon_0=-112.1666666666667";
    var Ct = " +lon_0=-88.83333333333333";
    var Cu = " +lon_0=-104.3333333333333";
    var Cv = " +lon_0=-107.8333333333333";
    var Cw = " +lon_0=-76.58333333333333";
    var Cx = " +lon_0=-78.58333333333333";
    var Cy = " +lon_0=-120.8333333333333";
    var Cz = " +lon_0=-88.33333333333333";
    var DA = " +lon_0=-90.16666666666667";
    var DB = " +lon_0=-85.66666666666667";
    var DC = " +lon_0=-87.08333333333333";
    var DD = " +lon_0=-70.16666666666667";
    var DE = " +lon_0=-93.09999999999999";
    var DF = " +lon_0=-115.5833333333333";
    var DG = " +lon_0=-116.6666666666667";
    var DH = " +lon_0=-118.5833333333333";
    var DI = " +lon_0=-71.66666666666667";
    var DJ = " +lon_0=-105.1666666666667";
    var DK = " +lon_0=-107.3333333333333";
    var DL = " +lon_0=-110.0833333333333";
    var DM = " +lat_0=37.5";
    var DN = " +y_0=700000";
    var DO = " +towgs84=-242.2,-144.9,370.3,0,0,0,0";
    var DP = " +x_0=4500000";
    var DQ = " +y_0=1500000";
    var DR = " +x_0=599999.9999976";
    var DS = " +towgs84=-275.722,94.7824,340.894,-8.001,-4.42,-11.821,1";
    var DT = "+proj=aea";
    var DU = " +y_0=-2500000";
    var DV = " +lat_2=38.96666666666667";
    var DW = " +lat_1=41.66666666666666";
    var DX = " +lat_1=39.83333333333334";
    var DY = " +lat_2=38.33333333333334";
    var DZ = " +lat_2=37.06666666666667";
    var Da = " +lat_0=35.33333333333334";
    var Db = " +lat_1=35.46666666666667";
    var Dc = " +lat_2=34.03333333333333";
    var Dd = " +lat_1=33.88333333333333";
    var De = " +lat_2=32.78333333333333";
    var Df = " +lat_0=32.16666666666666";
    var Dg = " +lat_2=37.23333333333333";
    var Dh = " +lat_1=41.86666666666667";
    var Di = " +lat_0=40.83333333333334";
    var Dj = " +lat_2=29.58333333333333";
    var Dk = " +lat_2=41.71666666666667";
    var Dl = " +lat_1=41.03333333333333";
    var Dm = " +lat_2=40.66666666666666";
    var Dn = " +lat_1=36.76666666666667";
    var Do = " +lat_0=33.33333333333334";
    var Dp = " +lat_1=40.96666666666667";
    var Dq = " +lat_2=39.93333333333333";
    var Dr = " +lat_0=31.83333333333333";
    var Ds = " +lat_0=31.66666666666667";
    var Dt = " +lat_0=27.83333333333333";
    var Du = " +lat_2=36.76666666666667";
    var Dv = " +lat_0=45.33333333333334";
    var Dw = " +lat_0=45.16666666666666";
    var Dx = " +lat_1=36.23333333333333";
    var Dy = " +lat_2=34.93333333333333";
    var Dz = " +lat_1=34.76666666666667";
    var EA = " +lat_0=32.66666666666666";
    var EB = " +lat_1=43.26666666666667";
    var EC = " +lat_2=42.06666666666667";
    var ED = " +lat_2=40.61666666666667";
    var EE = " +lat_1=39.78333333333333";
    var EF = " +lat_2=38.71666666666667";
    var EG = " +lat_1=38.56666666666667";
    var EH = " +lat_2=37.26666666666667";
    var EI = " +lat_0=41.08333333333334";
    var EJ = " +lat_0=42.33333333333334";
    var EK = " +y_0=100000";
    var EL = " +b=6356173.508712696";
    var EM = " +y_0=5500000";
    var EN = " +lon_0=105";
    var EO = " +y_0=-5000000";
    var EP = " +k=0.9995000000000001";
    var EQ = " +k=0.9999749999999999";
    var ER = " +towgs84=-160,-6,-302,0,0,0,0";
    var ES = " +towgs84=307,304,-318,0,0,0,0";
    var ET = " +lon_0=-82.5";
    var EU = " +towgs84=70.995,-335.916,262.898,0,0,0,0";
    var EV = " +towgs84=-304.046,-60.576,103.64,0,0,0,0";
    var EW = " +x_0=700000";
    var EX = " +x_0=213360";
    var EY = " +lon_0=-85.75";
    var EZ = " +lon_0=-100.5";
    var Ea = " +lon_0=-77.75";
    var Eb = " +x_0=999999.9999898402";
    var Ec = " +towgs84=-151.99,287.04,-147.45,0,0,0,0";
    var Ed = " +lon_0=129";
    var Ee = " +a=6378293.645208759";
    var Ef = " +b=6356617.987679838";
    var Eg = " +x_0=5500000";
    var Eh = " +lat_1=40.78333333333333";
    var Ei = " +lat_2=39.71666666666667";
    var Ej = " +lat_1=37.93333333333333";
    var Ek = " +lat_2=36.73333333333333";
    var El = " +lat_1=42.68333333333333";
    var Em = " +lat_1=41.48333333333333";
    var En = " +lat_2=41.28333333333333";
    var Eo = " +lat_1=47.08333333333334";
    var Ep = " +lat_2=45.48333333333333";
    var Eq = " +lat_0=44.78333333333333";
    var Er = " +lat_2=44.18333333333333";
    var Es = " +lat_0=43.31666666666667";
    var Et = " +lat_1=36.16666666666666";
    var Eu = " +lat_2=34.33333333333334";
    var Ev = " +lat_2=47.43333333333333";
    var Ew = " +lat_1=47.48333333333333";
    var Ex = " +lat_2=46.18333333333333";
    var Ey = " +lat_2=35.56666666666667";
    var Ez = " +lat_1=35.23333333333333";
    var FA = " +lat_2=33.93333333333333";
    var FB = " +lat_2=40.88333333333333";
    var FC = " +lat_1=34.83333333333334";
    var FD = " +lat_1=36.41666666666666";
    var FE = " +lat_1=36.18333333333333";
    var FF = " +lat_1=33.96666666666667";
    var FG = " +lat_2=32.13333333333333";
    var FH = " +lat_1=31.88333333333333";
    var FI = " +lat_2=30.11666666666667";
    var FJ = " +lat_1=30.28333333333333";
    var FK = " +lat_2=28.38333333333333";
    var FL = " +lat_2=38.03333333333333";
    var FM = " +lat_1=47.33333333333334";
    var FN = " +lat_2=45.83333333333334";
    var FO = " +lat_1=46.76666666666667";
    var FP = " +lat_2=45.56666666666667";
    var FQ = " +lat_1=44.06666666666667";
    var FR = " +lat_2=42.73333333333333";
    var FS = " +lat_1=32.66666666666666";
    var FT = " +lat_2=31.16666666666667";
    var FU = " +lat_1=48.63333333333333";
    var FV = " +lat_2=47.03333333333333";
    var FW = " +lat_2=45.61666666666667";
    var FX = " +lat_1=45.21666666666667";
    var FY = " +lat_2=43.78333333333333";
    var FZ = " +lat_0=39.83333333333334";
    var Fa = " +lat_2=40.43333333333333";
    var Fb = " +lat_1=40.03333333333333";
    var Fc = " +lat_2=38.73333333333333";
    var Fd = " +lat_1=45.68333333333333";
    var Fe = " +lat_2=44.41666666666666";
    var Ff = " +lat_2=42.83333333333334";
    var Fg = " +lat_1=38.88333333333333";
    var Fh = " +lat_2=37.48333333333333";
    var Fi = " +lat_1=37.08333333333334";
    var Fj = " +lat_2=38.66666666666666";
    var Fk = " +lat_0=58";
    var Fl = " +lon_0=-98";
    var Fm = " +lon_0=117";
    var Fn = " +lon_0=135";
    var Fo = " +lat_0=41.5";
    var Fp = " +lat_0=42.5";
    var Fq = " +y_0=3000000";
    var Fr = " +lon_0=123";
    var Fs = " +lat_0=40";
    var Ft = " +lat_0=54";
    var Fu = " +towgs84=-192.873,-39.382,-111.202,-0.00205,-0.0005,0.00335,0.0188";
    var Fv = " +towgs84=565.417,50.3319,465.552,-0.398957,0.343988,-1.8774,4.0725";
    var Fw = " +x_0=914401.8289";
    var Fx = " +y_0=304800.6096";
    var Fy = " +lon_0=111";
    var Fz = " +k_0=0.99878641";
    var GA = " +lon_0=-66.43333333333334";
    var GB = " +towgs84=61,-285,-181,0,0,0,0";
    var GC = " +towgs84=-133,-77,-51,0,0,0,0";
    var GD = " +towgs84=-679,669,-48,0,0,0,0";
    var GE = " +lon_0=-71.5";
    var GF = " +lon_0=-78.5";
    var GG = " +lon_0=-93.5";
    var GH = " +lat_0=41.75";
    var GI = " +y_0=249999.9998983998";
    var GJ = " +y_0=999999.9999898402";
    var GK = " +to_meter=1.0000135965";
    var GL = " +a=6377304.063";
    var GM = " +lat_0=36";
    var GN = " +towgs84=-79.9,-158,-168.9,0,0,0,0";
    var GO = " +towgs84=-50.9,-347.6,-231,0,0,0,0";
    var GP = " +towgs84=-106.869,52.2978,-103.724,0.3366,-0.457,1.8422,-1.2747";
    var GQ = " +towgs84=283,682,231,0,0,0,0";
    var GR = " +towgs84=-206,172,-6,0,0,0,0";
    var GS = " +towgs84=-92,-93,122,0,0,0,0";
    var GT = " +to_meter=0.9143985307444408";
    var GU = "+proj=sterea";
    var GV = " +lat_0=21.16666666666667";
    var GW = " +lat_1=18.43333333333333";
    var GX = " +lat_2=18.03333333333333";
    var GY = " +lat_0=17.83333333333333";
    var GZ = " +gamma=323.1301023611111";
    var Ga = " +lon_0=-79.5";
    var Gb = " +y_0=4500000";
    var Gc = " +x_0=31500000";
    var Gd = " +x_0=500000.0001504";
    var Ge = " +b=6356514.96582849";
    var Gf = " +towgs84=674.4,15.1,405.3,0,0,0,0";
    var Gg = " +towgs84=-180.624,-225.516,173.919,-0.81,-1.898,8.336,16.7101";
    var Gh = " +towgs84=589,76,480,0,0,0,0";
    var Gi = " +towgs84=-263,6,431,0,0,0,0";
    var Gj = " +lon_0=15";
    var Gk = " +axis=wsu";
    var Gl = " +lon_0=21";
    var Gm = " +lat_0=30";
    var Gn = " +ellps=helmert";
    var Go = " +a=6377299.151";
    var Gp = " +lon_0=-74.5";
    var Gq = " +b=6356750.304921594";
    var Gr = " +y_0=2000000.0001016";
    var Gs = " +x_0=3500000.0001016";
    var Gt = " +y_0=399999.99998984";
    var Gu = " +x_0=200000.00001016";
    var Gv = " +b=6356098.359005156";
    var Gw = " +x_0=14500000";
    var Gx = " +x_0=29500000";
    var Gy = " +towgs84=-117,-132,-164,0,0,0,0";
    var Gz = " +zone=20";
    var HA = " +lon_0=-122";
    var HB = " +ellps=bess_nam";
    var HC = " +lon_0=-86.15000000000001";
    var HD = " +towgs84=-189,-242,-91,0,0,0,0";
    var HE = " +towgs84=-265,120,-358,0,0,0,0";
    var HF = " +towgs84=-73.472,-51.66,-112.482,0.953,4.6,-2.368,0.586";
    var HG = " +towgs84=-17.51,-108.32,-62.39,0,0,0,0";
    var HH = " +towgs84=-10.18,-350.43,291.37,0,0,0,0";
    var HI = " +towgs84=-190.421,8.532,238.69,0,0,0,0";
    var HJ = " +lon_0=-68.5";
    var HK = " +a=6377299.36559538";
    var HL = " +x_0=79999.99999968";
    var HM = " +x_0=50000.00001504";
    var HN = " +lon_0=0";
    var HO = " +lon_0=27";
    var HP = " +lon_0=75";
    var HQ = " +lon_0=81";
    var HR = " +lon_0=93";
    var HS = " +lon_0=99";
    var HT = " +x_0=900000";
    var HU = " +x_0=13500000";
    var HV = " +x_0=20500000";
    var HW = " +x_0=22500000";
    var HX = " +towgs84=-166,-15,204,0,0,0,0";
    var HY = " +towgs84=-130,110,-13,0,0,0,0";
    var HZ = " +towgs84=-587.8,519.75,145.76,0,0,0,0";
    var Ha = " +lat_2=83.66666666666667";
    var Hb = " +lat_0=85.43711833333333";
    var Hc = " +towgs84=-273.5,110.6,-357.9,0,0,0,0";
    var Hd = " +lon_0=87";
    var He = "+proj=laea";
    var Hf = " +towgs84=-403,684,41,0,0,0,0";
    var Hg = " +lon_0=-92.5";
    var Hh = " +y_0=6000000";
    var Hi = " +zone=19";
    var Hj = " +lat_0=29.5";
    var Hk = " +y_0=300000";
    var Hl = " +lat_2=45.5";
    var Hm = " +k=0.999909091";
    var Hn = " +a=6377492.018";
    var Ho = " +b=6356751.689189189";
    var Hp = " +b=6356100.230165384";
    var Hq = " +lon_0=90";
    var Hr = " +lat_0=90";
    var Hs = " +x_0=18500000";
    var Ht = " +x_0=19500000";
    var Hu = " +x_0=15500000";
    var Hv = " +x_0=16500000";
    var Hw = " +x_0=21500000";
    var Hx = " +x_0=23500000";
    var Hy = " +x_0=25500000";
    var Hz = " +x_0=26500000";
    var IA = " +x_0=27500000";
    var IB = " +x_0=28500000";
    var IC = " +zone=18";
    var ID = " +zone=21";
    var IE = " +towgs84=-124.76,53,466.79,0,0,0,0";
    var IF = " +lon_0=-92";
    var IG = " +lon_0=33";
    var IH = " +lon_0=12";
    var II = " +lon_0=24";
    var IJ = " +lat_2=77";
    var IK = " +y_0=200000";
    var IL = " +lon_0=-70.5";
    var IM = " +x_0=7500000";
    var IN = " +y_0=3500000";
    var IO = " +towgs84=31,146,47,0,0,0,0";
    var IP = " +lat_0=45";
    var IQ = " +lat_0=26";
    var IR = " +a=6378160";
    var IS = " +lon_0=-109.5";
    var IT = " +x_0=30500000";
    var IU = " +x_0=32500000";
    var IV = " +lon_0=-85.83333333333333";
    var IW = " +lon_0=-118.3333333333333";
    var IX = " +y_0=0.003048006096012192";
    var IY = " +lat_0=30.5";
    var IZ = " +lat_0=44";
    var Ia = " +lon_0=30";
    var Ib = " +lat_0=47";
    var Ic = " +lat_1=77";
    var Id = " +lat_0=36.16666666666666";
    var Ie = " +lat_0=4.596200416666666";
    var If = " +gamma=53.13010236111111";
    var Ig = " +lon_0=13.33333333333333";
    var Ih = " +lat_0=81.31722600000001";
    var Ii = " +lat_0=73.15574086111111";
    var Ij = " +lat_0=65.10127088888888";
    var Ik = " +zone=17";
    var Il = " +lon_0=132";
    var Im = " +lon_0=114";
    var In = " +towgs84=-143,-90,-294,0,0,0,0";
    var Io = " +zone=22";
    var Ip = " +lat_0=41";
    var Iq = " +lat_0=46.5";
    var Ir = " +lon_0=-118";
    var Is = " +y_0=400000";
    var It = " +x_0=17500000";
    var Iu = " +x_0=33500000";
    var Iv = " +lon_0=-113.75";
    var Iw = " +lon_0=-116.25";
    var Ix = " +lon_0=-115.75";
    var Iy = " +lon_0=-106.25";
    var Iz = " +k=0.999916667";
    var JA = " +k=0.999964286";
    var JB = " +lon_0=-108.75";
    var JC = " +towgs84=-73,-247,227,0,0,0,0";
    var JD = " +towgs84=265.025,384.929,-194.046,0,0,0,0";
    var JE = " +k=0.99998";
    var JF = " +lat_1=40.65";
    var JG = " +lat_1=38.35";
    var JH = " +y_0=2500000";
    var JI = " +y_0=6500000";
    var JJ = " +x_0=39999.99999984";
    var JK = " +towgs84=-61.702,284.488,472.052,0,0,0,0";
    var JL = " +towgs84=-223.237,110.193,36.649,0,0,0,0";
    var JM = " +zone=39";
    var JN = " +zone=32";
    var JO = " +towgs84=-125,53,467,0,0,0,0";
    var JP = " +towgs84=198,881,317,0,0,0,0";
    var JQ = " +towgs84=214,804,268,0,0,0,0";
    var JR = " +towgs84=217,823,299,0,0,0,0";
    var JS = " +lon_0=45";
    var JT = " +lat_1=43";
    var JU = "+proj=merc";
    var JV = " +x_0=99999.99998983997";
    var JW = " +x_0=99999.99999960001";
    var JX = " +x_0=2743195.592233322";
    var JY = " +y_0=914398.5307444407";
    var JZ = " +zone=38";
    var Ja = " +zone=28";
    var Jb = " +lon_0=-114";
    var Jc = " +lat_1=45.5";
    var Jd = " +towgs84=-73,46,-86,0,0,0,0";
    var Je = " +towgs84=11,72,-101,0,0,0,0";
    var Jf = " +towgs84=287.58,177.78,-135.41,0,0,0,0";
    var Jg = " +towgs84=-162.619,-276.959,-161.764,0.067753,-2.24365,-1.15883,-1.09425";
    var Jh = " +lon_0=-87";
    var Ji = " +lon_0=-99";
    var Jj = " +lon_0=102";
    var Jk = " +lon_0=126";
    var Jl = " +k=0.99999";
    var Jm = " +x_0=50000";
    var Jn = " +lat_2=40";
    var Jo = " +lon_0=-84.25";
    var Jp = " +x_0=11500000";
    var Jq = " +lon_0=-72.75";
    var Jr = " +lon_0=-101.5";
    var Js = " +lon_0=-94.25";
    var Jt = " +x_0=6500000";
    var Ju = " +y_0=5000000";
    var Jv = " +x_0=1700000";
    var Jw = " +towgs84=31.95,300.99,419.19,0,0,0,0";
    var Jx = " +towgs84=-189.681,18.3463,-42.7695,-0.33746,-3.09264,2.53861,0.4598";
    var Jy = " +towgs84=-119.425,-303.659,-11.0006,1.1643,0.174458,1.09626,3.65706";
    var Jz = " +towgs84=982.609,552.753,-540.873,6.68163,-31.6115,-19.8482,16.805";
    var KA = " +zone=29";
    var KB = " +lon_0=9";
    var KC = " +zone=33";
    var KD = " +zone=37";
    var KE = " +no_uoff";
    var KF = " +lon_0=120";
    var KG = " +lon_0=177";
    var KH = " +lon_0=-177";
    var KI = " +lon_0=-158";
    var KJ = " +y_0=250000";
    var KK = " +lon_0=-111";
    var KL = " +x_0=2500000.0001424";
    var KM = " +x_0=1500000.0001464";
    var KN = " +lon_0=-71.60561777777777";
    var KO = " +lon_0=-156.6666666666667";
    var KP = " +lon_0=-160.1666666666667";
    var KQ = " +lat_0=0.1166666666666667";
    var KR = " +towgs84=0,0,0,-0,-0,-0,0";
    var KS = " +lon_0=-117.8333333333333";
    var KT = " +lon_0=-123.1666666666667";
    var KU = " +lon_0=-122.3333333333333";
    var KV = " +lon_0=-119.1666666666667";
    var KW = " +lon_0=-123.0833333333333";
    var KX = " +lon_0=-85.84999999999999";
    var KY = " +lon_0=-87.09999999999999";
    var KZ = " +lon_0=-86.90000000000001";
    var Ka = " +lon_0=-89.24166666666667";
    var Kb = " +lon_0=-92.63333333333334";
    var Kc = " +towgs84=347.103,1078.12,2623.92,-33.8875,70.6773,-9.3943,186.074";
    var Kd = " +towgs84=8.846,-4.394,-1.122,-0.00237,-0.146528,0.130428,0.783926";
    var Ke = " +towgs84=-480.26,-438.32,-643.429,16.3119,20.1721,-4.0349,-111.7";
    var Kf = " +towgs84=-0.293,766.95,87.713,0.195704,1.69507,3.47302,-0.039338";
    var Kg = " +towgs84=221.525,152.948,176.768,-2.3847,-1.3896,-0.877,11.4741";
    var Kh = " +towgs84=215.525,149.593,176.229,-3.2624,-1.692,-1.1571,10.4773";
    var Ki = " +zone=35";
    var Kj = " +lat_0=46.95240555555556";
    var Kk = " +alpha=30.28813972222222";
    var Kl = " +lat_1=10.16666666666667";
    var Km = " +lat_0=10.16666666666667";
    var Kn = " +lat_0=18.83333333333333";
    var Ko = " +lat_0=20.33333333333333";
    var Kp = " +lat_0=21.83333333333333";
    var Kq = " +lat_0=21.66666666666667";
    var Kr = " +lat_0=45.30916666666666";
    var Ks = " +lat_1=49.83333333333334";
    var Kt = " +lat_2=51.16666666666666";
    var Ku = " +lonc=-133.6666666666667";
    var Kv = " +alpha=323.1301023611111";
    var Kw = " +lat_1=53.83333333333334";
    var Kx = " +lat_2=51.83333333333334";
    var Ky = " +lat_1=44.66666666666666";
    var Kz = " +lat_0=44.66666666666666";
    var LA = " +lat_1=45.66666666666666";
    var LB = " +lat_0=45.91666666666666";
    var LC = " +lat_0=45.08333333333334";
    var LD = " +lat_0=44.33333333333334";
    var LE = " +lat_0=44.08333333333334";
    var LF = " +lat_1=48.33333333333334";
    var LG = " +lat_0=48.33333333333334";
    var LH = " +lat_0=31.73409694444445";
    var LI = " +lon_0=35.21208055555556";
    var LJ = " +lat_0=44.03611111111111";
    var LK = " +lat_0=4.599047222222222";
    var LL = " +lat_0=40.66666666666666";
    var LM = " +lat_1=49";
    var LN = " +lon_0=39";
    var LO = " +lat_1=37.25";
    var LP = " +lat_1=39.75";
    var LQ = " +lat_2=38.45";
    var LR = " +lat_1=30.75";
    var LS = " +lon_0=-84.5";
    var LT = " +lat_0=33.75";
    var LU = " +x_0=4000000";
    var LV = " +y_0=4000000";
    var LW = " +lon_0=-72.5";
    var LX = " +x_0=5000000";
    var LY = " +x_0=10500000";
    var LZ = " +x_0=12500000";
    var La = " +x_0=24500000";
    var Lb = " +k=0.99999375";
    var Lc = " +x_0=399999.9999984";
    var Ld = " +lon_0=-77";
    var Le = " +lon_0=108";
    var Lf = " +lon_0=171";
    var Lg = " +towgs84=-179.483,-69.379,-27.584,-7.862,8.163,6.042,-13.925";
    var Lh = " +lon_0=-171";
    var Li = " +lat_0=32.5";
    var Lj = " +lon_0=-117";
    var Lk = " +k=1.000015";
    var Ll = " +k=1.000034";
    var Lm = " +k=1.000031";
    var Ln = " +k=1.000026";
    var Lo = " +ellps=evrstSS";
    var Lp = " +a=6377301.243";
    var Lq = " +towgs84=410.721,55.049,80.746,2.5779,2.3514,0.6664,17.3311";
    var Lr = " +towgs84=72.438,345.918,79.486,1.6045,0.8823,0.5565,1.3746";
    var Ls = " +pm=ferro";
    var Lt = " +lon_0=78";
    var Lu = " +lon_0=10";
    var Lv = " +pm=paris";
    var Lw = " +towgs84=0.055,-0.541,-0.185,0.0183,-0.0003,-0.007,-0.014";
    var Lx = " +towgs84=446.448,-125.157,542.06,0.15,0.247,0.842,-20.489";
    var Ly = " +towgs84=8.853,-52.644,180.304,-0.393,-2.323,2.96,-24.081";
    var Lz = " +towgs84=572.213,85.334,461.94,4.9732,1.529,5.2484,3.5378";
    var MA = " +zone=58";
    var MB = " +zone=23";
    var MC = " +x_0=304800.6096012192";
    var MD = " +y_0=152400.3048006096";
    var ME = " +x_0=800000.0001016001";
    var MF = " +x_0=399999.9998983998";
    var MG = " +x_0=7999999.999968001";
    var MH = " +x_0=5999999.999976001";
    var MI = " +x_0=830000.0001016001";
    var MJ = " +x_0=249999.9998983998";
    var MK = " +x_0=350000.0001016001";
    var ML = " +to_meter=0.3047972654";
    var MM = " +x_0=99999.99989839978";
    var MN = " +y_0=8000000.000010163";
    var MO = " +x_0=699999.9999898402";
    var MP = " +lon_0=-69";
    var MQ = " +lon_0=-86";
    var MR = " +towgs84=-3.2,-5.7,2.8,0,0,0,0";
    var MS = " +x_0=8500000";
    var MT = " +x_0=9500000";
    var MU = " +lat_1=39.45";
    var MV = " +lat_0=44.25";
    var MW = " +lat_1=41.95";
    var MX = " +lat_2=35.25";
    var MY = " +lat_2=34.65";
    var MZ = " +lat_2=44.25";
    var Ma = " +lat_1=47.05";
    var Mb = " +lat_1=40.25";
    var Mc = " +k_0=1.00012";
    var Md = " +lat_0=40.25";
    var Me = " +zone=40";
    var Mf = " +zone=36";
    var Mg = " +zone=51";
    var Mh = " +zone=48";
    var Mi = " +zone=49";
    var Mj = " +lon_0=96";
    var Mk = " +y_0=750000";
    var Ml = " +lat_0=36.5";
    var Mm = " +lon_0=-119";
    var Mn = " +lat_0=33.5";
    var Mo = " +lat_2=41.2";
    var Mp = " +k=0.999995";
    var Mq = " +lat_2=33.3";
    var Mr = " +lat_0=38.5";
    var Ms = " +lon_0=-154";
    var Mt = " +lon_0=-120";
    var Mu = " +x_0=34500000";
    var Mv = " +x_0=35500000";
    var Mw = " +x_0=36500000";
    var Mx = " +x_0=37500000";
    var My = " +x_0=38500000";
    var Mz = " +x_0=39500000";
    var NA = " +x_0=40500000";
    var NB = " +x_0=41500000";
    var NC = " +x_0=43500000";
    var ND = " +x_0=45500000";
    var NE = " +y_0=3999999.99998984";
    var NF = " +y_0=2000000.00001016";
    var NG = " +towgs84=164,138,-189,0,0,0,0";
    var NH = " +towgs84=-186,230,110,0,0,0,0";
    var NI = " +towgs84=-199,32,322,0,0,0,0";
    var NJ = " +to_meter=0.3047997101815088";
    var NK = " +towgs84=-76,-138,67,0,0,0,0";
    var NL = " +towgs84=-43,-163,45,0,0,0,0";
    var NM = " +towgs84=-346,-1,224,0,0,0,0";
    var NN = " +towgs84=210,814,289,0,0,0,0";
    var NO = " +towgs84=-74,-130,42,0,0,0,0";
    var NP = " +zone=15";
    var NQ = " +zone=16";
    var NR = " +zone=34";
    var NS = " +zone=50";
    var NT = " +zone=52";
    var NU = " +lon_0=-62";
    var NV = " +lon_0=-84";
    var NW = " +lon_0=-79";
    var NX = " +lon_0=131";
    var NY = " +lon_0=153";
    var NZ = " +lon_0=165";
    var Na = " +lon_0=-94";
    var Nb = " +lon_0=-54";
    var Nc = " +a=6378300.789";
    var Nd = " +b=6356566.435";
    var Ne = " +y_0=3999999.9998984";
    var Nf = " +y_0=5000000.0001016";
    var Ng = " +x_0=150000.00001464";
    var Nh = " +lat_2=46";
    var Ni = " +lon_0=84";
    var Nj = " +lat_0=43";
    var Nk = " +k_0=0.999625769";
    var Nl = " +towgs84=51,391,-36,0,0,0,0";
    var Nm = " +towgs84=-83,37,124,0,0,0,0";
    var Nn = " +towgs84=-355,21,72,0,0,0,0";
    var No = " +towgs84=-23,259,-9,0,0,0,0";
    var Np = " +towgs84=174.05,-25.49,112.57,-0,-0,0.554,0.2263";
    var Nq = " +zone=59";
    var Nr = " +zone=25";
    var Ns = " +zone=11";
    var Nt = " +zone=12";
    var Nu = " +zone=13";
    var Nv = " +zone=54";
    var Nw = " +zone=14";
    var Nx = " +zone=24";
    var Ny = " +zone=47";
    var Nz = " +lat_2=38.3";
    var OA = " +lat_1=45.7";
    var OB = " +lat_2=42.1";
    var OC = " +x_0=165000";
    var OD = " +lat_2=32.5";
    var OE = " +x_0=609600";
    var OF = " +lat_1=39.2";
    var OG = " +lat_2=47.5";
    var OH = " +lat_1=30.7";
    var OI = " +lat_2=29.3";
    var OJ = " +lat_0=28.5";
    var OK = " +lat_1=41.7";
    var OL = " +lat_1=44.4";
    var OM = " +lat_1=27.5";
    var ON = " +lon_0=-150";
    var OO = " +lat_0=44.5";
    var OP = " +k=1.000027";
    var OQ = " +k=1.000038";
    var OR = " +k=1.000036";
    var OS = " +lon_0=-87.5";
    var OT = " +x_0=3999999.999984";
    var OU = " +x_0=199999.9999992";
    var OV = " +towgs84=16,196,93,0,0,0,0";
    var OW = " +towgs84=-88,4,101,0,0,0,0";
    var OX = " +lat_0=18";
    var OY = " +lat_2=67";
    var OZ = " +lon_0=-96";
    var Oa = " +x_0=80000";
    var Ob = " +lon_0=-82";
    var Oc = " +lon_0=-74";
    var Od = " +lon_0=147";
    var Oe = " +lon_0=150";
    var Of = " +x_0=40000";
    var Og = " +k=1.00002";
    var Oh = " +x_0=42500000";
    var Oi = " +x_0=44500000";
    var Oj = " +lon_0=-85.05";
    var Ok = " +ellps=mod_airy";
    var Ol = " +lat_0=0.1333333333333333";
    var Om = " +lat_1=-60.66666666666666";
    var On = " +lat_2=-63.33333333333334";
    var Oo = " +lon_0=-91.91666666666667";
    var Op = " +y_0=0.003352806705613411";
    var Oq = " +zone=30";
    var Or = " +lon_0=3";
    var Os = " +zone=26";
    var Ot = " +zone=53";
    var Ou = " +lat_0=31.73439361111111";
    var Ov = " +lon_0=35.20451694444445";
    var Ow = " +lon_0=7.439583333333333";
    var Ox = " +lon_0=132.1666666666667";
    var Oy = " +lon_0=134.3333333333333";
    var Oz = " +lon_0=137.1666666666667";
    var PA = " +lon_0=139.8333333333333";
    var PB = " +lon_0=140.8333333333333";
    var PC = " +lon_0=3.192280555555556";
    var PD = " +lat_1=49.50000000000001";
    var PE = " +lat_0=49.50000000000001";
    var PF = " +alpha=53.31582047222222";
    var PG = " +lon_0=10.33333333333333";
    var PH = " +lon_0=16.33333333333333";
    var PI = " +towgs84=-502.862,-247.438,312.724,0,0,0,0";
    var PJ = " +towgs84=-381.788,-57.501,-256.673,0,0,0,0";
    var PK = " +towgs84=-43.685,-179.785,-267.721,0,0,0,0";
    var PL = " +zone=60";
    var PM = " +zone=55";
    var PN = " +lon_0=36";
    var PO = " +lon_0=42";
    var PP = " +lat_1=46";
    var PQ = " +lat_1=44";
    var PR = " +lat_0=42";
    var PS = " +lon_0=51";
    var PT = " +lat_0=33";
    var PU = " +lat_0=52";
    var PV = " +ellps=airy";
    var PW = " +pm=jakarta";
    var PX = " +x_0=2743195.5";
    var PY = " +y_0=-4354009.816";
    var PZ = " +k_0=0.9987864078000001";
    var Pa = " +towgs84=-106.226,166.366,-37.893,0,0,0,0";
    var Pb = " +towgs84=508.088,-191.042,565.223,0,0,0,0";
    var Pc = " +k=0.99996";
    var Pd = " +a=6378135";
    var Pe = " +lon_0=-66";
    var Pf = " +lon_0=141";
    var Pg = " +lon_0=159";
    var Ph = " +k=0.99984";
    var Pi = " +lat_0=-22";
    var Pj = " +lon_0=127.5";
    var Pk = " +x_0=6000000";
    var Pl = " +x_0=3900000";
    var Pm = " +y_0=1300000";
    var Pn = " +lat_0=44.75";
    var Po = " +lat_0=37.75";
    var Pp = " +lat_0=40.55";
    var Pq = " +lon_0=-87.3";
    var Pr = " +lon_0=-86.5";
    var Ps = " +towgs84=195.671,332.517,274.607,0,0,0,0";
    var Pt = " +towgs84=-204.619,140.176,55.226,0,0,0,0";
    var Pu = "+proj=somerc";
    var Pv = " +y_0=30480.06096012192";
    var Pw = " +y_0=999999.9999960001";
    var Px = " +x_0=182880.3657607315";
    var Py = " +towgs84=674.374,15.056,405.346,0,0,0,0";
    var Pz = " +towgs84=-133.63,-157.5,-158.62,0,0,0,0";
    var QA = " +towgs84=-0.465,372.095,171.736,0,0,0,0";
    var QB = " +towgs84=-56.263,16.136,-22.856,0,0,0,0";
    var QC = " +towgs84=-241.54,-163.64,396.06,0,0,0,0";
    var QD = " +zone=31";
    var QE = " +zone=10";
    var QF = " +zone=46";
    var QG = " +x_0=304800.6096";
    var QH = " +y_0=152400.3048";
    var QI = " +alpha=337.25556";
    var QJ = " +x_0=2546731.496";
    var QK = " +gamma=337.25556";
    var QL = " +k_0=0.999625544";
    var QM = " +towgs84=335.47,222.58,-230.94,0,0,0,0";
    var QN = " +towgs84=217.037,86.959,23.956,0,0,0,0";
    var QO = " +towgs84=-128.16,-282.42,21.93,0,0,0,0";
    var QP = " +towgs84=103.25,-100.4,-307.19,0,0,0,0";
    var QQ = " +lon_0=31";
    var QR = " +lon_0=18";
    var QS = " +lat_2=36";
    var QT = " +lat_0=29";
    var QU = " +lat_0=35";
    var QV = " +lat_0=34";
    var QW = " +lon_0=63";
    var QX = " +lat_0=37";
    var QY = " +lat_2=65";
    var QZ = " +y_0=-4000000";
    var Qa = " +y_0=914398.5";
    var Qb = " +towgs84=-199.87,74.79,246.62,0,0,0,0";
    var Qc = " +towgs84=-11.64,-348.6,291.98,0,0,0,0";
    var Qd = " +towgs84=-254.1,-5.36,-100.29,0,0,0,0";
    var Qe = " +towgs84=-206.1,-174.7,-87.7,0,0,0,0";
    var Qf = " +towgs84=-770.1,158.4,-498.2,0,0,0,0";
    var Qg = " +towgs84=-146.21,112.63,4.05,0,0,0,0";
    var Qh = " +towgs84=-294.7,-200.1,525.5,0,0,0,0";
    var Qi = " +lat_0=4";
    var Qj = " +a=6378300";
    var Qk = " +lon_0=-63";
    var Ql = " +lon_0=162";
    var Qm = " +lat_ts=90";
    var Qn = " +y_0=600000";
    var Qo = " +x_0=350000";
    var Qp = " +y_0=900000";
    var Qq = " +lat_1=32.5";
    var Qr = " +lon_0=-147";
    var Qs = " +k=1.000043";
    var Qt = " +lat_0=48.5";
    var Qu = " +lat_0=40.9";
    var Qv = " +k=1.000028";
    var Qw = " +k=1.000025";
    var Qx = " +x_0=170251.555";
    var Qy = " +b=6356657.142669561";
    var Qz = " +b=6356094.667915204";
    var RA = " +b=6355862.933255573";
    var RB = " +a=6378249.144808011";
    var RC = " +b=6356514.966204134";
    var RD = " +towgs84=-70.9,-151.8,-41.4,0,0,0,0";
    var RE = " +towgs84=52.17,-71.82,-14.9,0,0,0,0";
    var RF = " +towgs84=283.7,735.9,261.1,0,0,0,0";
    var RG = " +zone=5";
    var RH = " +zone=7";
    var RI = " +lon_0=19";
    var RJ = " +lon_0=25";
    var RK = " +lat_2=45";
    var RL = " +lon_0=57";
    var RM = " +lon_0=69";
    var RN = " +lat_2=39";
    var RO = " +lat_2=35";
    var RP = " +lon_0=28";
    var RQ = " +lon_0=-61.5";
    var RR = " +lon_0=-64.5";
    var RS = " +lon_0=-90.5";
    var RT = " +lon_0=-94.5";
    var RU = " +y_0=2800000";
    var RV = " +x_0=4321000";
    var RW = " +y_0=3210000";
    var RX = " +y_0=14743.5";
    var RY = " +y_0=1999999.999992";
    var RZ = " +y_0=2999999.999988";
    var Ra = " +y_0=50000.00001504";
    var Rb = " +zone=41";
    var Rc = " +zone=42";
    var Rd = " +k=0.994";
    var Re = " +zone=56";
    var Rf = " +lon_0=-67.875";
    var Rg = " +lon_0=-70.375";
    var Rh = " +x_0=609601.22";
    var Ri = " +b=6356889.449";
    var Rj = " +lon_0=-69.125";
    var Rk = " +lon_0=-121.75";
    var Rl = " +lon_0=-121.25";
    var Rm = " +lon_0=-119.75";
    var Rn = " +lon_0=-122.75";
    var Ro = " +zone=6";
    var Rp = "+proj=krovak";
    var Rq = " +towgs84=-637,-549,-203,0,0,0,0";
    var Rr = " +towgs84=-20.8,11.3,2.4,0,0,0,0";
    var Rs = " +lon_0=-93";
    var Rt = " +lon_0=127";
    var Ru = " +lon_0=125";
    var Rv = " +k=0.99975";
    var Rw = " +lon_0=136";
    var Rx = " +lon_0=138";
    var Ry = " +lon_0=180";
    var Rz = " +y_0=50000";
    var SA = " +lon_0=-85";
    var SB = " +k=1.00016";
    var SC = " +lon_0=2.7";
    var SD = " +towgs84=27.5,14,186.4,0,0,0,0";
    var SE = " +towgs84=-499,-249,314,0,0,0,0";
    var SF = " +towgs84=-467,-16,-300,0,0,0,0";
    var SG = " +towgs84=-382,-59,-262,0,0,0,0";
    var SH = " +towgs84=253,-132,-127,0,0,0,0";
    var SI = " +towgs84=-963,510,-359,0,0,0,0";
    var SJ = " +towgs84=94,-948,-1262,0,0,0,0";
    var SK = " +zone=1";
    var SL = " +zone=27";
    var SM = " +zone=57";
    var SN = " +pm=oslo";
    var SO = " +zone=43";
    var SP = " +lon_0=23";
    var SQ = " +lon_0=48";
    var SR = " +lon_0=54";
    var SS = " +lat_0=49.5";
    var ST = " +k=0.999912";
    var SU = " +lon_0=-174";
    var SV = " +lon_0=-168";
    var SW = " +lon_0=-170";
    var SX = " +lon_0=-165";
    var SY = " +lat_2=40.5";
    var SZ = " +lon_0=-115";
    var Sa = " +lat_1=29.5";
    var Sb = " +k=1.000045";
    var Sc = " +lat_1=39.5";
    var Sd = " +lat_1=33.3";
    var Se = " +lat_0=33.3";
    var Sf = " +lon_0=-155.5";
    var Sg = " +lon_0=-159.5";
    var Sh = " +y_0=-4480000";
    var Si = " +lon_0=-176.5";
    var Sj = " +lon_0=-89.75";
    var Sk = " +k_0=1.000008";
    var Sl = " +lonc=-124.05";
    var Sm = " +k_0=1.000002";
    var Sn = " +lon_0=-122.5";
    var So = " +lon_0=-98.25";
    var Sp = " +lon_0=-112.5";
    var Sq = " +lon_0=-84.95";
    var Sr = " +lon_0=-86.95";
    var Ss = " +lon_0=-85.45";
    var St = " +lon_0=-87.45";
    var Su = " +lon_0=-87.55";
    var Sv = " +towgs84=-149,128,296,0,0,0,0";
    var Sw = " +towgs84=-425,-169,81,0,0,0,0";
    var Sx = " +towgs84=-104,167,-38,0,0,0,0";
    var Sy = " +towgs84=-106,-87,188,0,0,0,0";
    var Sz = " +towgs84=-289,-124,60,0,0,0,0";
    var TA = " +towgs84=137,248,-430,0,0,0,0";
    var TB = " +towgs84=-13,-348,292,0,0,0,0";
    var TC = " +towgs84=-115,118,426,0,0,0,0";
    var TD = " +towgs84=0,-0.15,0.68,0,0,0,0";
    var TE = " +towgs84=145,-187,103,0,0,0,0";
    var TF = " +towgs84=-134,229,-29,0,0,0,0";
    var TG = " +towgs84=70,207,389.5,0,0,0,0";
    var TH = " +towgs84=-148,51,-291,0,0,0,0";
    var TI = " +towgs84=-255,-15,71,0,0,0,0";
    var TJ = " +towgs84=725,685,536,0,0,0,0";
    var TK = " +towgs84=72,213.7,93,0,0,0,0";
    var TL = " +towgs84=174,359,365,0,0,0,0";
    var TM = " +towgs84=-173,253,27,0,0,0,0";
    var TN = " +towgs84=-203,141,53,0,0,0,0";
    var TO = " +towgs84=186,482,151,0,0,0,0";
    var TP = " +towgs84=162,117,154,0,0,0,0";
    var TQ = " +towgs84=-73,213,296,0,0,0,0";
    var TR = " +towgs84=-130,29,364,0,0,0,0";
    var TS = " +towgs84=-10,375,165,0,0,0,0";
    var TT = " +towgs84=175,-38,113,0,0,0,0";
    var TU = " +to_meter=0.9143984146160287";
    var TV = " +zone=2";
    var TW = " +zone=8";
    var TX = " +zone=9";
    var TY = " +zone=4";
    var TZ = " +towgs84=30,430,368,0,0,0,0";
    var Ta = " +towgs84=185,165,42,0,0,0,0";
    var Tb = " +towgs84=-97,787,86,0,0,0,0";
    var Tc = " +towgs84=639,405,60,0,0,0,0";
    var Td = " +zone=44";
    var Te = " +zone=45";
    var Tf = " +lon_0=-58.5";
    var Tg = " +lon_0=-67.5";
    var Th = " +lon_0=-73.5";
    var Ti = " +lon_0=-76.5";
    var Tj = " +y_0=1200000";
    var Tk = " +lon_0=133.5";
    var Tl = " +x_0=8000000";
    var Tm = " +y_0=8000000";
    var Tn = " +k=0.9998335";
    var To = " +lon_0=-85.5";
    var Tp = " +x_0=7000000";
    var Tq = " +lat_0=43.75";
    var Tr = " +lat_0=43.25";
    var Ts = " +lat_0=45.25";
    var Tt = " +lon_0=-86.3";
    var Tu = " +lat_0=38.15";
    var Tv = " +lat_0=39.15";
    var Tw = " +lat_0=41.25";
    var Tx = " +lat_0=40.65";
    var Ty = " +lat_0=39.25";
    var Tz = " +lat_0=40.35";
    var UA = " +lon_0=-85.8";
    var UB = " +towgs84=9,183,236,0,0,0,0";
    var UC = " +towgs84=-48,55,52,0,0,0,0";
    var UD = " +towgs84=84,274,65,0,0,0,0";
    var UE = " +lon_0=17";
    var UF = " +lat_1=60";
    var UG = " +k=0.9998";
    var UH = " +lon_0=66";
    var UI = " +lon_0=20";
    var UJ = " +lon_0=26";
    var UK = " +lat_0=51";
    var UL = " +lat_1=87";
    var UM = " +lat_1=26";
    var UN = " +lon_0=144";
    var UO = " +lon_0=168";
    var UP = " +lon_0=174";
    var UQ = " +lon_0=-72";
    var UR = " +lon_0=-75";
    var US = " +lon_0=-60";
    var UT = " +lon_0=-39";
    var UU = "+proj=poly";
    var UV = " +x_0=219529.584";
    var UW = " +a=6378306.3696";
    var UX = " +lon_0=-61.33333333333334";
    var UY = " +lon_0=-91.86666666666666";
    var UZ = " +lon_0=-8.131906111111112";
    var Ua = " +lon_0=-83.66666666666667";
    var Ub = " +lon_0=-108.4166666666667";
    var Uc = " +lon_0=-108.3333333333333";
    var Ud = " +lon_0=-85.40000000000001";
    var Ue = " +lon_0=-86.65000000000001";
    var Uf = " +lon_0=-86.40000000000001";
    var Ug = " +lon_0=-85.59999999999999";
    var Uh = " +lon_0=-87.15000000000001";
    var Ui = " +lon_0=-86.59999999999999";
    var Uj = " +lon_0=-84.90000000000001";
    var Uk = " +lon_0=-85.65000000000001";
    var Ul = " +lon_0=-87.65000000000001";
    var Um = " +lon_0=-85.34999999999999";
    var Un = " +lon_0=-87.40000000000001";
    var Uo = " +lon_0=-87.34999999999999";
    var Up = " +lon_0=-85.90000000000001";
    var Uq = " +lon_0=-90.62222222222222";
    var Ur = " +lon_0=-91.84999999999999";
    var Us = " +lon_0=-91.15277777777779";
    var Ut = " +lon_0=-91.79722222222222";
    var Uu = " +lon_0=-92.45777777777778";
    var Uv = " +lon_0=-91.29444444444444";
    var Uw = " +lon_0=-90.70833333333334";
    var Ux = " +lon_0=-89.39444444444445";
    var Uy = " +lon_0=-89.42222222222223";
    var Uz = " +lon_0=-88.77500000000001";
    var VA = " +lon_0=-87.27222222222223";
    var VB = " +lon_0=-91.89444444444445";
    var VC = " +lon_0=-91.28888888888889";
    var VD = " +lon_0=-88.14166666666668";
    var VE = " +lon_0=-88.63333333333334";
    var VF = " +lon_0=-89.83888888888889";
    var VG = " +lon_0=-90.16111111111111";
    var VH = " +lon_0=-90.25555555555556";
    var VI = " +lon_0=-90.84429651944444";
    var VJ = " +lon_0=-87.89444444444445";
    var VK = " +lon_0=-91.31666666666666";
    var VL = " +lon_0=-89.03333333333333";
    var VM = " +lon_0=-89.73333333333333";
    var VN = " +lon_0=-87.71111111111111";
    var VO = " +lon_0=-88.41666666666667";
    var VP = " +lon_0=-90.64166666666668";
    var VQ = " +lon_0=-87.90833333333335";
    var VR = " +lon_0=-89.54444444444444";
    var VS = " +lon_0=-92.22777777777777";
    var VT = " +lon_0=-90.48888888888889";
    var VU = " +lon_0=-90.43055555555556";
    var VV = " +lon_0=-89.07222222222222";
    var VW = " +lon_0=-91.06666666666666";
    var VX = " +lon_0=-89.90000000000001";
    var VY = " +lon_0=-91.11666666666666";
    var VZ = " +lon_0=-88.60555555555555";
    var Va = " +lon_0=-90.48333333333333";
    var Vb = " +lon_0=-91.36666666666666";
    var Vc = " +lon_0=-90.78333333333333";
    var Vd = " +lon_0=-89.48888888888889";
    var Ve = " +lon_0=-88.54166666666667";
    var Vf = " +lon_0=-91.78333333333333";
    var Vg = " +lon_0=-88.06388888888888";
    var Vh = " +lon_0=-88.22499999999999";
    var Vi = " +lon_0=-88.81666666666666";
    var Vj = " +y_0=0.004876809753619507";
    var Vk = " +y_0=0.008534417068834137";
    var Vl = " +y_0=0.003962407924815849";
    var Vm = " +y_0=0.005791211582423164";
    var Vn = " +lon_0=-55.68333333333333";
    var Vo = " +to_meter=0.201166195164";
    var Vp = " +lat_0=4.666666666666667";
    var Vq = " +lat_0=6.666666666666667";
    var Vr = " +lon_0=6.166666666666667";
    var Vs = " +lat_0=10.44166666666667";
    var Vt = " +lat_0=22.31213333333334";
    var Vu = " +lon_0=114.1785555555556";
    var Vv = " +lon_0=51.21666666666667";
    var Vw = " +lon_0=11.30827777777778";
    var Vx = " +lon_0=13.55827777777778";
    var Vy = " +lon_0=15.80827777777778";
    var Vz = " +lon_0=18.05827777777778";
    var WA = " +lon_0=20.30827777777778";
    var WB = " +lon_0=22.55827777777778";
    var WC = " +lat_1=27.41666666666667";
    var WD = " +lat_2=34.91666666666666";
    var WE = " +lat_0=31.16666666666667";
    var WF = " +lat_1=59.33333333333334";
    var WG = " +lat_0=57.51755393055556";
    var WH = " +lon_0=4.359215833333333";
    var WI = " +lat_1=61.66666666666666";
    var WJ = " +lat_0=29.02626833333333";
    var WK = " +lat_1=48.66666666666666";
    var WL = " +lat_2=53.66666666666666";
    var WM = " +lon_0=127.0028902777778";
    var WN = " +lon_0=89.84999999999999";
    var WO = " +lon_0=91.56666666666666";
    var WP = " +lon_0=24.83333333333333";
    var WQ = " +lat_2=63.66666666666666";
    var WR = " +lat_0=65.35103930555555";
    var WS = " +lat_1=63.66666666666666";
    var WT = " +lat_2=60.33333333333334";
    var WU = " +lat_0=62.01530688888889";
    var WV = " +lat_1=45.78333333333333";
    var WW = " +lat_0=45.78333333333333";
    var WX = " +lat_0=42.66666666666666";
    var WY = " +lat_0=43.36666666666667";
    var WZ = " +lat_0=45.70611111111111";
    var Wa = " +lat_0=45.13333333333333";
    var Wb = " +lat_1=46.66964837722222";
    var Wc = " +lat_0=46.66964837722222";
    var Wd = " +lat_0=43.48138888888889";
    var We = " +lat_1=45.89871486583333";
    var Wf = " +lat_0=45.89871486583333";
    var Wg = " +lat_0=42.71944444444445";
    var Wh = " +lat_1=44.97785689861112";
    var Wi = " +lat_0=44.97785689861112";
    var Wj = " +lat_1=43.46254664583333";
    var Wk = " +lat_0=43.46254664583333";
    var Wl = " +lon_0=-90.9388888888889";
    var Wm = " +lat_0=41.47222222222222";
    var Wn = " +lat_0=45.88333333333333";
    var Wo = " +lat_0=44.40833333333333";
    var Wp = " +lat_1=44.87228112638889";
    var Wq = " +lat_0=44.87228112638889";
    var Wr = " +lat_0=45.43888888888888";
    var Ws = " +lat_0=44.00555555555555";
    var Wt = " +lat_0=41.41111111111111";
    var Wu = " +lat_1=42.63756227694444";
    var Wv = " +lat_0=42.63756227694444";
    var Ww = " +lat_1=43.80700011777778";
    var Wx = " +lat_0=43.80700011777778";
    var Wy = " +lat_0=42.53888888888888";
    var Wz = " +lat_0=45.43333333333333";
    var XA = " +lat_0=44.25333512777778";
    var XB = " +lat_0=42.21666666666667";
    var XC = " +lat_0=43.26666666666667";
    var XD = " +lat_0=43.45111111111111";
    var XE = " +lat_1=45.15423710527778";
    var XF = " +lat_0=45.15423710527778";
    var XG = " +lat_0=44.84444444444445";
    var XH = " +lat_1=44.90090442361111";
    var XI = " +lat_0=44.90090442361111";
    var XJ = " +lat_0=44.69166666666666";
    var XK = " +lat_0=44.71666666666667";
    var XL = " +lat_1=44.00007392861111";
    var XM = " +lat_0=44.00007392861111";
    var XN = " +lat_0=44.39722222222222";
    var XO = " +lat_1=45.70422377027778";
    var XP = " +lat_0=45.70422377027778";
    var XQ = " +lat_1=44.63614887194444";
    var XR = " +lat_0=44.63614887194444";
    var XS = " +lat_0=44.66111111111111";
    var XT = " +lat_1=44.41682397527777";
    var XU = " +lat_0=44.41682397527777";
    var XV = " +lat_0=44.55555555555555";
    var XW = " +lat_0=41.94444444444444";
    var XX = " +lat_0=43.91944444444444";
    var XY = " +lat_0=42.81944444444445";
    var XZ = " +lat_1=45.90009913138888";
    var Xa = " +lat_0=45.90009913138888";
    var Xb = " +lat_1=45.17782208583333";
    var Xc = " +lat_0=45.17782208583333";
    var Xd = " +lat_0=43.16111111111111";
    var Xe = " +lat_1=43.57503293972223";
    var Xf = " +lat_0=43.57503293972223";
    var Xg = " +lat_1=46.07784409055556";
    var Xh = " +lat_0=46.07784409055556";
    var Xi = " +lat_1=42.66946209694444";
    var Xj = " +lat_0=42.66946209694444";
    var Xk = " +lat_1=45.96121983333334";
    var Xl = " +lat_0=45.96121983333334";
    var Xm = " +lat_0=42.91805555555555";
    var Xn = " +lat_0=42.56944444444445";
    var Xo = " +lat_0=43.42027777777778";
    var Xp = " +lat_1=44.11394404583334";
    var Xq = " +lat_0=44.11394404583334";
    var Xr = " +lat_1=44.36259546944444";
    var Xs = " +lat_0=44.36259546944444";
    var Xt = " +lat_1=44.10000000000001";
    var Xu = " +lat_0=44.10000000000001";
    var Xv = " +lat_1=42.16500000000001";
    var Xw = " +lat_0=42.16500000000001";
    var Xx = " +lat_0=52.15616055555555";
    var Xy = " +lat_2=48.73333333333333";
    var Xz = " +zone=3";
    var YA = " +lat_0=53.5";
    var YB = " +k=0.999923";
    var YC = " +x_0=850000";
    var YD = " +x_0=830000";
    var YE = " +lon_0=16.5";
    var YF = " +x_0=520000";
    var YG = " +lat_2=31.5";
    var YH = " +lon_0=10.5";
    var YI = " +lat_1=44.5";
    var YJ = " +lon_0=-153";
    var YK = " +lon_0=-135";
    var YL = " +x_0=750000";
    var YM = " +lat_0=43.5";
    var YN = " +lon_0=-142";
    var YO = " +lon_0=-146";
    var YP = " +lon_0=-162";
    var YQ = " +lon_0=-166";
    var YR = " +lon_0=-176";
    var YS = " +lat_2=39.5";
    var YT = " +lon_0=-129";
    var YU = " +k_0=1.0002";
    var YV = " +k=1.000023";
    var YW = " +lon_0=-121";
    var YX = " +k=1.000175";
    var YY = " +lat_0=45.5";
    var YZ = " +k=1.000155";
    var Ya = " +lat_2=37.5";
    var Yb = " +lat_1=48.5";
    var Yc = " +k=1.000029";
    var Yd = " +lat_0=39.6";
    var Ye = " +k=1.000013";
    var Yf = " +k=1.000022";
    var Yg = " +lat_0=40.7";
    var Yh = " +lat_0=39.3";
    var Yi = " +lat_0=37.8";
    var Yj = " +lat_0=38.9";
    var Yk = " +lon_0=-5.4";
    var Yl = " +y_0=626907.39";
    var Ym = " +b=6356571.996";
    var Yn = " +a=6377295.664";
    var Yo = " +lon_0=5.38763888888889";
    var Yp = " +y_0=-4600000.00001208";
    var Yq = " +y_0=1889763.779527559";
    var Yr = " +y_0=99999.99999960001";
    var Ys = " +x_0=120091.4401828804";
    var Yt = " +lon_0=72";
    var Yu = " +lat_0=50";
    var Yv = " +lat_1=50";
    var Yw = " +lat_1=35";
    var Yx = " +lon_0=22";
    var Yy = " +lat_1=34";
    var Yz = " +lonc=115";
    var ZA = " +lat_0=-9";
    var ZB = " +lat_0=23";
    var ZC = " +lat_1=85";
    var ZD = " +lat_2=69";
    var ZE = " +lat_1=69";
    var ZF = " +lat_2=61";
    var ZG = " +lon_0=34";
    var ZH = " +lon_0=140.25";
    var ZI = " +lon_0=142.25";
    var ZJ = " +lon_0=144.25";
    var ZK = " +x_0=47500000";
    var ZL = " +y_0=-3000000";
    var ZM = " +pm=2.337208333333333";
    var ZN = " +x_0=7000000.00000248";
    var ZO = " +lon_0=6";
    var ZP = " +k=0.997";
    var ZQ = " +lon_0=106";
    var ZR = " +lon_0=154";
    var ZS = " +lon_0=156";
    var ZT = " +lat_2=-36";
    var ZU = " +lon_0=119";
    var ZV = " +lon_0=121";
    var ZW = " +lon_0=166";
    var ZX = " +a=6371228";
    var ZY = " +b=6371228";
    var ZZ = " +a=6378273";
    var Za = " +lat_0=-44";
    var Zb = " +pm=lisbon";
    var Zc = " +lon_0=-57";
    var Zd = " +lon_0=-56";
    var Ze = " +k=1.00007";
    var Zf = " +lonc=-123";
    var Zg = " +alpha=295";
    var Zh = " +gamma=295";
    var Zi = " +k=1.00011";
    var Zj = " +k=1.00005";
    var Zk = " +k=1.00013";
    var Zl = " +x_0=30000";
    var Zm = " +k=1.00001";
    var Zn = " +k=1.00003";
    var Zo = " +y_0=130000.00001472";
    var Zp = " +x_0=119999.99999952";
    var Zq = " +y_0=-2999999.999988";
    var Zr = " +x_0=-299999.9999988";
    var Zs = " +lat_1=43.0695160375";
    var Zt = " +lat_0=43.0695160375";
    var Zu = " +lat_1=43.3223129275";
    var Zv = " +lat_0=43.3223129275";
    var Zw = " +k=1.0000067";
    var Zx = " +a=6378298.3";
    var Zy = " +lon_0=-66.5";
    var Zz = " +lon_0=129.5";
    var aA = " +lon_0=138.5";
    var aB = " +x_0=2300000";
    var aC = " +x_0=3300000";
    var aD = " +x_0=4300000";
    var aE = " +y_0=7500000";
    var aF = " +lonc=102.25";
    var aG = " +y_0=1166200";
    var aH = " +x_0=3000000";
    var aI = " +lat_1=46.25";
    var aJ = " +ellps=WGS66";
    var aK = " +ellps=GRS67";
    var aL = " +lat_1=34.65";
    var aM = " +y_0=59999.99999976";
    var aN = " +y_0=30000.00001512";
    var aO = " +x_0=59999.99999976";
    var aP = " +x_0=30000.00001512";
    var aQ = " +lat_1=43.200055605";
    var aR = " +lat_0=43.200055605";
    var aS = " +y_0=65379.0134283";
    var aT = " +alpha=323.0257905";
    var aU = " +alpha=53.31580995";
    var aV = " +x_0=10000.0000152";
    module.exports = [2e3, D + L3 + NU + EP + u + N + c + E + A2, 1, D + L3 + NU + EP + u + N + c + TI + E + A2, 1, D + L3 + NU + EP + u + N + c + TJ + E + A2, 1, D + L3 + NU + EP + u + N + c + TK + E + A2, 1, D + L3 + NU + EP + u + N + c + TL + E + A2, 1, D + L3 + NU + EP + u + N + c + UB + E + A2, 1, D + L3 + NU + EP + u + N + c + Sv + E + A2, 1, D + L3 + NU + EP + u + N + c + Ps + E + A2, 2, D + L3 + Tf + V2 + Ab + N + i + E + A2, 1, D + L3 + RQ + V2 + Ab + N + i + E + A2, 1, D + L3 + RR + V2 + Ab + N + i + E + A2, 1, D + L3 + Tg + V2 + Ab + N + i + E + A2, 1, D + L3 + IL + V2 + Ab + N + i + E + A2, 1, D + L3 + Th + V2 + Ab + N + i + E + A2, 1, D + L3 + Ti + V2 + Ab + N + i + E + A2, 1, D + L3 + Ga + V2 + Ab + N + i + E + A2, 1, D + L3 + Th + V2 + Ab + N + i + E + A2, 1, D + L3 + Ti + V2 + Ab + N + i + E + A2, 1, D + L3 + Ga + V2 + Ab + N + i + E + A2, 1, D + L3 + ET + V2 + Ab + N + i + E + A2, 1, D + L3 + CR + V2 + Ab + N + i + E + A2, 1, D + L3 + NV + V2 + Ab + N + i + E + A2, 1, D + L3 + Jh + V2 + Ab + N + i + E + A2, 1, D + L3 + Bu + V2 + Ab + N + i + E + A2, 1, D + L3 + Rs + V2 + Ab + N + i + E + A2, 1, D + L3 + OZ + V2 + Ab + N + i + E + A2, 1, I2 + NP + i + E + A2, 1, I2 + NQ + i + E + A2, 1, I2 + Ik + i + E + A2, 1, I2 + IC + i + E + A2, 1, I2 + Ik + i + E + A2, 1, I2 + IC + i + E + A2, 1, I2 + Hi + i + E + A2, 1, I2 + Gz + i + E + A2, 1, I2 + ID + i + E + A2, 4, D + Ou + Ov + Zw + UV + Yl + C + UC + E + A2, 1, I2 + Oq + c + JO + E + A2, 1, I2 + Oq + c + IE + E + A2, 1, I2 + KA + c + JO + E + A2, 1, I2 + KA + c + IE + E + A2, 1, D + L3 + EN + " +k=1" + Hs + N + M + HG + E + A2, 1, D + L3 + Fy + " +k=1" + Ht + N + M + HG + E + A2, 1, D + L3 + Gj + " +k=1" + s + N + Gk + j + B + E + A2, 1, D + L3 + UE + " +k=1" + s + N + Gk + j + B + E + A2, 1, D + L3 + RI + " +k=1" + s + N + Gk + j + B + E + A2, 1, D + L3 + Gl + " +k=1" + s + N + Gk + j + B + E + A2, 1, D + L3 + SP + " +k=1" + s + N + Gk + j + B + E + A2, 1, D + L3 + RJ + " +k=1" + s + N + Gk + j + B + E + A2, 1, D + L3 + HO + " +k=1" + s + N + Gk + j + B + E + A2, 1, D + L3 + " +lon_0=29 +k=1" + s + N + Gk + j + B + E + A2, 1, D + L3 + QQ + " +k=1" + s + N + Gk + j + B + E + A2, 1, D + L3 + IG + " +k=1" + s + N + Gk + j + B + E + A2, 1, Pu + Kj + Ow + " +k_0=1 +x_0=2600000" + Tj + Y + Py + E + A2, 1, CU + " +lat_0=27.51882880555555 +lonc=52.60353916666667 +alpha=0.5716611944444444 +k=0.999895934 +x_0=658377.437 +y_0=3044969.194 +gamma=0.5716611944444444" + R + Pz + E + A2, 1, I2 + JZ + R + Gy + E + A2, 1, I2 + JM + R + Gy + E + A2, 1, I2 + Me + R + Gy + E + A2, 1, I2 + Rb + R + Gy + E + A2, 1, H + " +lat_1=40" + Fs + HN + " +k_0=0.9988085293" + a + Qn + Zx + Qy + " +pm=madrid" + E + A2, 3, Rp + SS + " +lon_0=42.5" + Kk + V2 + s + N + Y + Gh + Ls + E + A2, 1, Ck + " +lat_0=11.25217861111111 +lon_0=-60.68600888888889 +x_0=37718.66159325 +y_0=36209.91512952" + Ee + Ef + Vo + A2, 1, I2 + Gz + R + QA + E + A2, 1, D + L3 + KB + V2 + h + N + R + v + E + A2, 1, D + L3 + " +lon_0=11" + V2 + h + N + R + v + E + A2, 1, D + L3 + " +lon_0=13" + V2 + h + N + R + v + E + A2, 1, D + L3 + Gj + V2 + h + N + R + v + E + A2, 1, D + L3 + UE + V2 + h + N + R + v + E + A2, 1, D + L3 + RI + V2 + h + N + R + v + E + A2, 1, D + L3 + Gl + V2 + h + N + R + v + E + A2, 1, D + L3 + SP + V2 + h + N + R + v + E + A2, 1, D + L3 + RJ + V2 + h + N + R + v + E + A2, 1, I2 + JN + R + v + E + A2, 1, I2 + KC + R + v + E + A2, 1, I2 + NR + R + v + E + A2, 1, I2 + Ki + R + v + E + A2, 1, D + m + MP + " +k=1" + Ci + N + R + E + A2, 1, D + m + MP + " +k=1" + Ci + N + R + SD + E + A2, 1, D + m + MP + " +k=1" + Ci + N + R + OV + E + A2, 1, I2 + Hi + o + R + OV + E + A2, 3, D + L3 + IH + AP + O2 + N + R + v + E + A2, 1, D + L3 + " +lon_0=11" + AP + O2 + N + AU + BN + Gi + E + A2, 1, I2 + JZ + j + B + E + A2, 1, I2 + JM + j + B + E + A2, 3, D + L3 + ZQ + " +k=1" + O2 + N + M + HG + E + A2, 1, D + L3 + ZQ + AP + O2 + N + T + Q + E + A2, 1, I2 + Ja + R + TM + E + A2, 1, D + Ch + Ed + " +k=1" + h + Ae + Y + E + A2, 1, D + Ch + Rt + " +k=1" + h + Ae + Y + E + A2, 1, D + Ch + Ru + " +k=1" + h + Ae + Y + E + A2, 1, Ck + " +lat_0=25.38236111111111 +lon_0=50.76138888888889" + BU + EK + Gn + E + A2, 1, D + L3 + II + AP + O2 + N + C + Qb + E + A2, 1, H + Kl + Km + KN + " +k_0=1" + s + " +y_0=-52684.972" + R + E + A2, 1, H + Kl + Km + KN + " +k_0=1" + h + " +y_0=147315.028" + R + E + A2, 1, H + Kl + Km + KN + " +k_0=1" + O2 + " +y_0=447315.028" + R + E + A2, 1, H + Kl + Km + KN + " +k_0=1 +x_0=-17044 +y_0=-23139.97" + R + E + A2, 1, D + " +lat_0=-36.87972222222222 +lon_0=174.7641666666667" + V2 + u + CO + C + B + E + A2, 1, D + " +lat_0=-37.76111111111111 +lon_0=176.4661111111111 +k=1" + u + CO + C + B + E + A2, 1, D + " +lat_0=-38.62444444444444 +lon_0=177.8855555555556 +k=1" + u + CO + C + B + E + A2, 1, D + " +lat_0=-39.65083333333333 +lon_0=176.6736111111111 +k=1" + u + CO + C + B + E + A2, 1, D + " +lat_0=-39.13555555555556 +lon_0=174.2277777777778 +k=1" + u + CO + C + B + E + A2, 1, D + " +lat_0=-39.51222222222222 +lon_0=175.64 +k=1" + u + CO + C + B + E + A2, 1, D + " +lat_0=-40.24194444444444 +lon_0=175.4880555555555 +k=1" + u + CO + C + B + E + A2, 1, D + " +lat_0=-40.92527777777777 +lon_0=175.6472222222222 +k=1" + u + CO + C + B + E + A2, 1, D + " +lat_0=-41.3011111111111 +lon_0=174.7763888888889 +k=1" + u + CO + C + B + E + A2, 1, D + " +lat_0=-40.71472222222223 +lon_0=172.6719444444444 +k=1" + u + CO + C + B + E + A2, 1, D + " +lat_0=-41.27444444444444 +lon_0=173.2991666666667 +k=1" + u + CO + C + B + E + A2, 1, D + " +lat_0=-41.28972222222222 +lon_0=172.1088888888889 +k=1" + u + CO + C + B + E + A2, 1, D + " +lat_0=-41.81055555555555 +lon_0=171.5811111111111 +k=1" + u + CO + C + B + E + A2, 1, D + " +lat_0=-42.33361111111111 +lon_0=171.5497222222222 +k=1" + u + CO + C + B + E + A2, 1, D + " +lat_0=-42.68888888888888 +lon_0=173.01 +k=1" + u + CO + C + B + E + A2, 1, D + " +lat_0=-41.54444444444444 +lon_0=173.8019444444444 +k=1" + u + CO + C + B + E + A2, 1, D + " +lat_0=-42.88611111111111 +lon_0=170.9797222222222 +k=1" + u + CO + C + B + E + A2, 1, D + " +lat_0=-43.11 +lon_0=170.2608333333333 +k=1" + u + CO + C + B + E + A2, 1, D + " +lat_0=-43.97777777777778 +lon_0=168.6061111111111 +k=1" + u + CO + C + B + E + A2, 1, D + " +lat_0=-43.59055555555556 +lon_0=172.7269444444445 +k=1" + u + CO + C + B + E + A2, 1, D + " +lat_0=-43.74861111111111 +lon_0=171.3605555555555 +k=1" + u + CO + C + B + E + A2, 1, D + " +lat_0=-44.40194444444445 +lon_0=171.0572222222222 +k=1" + u + CO + C + B + E + A2, 1, D + " +lat_0=-44.735 +lon_0=169.4675 +k=1" + u + CO + C + B + E + A2, 1, D + " +lat_0=-45.13277777777778 +lon_0=168.3986111111111 +k=1" + u + CO + C + B + E + A2, 1, D + " +lat_0=-45.56361111111111 +lon_0=167.7386111111111 +k=1" + u + CO + C + B + E + A2, 1, D + " +lat_0=-45.81611111111111 +lon_0=170.6283333333333 +k=1" + u + CO + C + B + E + A2, 1, D + " +lat_0=-45.86138888888889 +lon_0=170.2825" + Pc + u + CO + C + B + E + A2, 1, D + " +lat_0=-46.6 +lon_0=168.3427777777778 +k=1" + u + CO + C + B + E + A2, 1, I2 + MA + o + C + B + E + A2, 1, I2 + Nq + o + C + B + E + A2, 1, I2 + PL + o + C + B + E + A2, 1, D + Vp + " +lon_0=-1" + Rv + " +x_0=274319.7391633579" + N + Qj + Ho + NI + NJ + A2, 1, D + L3 + " +lon_0=-1" + AP + O2 + N + Qj + Ho + NI + E + A2, 1, H + UF + Nh + IZ + HJ + s + N + i + E + A2, 16, H + LM + " +lat_2=44" + Iq + Or + EW + " +y_0=6600000" + C + B + E + A2, 3, D + YA + " +lon_0=-8 +k=0.99982" + a + Mk + C + B + E + A2, 1, I2 + KA + C + B + E + A2, 1, D + Vq + " +lon_0=-12 +k=1 +x_0=152399.8550907544" + N + Qj + Ho + NJ + A2, 1, D + Vq + " +lon_0=-12 +k=1 +x_0=243839.7681452071 +y_0=182879.8261089053" + Qj + Ho + NJ + A2, 1, I2 + Ja + c + OW + E + A2, 1, I2 + KA + c + OW + E + A2, 1, He + IP + CS + s + N + " +a=6370997 +b=6370997" + E + A2, 1, D + L3 + " +lon_0=-5" + AP + O2 + N + c + JO + E + A2, 1, D + L3 + " +lon_0=-5" + AP + O2 + N + c + IE + E + A2, 4, D + " +lat_0=49.83333333333334" + Vr + " +k=1" + Oa + EK + R + Jx + E + A2, 3, GU + " +lat_0=53.00194444444445 +lon_0=21.50277777777778" + UG + " +x_0=4603000 +y_0=5806000" + M + b + E + A2, 1, GU + " +lat_0=53.58333333333334 +lon_0=17.00833333333333" + UG + " +x_0=3501000 +y_0=5999000" + M + b + E + A2, 1, GU + " +lat_0=51.67083333333333 +lon_0=16.67222222222222" + UG + " +x_0=3703000 +y_0=5627000" + M + b + E + A2, 1, D + L3 + " +lon_0=18.95833333333333 +k=0.999983 +x_0=237000 +y_0=-4700000" + M + b + E + A2, 1, D + L3 + Gj + YB + Eg + N + C + B + E + A2, 1, D + L3 + QR + YB + Jt + N + C + B + E + A2, 1, D + L3 + Gl + YB + IM + N + C + B + E + A2, 1, D + L3 + II + YB + MS + N + C + B + E + A2, 1, D + L3 + RI + " +k=0.9993" + O2 + " +y_0=-5300000" + C + B + E + A2, 8, I2 + Nr + R + Sw + E + A2, 1, I2 + Os + R + Sx + E + A2, 1, I2 + Os + R + TN + E + A2, 3, D + L3 + " +lon_0=173" + AP + " +x_0=1600000" + Ak + C + B + E + A2, 2, I2 + TV + o + C + B + E + A2, 1, D + L3 + " +lon_0=9.5" + CP + h + N + C + B + E + A2, 1, D + L3 + IH + CP + O2 + N + C + B + E + A2, 1, D + L3 + Gj + " +k=1" + HT + N + C + B + E + A2, 2, GU + Iq + Zy + ST + AI + CO + Pd + Gq + E + A2, 1, I2 + IC + C + B + E + A2, 1, I2 + Hi + C + B + E + A2, 1, I2 + Gz + C + B + E + A2, 1, H + " +lat_1=35.25 +lat_2=36.41666666666666 +lat_0=34.66666666666666" + MQ + Z2 + Pv + X + J + A2, 1, H + Az + DV + DM + Jo + O2 + N + C + B + E + A2, 1, D + L3 + HO + " +k=1" + MT + N + R + n + E + A2, 1, D + L3 + Ia + " +k=1" + LY + N + R + n + E + A2, 1, D + L3 + IG + " +k=1" + Jp + N + R + n + E + A2, 1, D + L3 + PN + " +k=1" + LZ + N + R + n + E + A2, 1, D + L3 + LN + " +k=1" + HU + N + R + n + E + A2, 1, D + L3 + PO + " +k=1" + Gw + N + R + n + E + A2, 1, D + L3 + JS + " +k=1" + Hu + N + R + n + E + A2, 1, D + L3 + Ia + AP + O2 + N + C + B + E + A2, 2, I2 + JN + AU + BN + RD + E + A2, 1, I2 + Io + R + NG + E + A2, 1, I2 + MB + R + NG + E + A2, 2, I2 + Hi + Pd + Gq + E + A2, 1, I2 + Gz + Pd + Gq + E + A2, 2, D + Bl + Cn + V2 + EX + N + C + B + t + A2, 1, D + Bl + Co + V2 + EX + N + C + B + t + A2, 1, D + Bl + Iv + BG + EX + N + C + B + t + A2, 1, H + DW + Jn + y + HA + Ac + AD + C + B + J + A2, 1, H + DX + DY + AA + HA + Ac + AD + C + B + J + A2, 1, H + Ap + DZ + Ml + AJ + Ac + AD + C + B + J + A2, 1, H + LO + QS + Da + Mm + Ac + AD + C + B + J + A2, 1, H + Db + Dc + Mn + Ir + Ac + AD + C + B + J + A2, 1, H + Dd + De + Df + Iw + Ac + AD + C + B + J + A2, 1, H + Eh + Ei + y + Ba + Bw + CL + C + B + J + A2, 1, H + LP + LQ + CY + Ba + Bw + CL + C + B + J + A2, 1, H + Ap + Dg + f + Ba + Bw + CL + C + B + J + A2, 1, H + Dh + Mo + Di + Jq + MC + MD + C + B + J + A2, 1, D + Ch + Cp + Mp + AE + N + C + B + J + A2, 1, D + Aq + CR + Am + AE + N + C + B + J + A2, 1, D + Aq + Ob + Am + AE + N + C + B + J + A2, 1, H + LR + Dj + QT + LS + a + N + C + B + J + A2, 1, D + Gm + Cq + V2 + AE + N + C + B + J + A2, 1, D + Gm + Cr + V2 + CM + N + C + B + J + A2, 1, D + p + Cs + BJ + AE + N + C + B + J + A2, 1, D + p + Jb + BJ + AF + N + C + B + J + A2, 1, D + p + Ix + BG + ME + N + C + B + J + A2, 3, H + Az + DV + DM + Jo + AF + N + C + B + J + A2, 1, H + Ej + Ek + AB + EY + AF + AD + C + B + J + A2, 1, H + MU + Nz + AA + Ld + MF + N + C + B + J + A2, 1, H + El + Dk + Ip + GE + AE + Mk + C + B + J + A2, 1, H + Em + En + Ip + IL + AF + N + C + B + J + A2, 1, H + Eo + Ep + Eq + Jh + MG + N + C + B + t + A2, 1, H + OA + Er + Es + BE + MH + N + C + B + t + A2, 1, H + Bq + OB + Fo + BE + OT + N + C + B + t + A2, 1, D + Hj + Ct + CP + BF + N + C + B + J + A2, 1, D + Hj + Bx + CP + CM + N + C + B + J + A2, 1, H + LM + RK + MV + IS + DR + N + C + B + t + A2, 1, D + Bl + Cu + Hm + OC + N + C + B + J + A2, 1, D + Bl + Iy + V2 + AF + N + C + B + J + A2, 1, D + Bl + Cv + Iz + MI + N + C + B + J + A2, 1, D + BA + Gp + V2 + Bn + N + C + B + J + A2, 1, D + Fs + Cw + Ad + MJ + N + C + B + J + A2, 1, D + Fs + Cx + Ad + MK + N + C + B + J + A2, 1, H + Dl + Dm + BB + Oc + BF + N + C + B + J + A2, 1, H + Et + Eu + LT + NW + Z2 + N + C + B + J + A2, 1, H + BH + Ev + Ib + EZ + DR + N + C + B + t + A2, 1, H + Ew + Ex + Be + EZ + DR + N + C + B + t + A2, 1, H + Dn + Ey + QU + Fl + a + N + C + B + J + A2, 1, H + Ez + FA + Do + Fl + a + N + C + B + J + A2, 1, H + PP + CZ + AK + AJ + KL + N + C + B + t + A2, 1, H + PQ + Ca + p + AJ + KM + N + C + B + t + A2, 1, H + MW + FB + BB + Ea + a + N + C + B + J + A2, 1, H + Dp + Dq + y + Ea + a + N + C + B + J + A2, 1, H + FC + OD + Dr + CR + OE + N + C + B + t + A2, 1, H + FD + MX + BC + MQ + a + N + C + B + J + A2, 1, H + FE + MY + QV + Jr + AE + CN + C + B + J + A2, 1, H + FF + FG + Ds + CV + a + Gr + C + B + J + A2, 1, H + FH + FI + Cb + Ag + CM + Fq + C + B + J + A2, 1, H + FJ + FK + Dt + Ji + a + Ne + C + B + J + A2, 1, H + CD + CE + Cc + CV + BF + Nf + C + B + J + A2, 1, H + AY + CF + Br + BI + Gd + Pw + C + B + t + A2, 1, H + JF + CG + AQ + BI + Gd + RY + C + B + t + A2, 1, H + JG + CH + f + BI + Gd + RZ + C + B + t + A2, 1, H + OF + FL + AA + GF + Gs + Gr + C + B + J + A2, 1, H + Az + Du + AB + GF + Gs + CN + C + B + J + A2, 1, H + BH + OG + Ib + Cy + AF + N + C + B + J + A2, 1, H + FM + FN + Dv + AJ + AF + N + C + B + J + A2, 1, H + FO + FP + Dw + Bu + a + N + C + B + J + A2, 1, H + Jc + MZ + AL + Bu + a + N + C + B + J + A2, 1, H + FQ + FR + PR + Bu + a + N + C + B + J + A2, 1, GU + " +lat_0=47.25" + Qk + ST + EW + Is + Pd + Gq + E + A2, 4, D + L3 + RQ + V2 + DP + N + Pd + Gq + E + A2, 1, D + L3 + RR + V2 + Eg + N + Pd + Gq + E + A2, 13, D + L3 + " +lon_0=109" + AP + O2 + Ak + Y + Cj + E + A2, 1, D + L3 + " +lon_0=116" + AP + O2 + Ak + S + E + A2, 1, D + L3 + Il + AP + O2 + Ak + S + E + A2, 1, D + L3 + ZO + AP + O2 + N + S + E + A2, 1, I2 + KC + c + E + A2, 1, I2 + KC + c + E + A2, 1, Ck + Vs + UX + " +x_0=86501.46392052001" + aS + Ee + Ef + JK + ML + A2, 1, I2 + Hi + o + R + Bs + E + A2, 1, I2 + Gz + o + R + Bs + E + A2, 1, H + " +lat_1=9 +lat_2=3 +lat_0=6" + Pe + BZ + AH + R + AX + E + A2, 1, H + " +lat_1=17 +lat_2=33 +lat_0=25.08951" + SQ + s + N + R + Cm + E + A2, 1, D + L3 + HO + " +k=1" + O2 + N + R + n + E + A2, 1, D + L3 + Ia + " +k=1" + O2 + N + R + n + E + A2, 1, D + L3 + IG + " +k=1" + O2 + N + R + n + E + A2, 1, D + L3 + PN + " +k=1" + O2 + N + R + n + E + A2, 1, D + L3 + LN + " +k=1" + O2 + N + R + n + E + A2, 1, D + L3 + PO + " +k=1" + O2 + N + R + n + E + A2, 1, D + L3 + JS + " +k=1" + O2 + N + R + n + E + A2, 1, D + Vt + Vu + " +k=1 +x_0=836694.05 +y_0=819069.8" + R + Jg + E + A2, 1, D + L3 + HP + " +k=1" + HU + N + As + d + E + A2, 1, D + L3 + HQ + " +k=1" + Gw + N + As + d + E + A2, 1, D + L3 + Hd + " +k=1" + Hu + N + As + d + E + A2, 1, D + L3 + HR + " +k=1" + Hv + N + As + d + E + A2, 1, D + L3 + HS + " +k=1" + It + N + As + d + E + A2, 1, D + L3 + EN + " +k=1" + Hs + N + As + d + E + A2, 1, D + L3 + Fy + " +k=1" + Ht + N + As + d + E + A2, 1, D + L3 + Fm + " +k=1" + HV + N + As + d + E + A2, 1, D + L3 + Fr + " +k=1" + Hw + N + As + d + E + A2, 1, D + L3 + Ed + " +k=1" + HW + N + As + d + E + A2, 1, D + L3 + Fn + " +k=1" + Hx + N + As + d + E + A2, 1, D + L3 + HP + " +k=1" + O2 + N + As + d + E + A2, 1, D + L3 + HQ + " +k=1" + O2 + N + As + d + E + A2, 1, D + L3 + Hd + " +k=1" + O2 + N + As + d + E + A2, 1, D + L3 + HR + " +k=1" + O2 + N + As + d + E + A2, 1, D + L3 + HS + " +k=1" + O2 + N + As + d + E + A2, 1, D + L3 + EN + " +k=1" + O2 + N + As + d + E + A2, 1, D + L3 + Fy + " +k=1" + O2 + N + As + d + E + A2, 1, D + L3 + Fm + " +k=1" + O2 + N + As + d + E + A2, 1, D + L3 + Fr + " +k=1" + O2 + N + As + d + E + A2, 1, D + L3 + Ed + " +k=1" + O2 + N + As + d + E + A2, 1, D + L3 + Fn + " +k=1" + O2 + N + As + d + E + A2, 1, D + L3 + HP + " +k=1" + Hy + N + As + d + E + A2, 1, D + L3 + Lt + " +k=1" + Hz + N + As + d + E + A2, 1, D + L3 + HQ + " +k=1" + IA + N + As + d + E + A2, 1, D + L3 + Ni + " +k=1" + IB + N + As + d + E + A2, 1, D + L3 + Hd + " +k=1" + Gx + N + As + d + E + A2, 1, D + L3 + Hq + " +k=1" + IT + N + As + d + E + A2, 1, D + L3 + HR + " +k=1" + Gc + N + As + d + E + A2, 1, D + L3 + Mj + " +k=1" + IU + N + As + d + E + A2, 1, D + L3 + HS + " +k=1" + Iu + N + As + d + E + A2, 1, D + L3 + Jj + " +k=1" + Mu + N + As + d + E + A2, 1, D + L3 + EN + " +k=1" + Mv + N + As + d + E + A2, 1, D + L3 + Le + " +k=1" + Mw + N + As + d + E + A2, 1, D + L3 + Fy + " +k=1" + Mx + N + As + d + E + A2, 1, D + L3 + Im + " +k=1" + My + N + As + d + E + A2, 1, D + L3 + Fm + " +k=1" + Mz + N + As + d + E + A2, 1, D + L3 + KF + " +k=1" + NA + N + As + d + E + A2, 1, D + L3 + Fr + " +k=1" + NB + N + As + d + E + A2, 1, D + L3 + Jk + " +k=1" + Oh + N + As + d + E + A2, 1, D + L3 + Ed + " +k=1" + NC + N + As + d + E + A2, 1, D + L3 + Il + " +k=1" + Oi + N + As + d + E + A2, 1, D + L3 + Fn + " +k=1" + ND + N + As + d + E + A2, 1, D + L3 + HP + " +k=1" + O2 + N + As + d + E + A2, 1, D + L3 + Lt + " +k=1" + O2 + N + As + d + E + A2, 1, D + L3 + HQ + " +k=1" + O2 + N + As + d + E + A2, 1, D + L3 + Ni + " +k=1" + O2 + N + As + d + E + A2, 1, D + L3 + Hd + " +k=1" + O2 + N + As + d + E + A2, 1, D + L3 + Hq + " +k=1" + O2 + N + As + d + E + A2, 1, D + L3 + HR + " +k=1" + O2 + N + As + d + E + A2, 1, D + L3 + Mj + " +k=1" + O2 + N + As + d + E + A2, 1, D + L3 + HS + " +k=1" + O2 + N + As + d + E + A2, 1, D + L3 + Jj + " +k=1" + O2 + N + As + d + E + A2, 1, D + L3 + EN + " +k=1" + O2 + N + As + d + E + A2, 1, D + L3 + Le + " +k=1" + O2 + N + As + d + E + A2, 1, D + L3 + Fy + " +k=1" + O2 + N + As + d + E + A2, 1, D + L3 + Im + " +k=1" + O2 + N + As + d + E + A2, 1, D + L3 + Fm + " +k=1" + O2 + N + As + d + E + A2, 1, D + L3 + KF + " +k=1" + O2 + N + As + d + E + A2, 1, D + L3 + Fr + " +k=1" + O2 + N + As + d + E + A2, 1, D + L3 + Jk + " +k=1" + O2 + N + As + d + E + A2, 1, D + L3 + Ed + " +k=1" + O2 + N + As + d + E + A2, 1, D + L3 + Il + " +k=1" + O2 + N + As + d + E + A2, 1, D + L3 + Fn + " +k=1" + O2 + N + As + d + E + A2, 1, D + L3 + Gl + " +k=1" + AV + N + R + At + E + A2, 1, D + L3 + II + " +k=1" + Ci + N + R + At + E + A2, 1, D + L3 + HO + " +k=1" + Bo + N + R + At + E + A2, 1, D + L3 + Ia + " +k=1" + DP + N + R + At + E + A2, 1, D + L3 + JS + " +k=1" + MS + N + M + NK + E + A2, 1, D + L3 + PS + " +k=1" + MT + N + M + NK + E + A2, 1, D + L3 + KB + " +k=1" + Bo + N + M + Ar + E + A2, 1, D + L3 + IH + " +k=1" + DP + N + M + Ar + E + A2, 1, D + L3 + Gj + " +k=1" + Eg + N + M + Ar + E + A2, 2, D + L3 + HP + " +k=1" + Hy + N + M + U + E + A2, 1, D + L3 + Lt + " +k=1" + Hz + N + M + U + E + A2, 1, D + L3 + HQ + " +k=1" + IA + N + M + U + E + A2, 1, D + L3 + Ni + " +k=1" + IB + N + M + U + E + A2, 1, D + L3 + Hd + " +k=1" + Gx + N + M + U + E + A2, 1, D + L3 + Hq + " +k=1" + IT + N + M + U + E + A2, 1, D + L3 + HR + " +k=1" + Gc + N + M + U + E + A2, 1, D + L3 + Mj + " +k=1" + IU + N + M + U + E + A2, 1, D + L3 + HS + " +k=1" + Iu + N + M + U + E + A2, 1, D + L3 + Jj + " +k=1" + Mu + N + M + U + E + A2, 1, D + L3 + EN + " +k=1" + Mv + N + M + U + E + A2, 1, D + L3 + Le + " +k=1" + Mw + N + M + U + E + A2, 1, D + L3 + Fy + " +k=1" + Mx + N + M + U + E + A2, 1, D + L3 + Im + " +k=1" + My + N + M + U + E + A2, 1, D + L3 + Fm + " +k=1" + Mz + N + M + U + E + A2, 1, D + L3 + KF + " +k=1" + NA + N + M + U + E + A2, 1, D + L3 + Fr + " +k=1" + NB + N + M + U + E + A2, 1, D + L3 + Jk + " +k=1" + Oh + N + M + U + E + A2, 1, D + L3 + Ed + " +k=1" + NC + N + M + U + E + A2, 1, D + L3 + Il + " +k=1" + Oi + N + M + U + E + A2, 1, D + L3 + Fn + " +k=1" + ND + N + M + U + E + A2, 1, D + L3 + HP + " +k=1" + O2 + N + M + U + E + A2, 1, D + L3 + Lt + " +k=1" + O2 + N + M + U + E + A2, 1, D + L3 + HQ + " +k=1" + O2 + N + M + U + E + A2, 1, D + L3 + Ni + " +k=1" + O2 + N + M + U + E + A2, 1, D + L3 + Hd + " +k=1" + O2 + N + M + U + E + A2, 1, D + L3 + Hq + " +k=1" + O2 + N + M + U + E + A2, 1, D + L3 + HR + " +k=1" + O2 + N + M + U + E + A2, 1, D + L3 + Mj + " +k=1" + O2 + N + M + U + E + A2, 1, D + L3 + HS + " +k=1" + O2 + N + M + U + E + A2, 1, D + L3 + Jj + " +k=1" + O2 + N + M + U + E + A2, 1, D + L3 + EN + " +k=1" + O2 + N + M + U + E + A2, 1, D + L3 + Le + " +k=1" + O2 + N + M + U + E + A2, 1, D + L3 + Fy + " +k=1" + O2 + N + M + U + E + A2, 1, D + L3 + Im + " +k=1" + O2 + N + M + U + E + A2, 1, D + L3 + Fm + " +k=1" + O2 + N + M + U + E + A2, 1, D + L3 + KF + " +k=1" + O2 + N + M + U + E + A2, 1, D + L3 + Fr + " +k=1" + O2 + N + M + U + E + A2, 1, D + L3 + Jk + " +k=1" + O2 + N + M + U + E + A2, 1, D + L3 + Ed + " +k=1" + O2 + N + M + U + E + A2, 1, D + L3 + Il + " +k=1" + O2 + N + M + U + E + A2, 1, D + L3 + Fn + " +k=1" + O2 + N + M + U + E + A2, 1, D + PT + Zz + V2 + s + N + C + B + E + A2, 1, D + PT + NX + V2 + s + N + C + B + E + A2, 1, D + GM + Ox + V2 + s + N + C + B + E + A2, 1, D + PT + Tk + V2 + s + N + C + B + E + A2, 1, D + GM + Oy + V2 + s + N + C + B + E + A2, 1, D + GM + Rw + V2 + s + N + C + B + E + A2, 1, D + GM + Oz + V2 + s + N + C + B + E + A2, 1, D + GM + aA + V2 + s + N + C + B + E + A2, 1, D + GM + PA + V2 + s + N + C + B + E + A2, 1, D + Fs + PB + V2 + s + N + C + B + E + A2, 1, D + IZ + ZH + V2 + s + N + C + B + E + A2, 1, D + IZ + ZI + V2 + s + N + C + B + E + A2, 1, D + IZ + ZJ + V2 + s + N + C + B + E + A2, 1, D + IQ + " +lon_0=142" + V2 + s + N + C + B + E + A2, 1, D + IQ + Pj + V2 + s + N + C + B + E + A2, 1, D + IQ + " +lon_0=124" + V2 + s + N + C + B + E + A2, 1, D + IQ + NX + V2 + s + N + C + B + E + A2, 1, D + " +lat_0=20" + Rw + V2 + s + N + C + B + E + A2, 1, D + IQ + ZR + V2 + s + N + C + B + E + A2, 1, D + L3 + Gl + " +k=1" + DP + N + M + E + A2, 1, D + L3 + Gl + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + HO + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + IG + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + LN + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + JS + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + PS + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + RL + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + QW + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + RM + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + HP + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + HQ + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + Hd + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + HR + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + HS + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + EN + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + Fy + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + Fm + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + Fr + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + Ed + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + Fn + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + Pf + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + Od + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + NY + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + Pg + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + NZ + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + Lf + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + KG + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + KH + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + Lh + " +k=1" + O2 + N + M + G + E + A2, 3, D + L3 + Gl + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + HO + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + IG + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + LN + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + JS + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + PS + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + RL + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + QW + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + RM + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + HP + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + HQ + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + Hd + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + HR + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + HS + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + EN + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + Fy + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + Fm + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + Fr + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + Ed + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + Fn + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + Pf + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + Od + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + NY + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + Pg + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + NZ + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + Lf + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + KG + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + KH + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + Lh + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + Gl + " +k=1" + IM + N + M + F + E + A2, 1, D + L3 + II + " +k=1" + MS + N + M + F + E + A2, 1, D + L3 + HO + " +k=1" + MT + N + M + F + E + A2, 1, D + L3 + Ia + " +k=1" + LY + N + M + F + E + A2, 1, D + L3 + IG + " +k=1" + Jp + N + M + F + E + A2, 1, D + L3 + PN + " +k=1" + LZ + N + M + F + E + A2, 1, D + L3 + LN + " +k=1" + HU + N + M + F + E + A2, 1, D + L3 + PO + " +k=1" + Gw + N + M + F + E + A2, 1, D + L3 + JS + " +k=1" + Hu + N + M + F + E + A2, 1, D + L3 + SQ + " +k=1" + Hv + N + M + F + E + A2, 1, D + L3 + PS + " +k=1" + It + N + M + F + E + A2, 1, D + L3 + SR + " +k=1" + Hs + N + M + F + E + A2, 1, D + L3 + RL + " +k=1" + Ht + N + M + F + E + A2, 1, D + L3 + " +lon_0=60 +k=1" + HV + N + M + F + E + A2, 1, D + L3 + QW + " +k=1" + Hw + N + M + F + E + A2, 1, D + L3 + UH + " +k=1" + HW + N + M + F + E + A2, 1, D + L3 + RM + " +k=1" + Hx + N + M + F + E + A2, 1, D + L3 + Yt + " +k=1" + La + N + M + F + E + A2, 1, D + L3 + HP + " +k=1" + Hy + N + M + F + E + A2, 1, D + L3 + Lt + " +k=1" + Hz + N + M + F + E + A2, 1, D + L3 + HQ + " +k=1" + IA + N + M + F + E + A2, 1, D + L3 + Ni + " +k=1" + IB + N + M + F + E + A2, 1, D + L3 + Hd + " +k=1" + Gx + N + M + F + E + A2, 1, D + L3 + Hq + " +k=1" + IT + N + M + F + E + A2, 1, D + L3 + HR + " +k=1" + Gc + N + M + F + E + A2, 1, D + L3 + Mj + " +k=1" + IU + N + M + F + E + A2, 1, D + L3 + HS + " +k=1" + Iu + N + M + F + E + A2, 2, D + L3 + Jj + " +k=1" + Mu + N + M + F + E + A2, 1, D + L3 + EN + " +k=1" + Mv + N + M + F + E + A2, 1, D + L3 + Le + " +k=1" + Mw + N + M + F + E + A2, 1, D + L3 + Fy + " +k=1" + Mx + N + M + F + E + A2, 1, D + L3 + Im + " +k=1" + My + N + M + F + E + A2, 1, D + L3 + Fm + " +k=1" + Mz + N + M + F + E + A2, 1, D + L3 + KF + " +k=1" + NA + N + M + F + E + A2, 1, D + L3 + Fr + " +k=1" + NB + N + M + F + E + A2, 1, D + L3 + Jk + " +k=1" + Oh + N + M + F + E + A2, 1, D + L3 + Ed + " +k=1" + NC + N + M + F + E + A2, 1, D + L3 + Il + " +k=1" + Oi + N + M + F + E + A2, 1, D + L3 + Fn + " +k=1" + ND + N + M + F + E + A2, 1, D + L3 + Rx + " +k=1 +x_0=46500000" + N + M + F + E + A2, 1, D + L3 + Pf + " +k=1" + ZK + N + M + F + E + A2, 1, D + L3 + UN + " +k=1 +x_0=48500000" + N + M + F + E + A2, 1, D + L3 + Od + " +k=1 +x_0=49500000" + N + M + F + E + A2, 1, D + L3 + Oe + " +k=1 +x_0=50500000" + N + M + F + E + A2, 1, D + L3 + NY + " +k=1 +x_0=51500000" + N + M + F + E + A2, 1, D + L3 + ZS + " +k=1 +x_0=52500000" + N + M + F + E + A2, 1, D + L3 + Pg + " +k=1 +x_0=53500000" + N + M + F + E + A2, 1, D + L3 + Ql + " +k=1 +x_0=54500000" + N + M + F + E + A2, 1, D + L3 + NZ + " +k=1 +x_0=55500000" + N + M + F + E + A2, 1, D + L3 + UO + " +k=1 +x_0=56500000" + N + M + F + E + A2, 1, D + L3 + Lf + " +k=1 +x_0=57500000" + N + M + F + E + A2, 1, D + L3 + UP + " +k=1 +x_0=58500000" + N + M + F + E + A2, 1, D + L3 + KG + " +k=1 +x_0=59500000" + N + M + F + E + A2, 2, D + L3 + KH + " +k=1 +x_0=61500000" + N + M + F + E + A2, 1, D + L3 + SU + " +k=1 +x_0=62500000" + N + M + F + E + A2, 1, D + L3 + Lh + " +k=1 +x_0=63500000" + N + M + F + E + A2, 1, D + L3 + SV + " +k=1 +x_0=64500000" + N + M + F + E + A2, 1, D + L3 + Gl + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + II + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + HO + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + Ia + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + IG + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + PN + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + LN + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + PO + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + JS + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + SQ + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + PS + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + SR + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + RL + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + " +lon_0=60 +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + QW + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + UH + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + RM + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + Yt + " +k=1" + O2 + N + M + F + E + A2, 2, D + L3 + HP + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + Lt + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + HQ + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + Ni + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + Hd + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + Hq + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + HR + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + Mj + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + HS + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + Jj + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + EN + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + Le + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + Fy + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + Im + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + Fm + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + KF + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + Fr + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + Jk + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + Ed + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + Il + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + Fn + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + Rx + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + Pf + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + UN + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + Od + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + Oe + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + NY + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + ZS + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + Pg + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + Ql + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + NZ + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + UO + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + Lf + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + UP + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + KG + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + Ry + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + KH + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + SU + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + Lh + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + SV + " +k=1" + O2 + N + M + F + E + A2, 1, D + L3 + Gl + " +k=1" + IM + N + M + G + E + A2, 1, D + L3 + II + " +k=1" + MS + N + M + G + E + A2, 1, D + L3 + HO + " +k=1" + MT + N + M + G + E + A2, 1, D + L3 + Ia + " +k=1" + LY + N + M + G + E + A2, 1, D + L3 + IG + " +k=1" + Jp + N + M + G + E + A2, 1, D + L3 + PN + " +k=1" + LZ + N + M + G + E + A2, 1, D + L3 + LN + " +k=1" + HU + N + M + G + E + A2, 1, D + L3 + PO + " +k=1" + Gw + N + M + G + E + A2, 1, D + L3 + JS + " +k=1" + Hu + N + M + G + E + A2, 1, D + L3 + SQ + " +k=1" + Hv + N + M + G + E + A2, 1, D + L3 + PS + " +k=1" + It + N + M + G + E + A2, 1, D + L3 + SR + " +k=1" + Hs + N + M + G + E + A2, 1, D + L3 + RL + " +k=1" + Ht + N + M + G + E + A2, 1, D + L3 + " +lon_0=60 +k=1" + HV + N + M + G + E + A2, 1, D + L3 + QW + " +k=1" + Hw + N + M + G + E + A2, 1, D + L3 + UH + " +k=1" + HW + N + M + G + E + A2, 1, D + L3 + RM + " +k=1" + Hx + N + M + G + E + A2, 1, D + L3 + Yt + " +k=1" + La + N + M + G + E + A2, 1, D + L3 + HP + " +k=1" + Hy + N + M + G + E + A2, 1, D + L3 + Lt + " +k=1" + Hz + N + M + G + E + A2, 1, D + L3 + HQ + " +k=1" + IA + N + M + G + E + A2, 1, D + L3 + Ni + " +k=1" + IB + N + M + G + E + A2, 1, D + L3 + Hd + " +k=1" + Gx + N + M + G + E + A2, 1, D + L3 + Hq + " +k=1" + IT + N + M + G + E + A2, 1, D + L3 + HR + " +k=1" + Gc + N + M + G + E + A2, 1, D + L3 + Mj + " +k=1" + IU + N + M + G + E + A2, 1, D + L3 + HS + " +k=1" + Iu + N + M + G + E + A2, 1, D + L3 + Jj + " +k=1" + Mu + N + M + G + E + A2, 1, D + L3 + EN + " +k=1" + Mv + N + M + G + E + A2, 1, D + L3 + Le + " +k=1" + Mw + N + M + G + E + A2, 1, D + L3 + Fy + " +k=1" + Mx + N + M + G + E + A2, 1, D + L3 + Im + " +k=1" + My + N + M + G + E + A2, 1, D + L3 + Fm + " +k=1" + Mz + N + M + G + E + A2, 1, D + L3 + KF + " +k=1" + NA + N + M + G + E + A2, 1, D + L3 + Fr + " +k=1" + NB + N + M + G + E + A2, 1, D + L3 + Jk + " +k=1" + Oh + N + M + G + E + A2, 1, D + L3 + Ed + " +k=1" + NC + N + M + G + E + A2, 1, D + L3 + Il + " +k=1" + Oi + N + M + G + E + A2, 1, D + L3 + Fn + " +k=1" + ND + N + M + G + E + A2, 1, D + L3 + Rx + " +k=1 +x_0=46500000" + N + M + G + E + A2, 1, D + L3 + Pf + " +k=1" + ZK + N + M + G + E + A2, 1, D + L3 + UN + " +k=1 +x_0=48500000" + N + M + G + E + A2, 1, D + L3 + Od + " +k=1 +x_0=49500000" + N + M + G + E + A2, 1, D + L3 + Oe + " +k=1 +x_0=50500000" + N + M + G + E + A2, 1, D + L3 + NY + " +k=1 +x_0=51500000" + N + M + G + E + A2, 1, D + L3 + ZS + " +k=1 +x_0=52500000" + N + M + G + E + A2, 1, D + L3 + Pg + " +k=1 +x_0=53500000" + N + M + G + E + A2, 1, D + L3 + Ql + " +k=1 +x_0=54500000" + N + M + G + E + A2, 1, D + L3 + NZ + " +k=1 +x_0=55500000" + N + M + G + E + A2, 1, D + L3 + UO + " +k=1 +x_0=56500000" + N + M + G + E + A2, 1, D + L3 + Lf + " +k=1 +x_0=57500000" + N + M + G + E + A2, 1, D + L3 + UP + " +k=1 +x_0=58500000" + N + M + G + E + A2, 1, D + L3 + KG + " +k=1 +x_0=59500000" + N + M + G + E + A2, 2, D + L3 + KH + " +k=1 +x_0=61500000" + N + M + G + E + A2, 1, D + L3 + SU + " +k=1 +x_0=62500000" + N + M + G + E + A2, 1, D + L3 + Lh + " +k=1 +x_0=63500000" + N + M + G + E + A2, 1, D + L3 + SV + " +k=1 +x_0=64500000" + N + M + G + E + A2, 1, D + L3 + Gl + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + II + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + HO + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + Ia + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + IG + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + PN + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + LN + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + PO + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + JS + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + SQ + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + PS + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + SR + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + RL + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + " +lon_0=60 +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + QW + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + UH + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + RM + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + Yt + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + HP + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + Lt + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + HQ + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + Ni + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + Hd + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + Hq + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + HR + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + Mj + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + HS + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + Jj + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + EN + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + Le + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + Fy + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + Im + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + Fm + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + KF + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + Fr + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + Jk + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + Ed + " +k=1" + O2 + N + M + G + E + A2, 1, I2 + Mf + o + i + HF + E + A2, 1, I2 + KD + o + i + HF + E + A2, 1, D + L3 + Il + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + Fn + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + Rx + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + Pf + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + UN + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + Od + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + Oe + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + NY + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + ZS + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + Pg + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + Ql + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + NZ + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + UO + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + Lf + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + UP + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + KG + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + Ry + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + KH + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + SU + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + Lh + " +k=1" + O2 + N + M + G + E + A2, 1, D + L3 + SV + " +k=1" + O2 + N + M + G + E + A2, 1, D + IY + IV + Pc + h + N + C + B + E + A2, 1, D + Gm + OS + BG + a + N + C + B + E + A2, 1, D + Bl + Cn + V2 + EX + N + C + B + E + A2, 1, D + Bl + Co + V2 + EX + N + C + B + E + A2, 1, D + Bl + Iv + BG + EX + N + C + B + E + A2, 1, H + Dx + Dy + BC + IF + u + N + C + B + E + A2, 1, H + Dz + Mq + EA + IF + u + Is + C + B + E + A2, 1, H + DW + Jn + y + HA + Bd + Ae + C + B + E + A2, 1, H + DX + DY + AA + HA + Bd + Ae + C + B + E + A2, 1, H + Ap + DZ + Ml + AJ + Bd + Ae + C + B + E + A2, 1, H + LO + QS + Da + Mm + Bd + Ae + C + B + E + A2, 1, H + Db + Dc + Mn + Ir + Bd + Ae + C + B + E + A2, 1, H + Dd + De + Df + Iw + Bd + Ae + C + B + E + A2, 1, H + Eh + Ei + y + Ba + Fw + Fx + C + B + E + A2, 1, H + LP + LQ + CY + Ba + Fw + Fx + C + B + E + A2, 1, H + Ap + Dg + f + Ba + Fw + Fx + C + B + E + A2, 1, H + Dh + Mo + Di + Jq + QG + QH + C + B + E + A2, 1, D + Ch + Cp + Mp + h + N + C + B + E + A2, 1, D + Aq + CR + Am + h + N + C + B + E + A2, 1, D + Aq + Ob + Am + h + N + C + B + E + A2, 1, H + LR + Dj + QT + LS + a + N + C + B + E + A2, 1, D + Gm + Cq + V2 + h + N + C + B + E + A2, 1, D + Gm + Cr + V2 + EW + N + C + B + E + A2, 1, D + Kn + Sf + AO + O2 + N + C + B + E + A2, 1, D + Ko + KO + AO + O2 + N + C + B + E + A2, 1, D + GV + KI + Jl + O2 + N + C + B + E + A2, 1, D + Kp + Sg + Jl + O2 + N + C + B + E + A2, 1, D + Kq + KP + " +k=1" + O2 + N + C + B + E + A2, 1, D + p + Cs + BJ + h + N + C + B + E + A2, 1, D + p + Jb + BJ + O2 + N + C + B + E + A2, 1, D + p + Ix + BG + CX + N + C + B + E + A2, 1, D + f + Cz + EQ + AI + N + C + B + E + A2, 1, D + f + DA + Am + EW + N + C + B + E + A2, 1, D + DM + DB + AO + BU + KJ + C + B + E + A2, 1, D + DM + DC + AO + HT + KJ + C + B + E + A2, 1, H + EB + EC + Fo + GG + AV + AH + C + B + E + A2, 1, H + AY + ED + Fs + GG + O2 + N + C + B + E + A2, 1, H + EE + EF + AQ + Fl + u + N + C + B + E + A2, 1, H + EG + EH + f + CV + u + Is + C + B + E + A2, 1, H + Az + DV + DM + Jo + O2 + N + C + B + E + A2, 1, H + Ej + Ek + AB + EY + O2 + Ae + C + B + E + A2, 1, H + FS + FT + IY + Hg + BZ + N + C + B + E + A2, 1, H + OH + OI + OJ + Bi + BZ + N + C + B + E + A2, 1, D + AK + HJ + V2 + AI + N + C + B + E + A2, 1, D + BD + DD + AO + HT + N + C + B + E + A2, 1, H + MU + Nz + AA + Ld + u + N + C + B + E + A2, 1, H + El + Dk + Ip + GE + h + Mk + C + B + E + A2, 1, H + Em + En + Ip + IL + O2 + N + C + B + E + A2, 1, H + Eo + Ep + Eq + Jh + Tl + N + C + B + E + A2, 1, H + OA + Er + Es + BE + Pk + N + C + B + E + A2, 1, H + Bq + OB + Fo + BE + LU + N + C + B + E + A2, 1, H + FU + FV + Iq + DE + CX + EK + C + B + E + A2, 1, H + Ma + FW + IP + Js + CX + EK + C + B + E + A2, 1, H + FX + FY + Nj + Na + CX + EK + C + B + E + A2, 1, D + Hj + Ct + CP + AI + N + C + B + E + A2, 1, D + Hj + Bx + CP + EW + N + C + B + E + A2, 1, D + Cd + RS + BG + Bv + N + C + B + E + A2, 1, D + Cd + Hg + BG + O2 + N + C + B + E + A2, 1, D + Id + RT + Am + YC + N + C + B + E + A2, 1, H + LM + RK + MV + IS + a + N + C + B + E + A2, 1, H + JT + Jn + FZ + CS + O2 + N + C + B + E + A2, 1, D + CQ + DF + V2 + h + Tm + C + B + E + A2, 1, D + CQ + DG + V2 + O2 + Hh + C + B + E + A2, 1, D + CQ + DH + V2 + CX + LV + C + B + E + A2, 1, D + Fp + DI + AO + AI + N + C + B + E + A2, 1, D + BA + Gp + V2 + Bn + N + C + B + E + A2, 1, D + Bl + Cu + Hm + OC + N + C + B + E + A2, 1, D + Bl + Iy + V2 + O2 + N + C + B + E + A2, 1, D + Bl + Cv + Iz + YD + N + C + B + E + A2, 1, D + BA + Gp + V2 + Bn + N + C + B + E + A2, 1, D + Fs + Cw + Ad + Bv + N + C + B + E + A2, 1, D + Fs + Cx + Ad + Qo + N + C + B + E + A2, 1, H + Dl + Dm + BB + Oc + AI + N + C + B + E + A2, 1, H + BH + Ev + Ib + EZ + a + N + C + B + E + A2, 1, H + Ew + Ex + Be + EZ + a + N + C + B + E + A2, 1, H + OK + Fa + BY + ET + a + N + C + B + E + A2, 1, H + Fb + Fc + Ch + ET + a + N + C + B + E + A2, 1, H + Dn + Ey + QU + Fl + a + N + C + B + E + A2, 1, H + Ez + FA + Do + Fl + a + N + C + B + E + A2, 1, H + PP + CZ + AK + AJ + Ci + N + C + B + E + A2, 1, H + PQ + Ca + p + AJ + AV + N + C + B + E + A2, 1, D + EI + GE + Lb + BU + N + C + B + E + A2, 1, H + Fd + Fe + AL + CS + a + N + C + B + E + A2, 1, H + OL + Ff + EJ + Ag + a + N + C + B + E + A2, 1, H + FD + MX + BC + MQ + a + N + C + B + E + A2, 1, H + FE + MY + QV + Jr + h + AH + C + B + E + A2, 1, H + FF + FG + Ds + CV + a + Cl + C + B + E + A2, 1, H + FH + FI + Cb + Ag + EW + Fq + C + B + E + A2, 1, H + FJ + FK + Dt + Ji + a + LV + C + B + E + A2, 1, H + CD + CE + Cc + CV + AI + Ju + C + B + E + A2, 1, H + AY + CF + Br + BI + O2 + AH + C + B + E + A2, 1, H + JF + CG + AQ + BI + O2 + Cl + C + B + E + A2, 1, H + JG + CH + f + BI + O2 + Fq + C + B + E + A2, 1, D + Fp + LW + JA + O2 + N + C + B + E + A2, 1, H + OF + FL + AA + GF + Bo + Cl + C + B + E + A2, 1, H + Az + Du + AB + GF + Bo + AH + C + B + E + A2, 1, H + BH + OG + Ib + Cy + O2 + N + C + B + E + A2, 1, H + FM + FN + Dv + AJ + O2 + N + C + B + E + A2, 1, H + Mb + RN + Mr + Ga + a + N + C + B + E + A2, 1, H + Fg + Fh + QX + CR + a + N + C + B + E + A2, 1, H + FO + FP + Dw + Bu + a + N + C + B + E + A2, 1, H + Jc + MZ + AL + Bu + a + N + C + B + E + A2, 1, H + FQ + FR + PR + Bu + a + N + C + B + E + A2, 1, D + CA + DJ + Ad + h + N + C + B + E + A2, 1, D + CA + DK + Ad + u + EK + C + B + E + A2, 1, D + CA + JB + Ad + a + N + C + B + E + A2, 1, D + CA + DL + Ad + CX + EK + C + B + E + A2, 1, H + GW + GX + GY + GA + h + IK + C + B + E + A2, 1, D + Bl + Cn + V2 + EX + N + C + B + t + A2, 1, D + Bl + Co + V2 + EX + N + C + B + t + A2, 1, D + Bl + Iv + BG + EX + N + C + B + t + A2, 1, H + DW + Jn + y + HA + Ac + AD + C + B + J + A2, 1, H + DX + DY + AA + HA + Ac + AD + C + B + J + A2, 1, H + Ap + DZ + Ml + AJ + Ac + AD + C + B + J + A2, 1, H + LO + QS + Da + Mm + Ac + AD + C + B + J + A2, 1, H + Db + Dc + Mn + Ir + Ac + AD + C + B + J + A2, 1, H + Dd + De + Df + Iw + Ac + AD + C + B + J + A2, 1, H + Eh + Ei + y + Ba + Bw + CL + C + B + J + A2, 1, H + LP + LQ + CY + Ba + Bw + CL + C + B + J + A2, 1, H + Ap + Dg + f + Ba + Bw + CL + C + B + J + A2, 1, H + Dh + Mo + Di + Jq + MC + MD + C + B + J + A2, 1, D + Ch + Cp + Mp + AE + N + C + B + J + A2, 1, D + Aq + CR + Am + AE + N + C + B + J + A2, 1, D + Aq + Ob + Am + AE + N + C + B + J + A2, 1, H + LR + Dj + QT + LS + a + N + C + B + J + A2, 1, D + Gm + Cq + V2 + AE + N + C + B + J + A2, 1, D + Gm + Cr + V2 + CM + N + C + B + J + A2, 1, D + p + Cs + BJ + AE + N + C + B + J + A2, 1, D + p + Jb + BJ + AF + N + C + B + J + A2, 1, D + p + Ix + BG + ME + N + C + B + J + A2, 3, H + Az + DV + DM + Jo + AF + N + C + B + J + A2, 1, H + Ej + Ek + AB + EY + AF + AD + C + B + J + A2, 1, H + MU + Nz + AA + Ld + MF + N + C + B + J + A2, 1, H + El + Dk + Ip + GE + AE + Mk + C + B + J + A2, 1, H + Em + En + Ip + IL + AF + N + C + B + J + A2, 1, H + Eo + Ep + Eq + Jh + MG + N + C + B + t + A2, 1, H + OA + Er + Es + BE + MH + N + C + B + t + A2, 1, H + Bq + OB + Fo + BE + OT + N + C + B + t + A2, 1, D + Hj + Ct + CP + BF + N + C + B + J + A2, 1, D + Hj + Bx + CP + CM + N + C + B + J + A2, 1, H + LM + RK + MV + IS + DR + N + C + B + t + A2, 1, D + Bl + Cu + Hm + OC + N + C + B + J + A2, 1, D + Bl + Iy + V2 + AF + N + C + B + J + A2, 1, D + Bl + Cv + Iz + MI + N + C + B + J + A2, 1, D + BA + Gp + V2 + Bn + N + C + B + J + A2, 1, D + Fs + Cw + Ad + MJ + N + C + B + J + A2, 1, D + Fs + Cx + Ad + MK + N + C + B + J + A2, 1, H + Dl + Dm + BB + Oc + BF + N + C + B + J + A2, 1, H + BH + Ev + Ib + EZ + DR + N + C + B + t + A2, 1, H + Ew + Ex + Be + EZ + DR + N + C + B + t + A2, 1, H + Dn + Ey + QU + Fl + a + N + C + B + J + A2, 1, H + Ez + FA + Do + Fl + a + N + C + B + J + A2, 1, H + PP + CZ + AK + AJ + KL + N + C + B + t + A2, 1, H + PQ + Ca + p + AJ + KM + N + C + B + t + A2, 1, H + FD + MX + BC + MQ + a + N + C + B + J + A2, 1, H + FE + MY + QV + Jr + AE + CN + C + B + J + A2, 1, H + FF + FG + Ds + CV + a + Gr + C + B + J + A2, 1, H + FH + FI + Cb + Ag + CM + Fq + C + B + J + A2, 1, H + FJ + FK + Dt + Ji + a + Ne + C + B + J + A2, 1, H + CD + CE + Cc + CV + BF + Nf + C + B + J + A2, 1, H + AY + CF + Br + BI + Gd + Pw + C + B + t + A2, 1, H + JF + CG + AQ + BI + Gd + RY + C + B + t + A2, 1, H + JG + CH + f + BI + Gd + RZ + C + B + t + A2, 1, H + OF + FL + AA + GF + Gs + Gr + C + B + J + A2, 1, H + Az + Du + AB + GF + Gs + CN + C + B + J + A2, 1, H + BH + OG + Ib + Cy + AF + N + C + B + J + A2, 1, H + FM + FN + Dv + AJ + AF + N + C + B + J + A2, 1, H + FO + FP + Dw + Bu + a + N + C + B + J + A2, 1, H + Jc + MZ + AL + Bu + a + N + C + B + J + A2, 1, H + FQ + FR + PR + Bu + a + N + C + B + J + A2, 1, D + L3 + " +lon_0=13" + AP + O2 + N + AU + BN + Sy + E + A2, 1, D + " +lat_0=24.45" + Vv + Jl + h + Hk + R + Jy + E + A2, 1, I2 + NS + o + Y + Hf + E + A2, 2, D + KQ + " +lon_0=41.53333333333333 +k=1 +x_0=1300000" + N + M + F + E + A2, 1, D + KQ + " +lon_0=44.53333333333333 +k=1" + aB + N + M + F + E + A2, 1, D + KQ + " +lon_0=47.53333333333333 +k=1" + aC + N + M + F + E + A2, 1, D + KQ + " +lon_0=50.53333333333333 +k=1" + aD + N + M + F + E + A2, 1, D + Ol + " +lon_0=50.76666666666667 +k=1" + aB + N + M + F + E + A2, 1, D + Ol + " +lon_0=53.76666666666667 +k=1" + aC + N + M + F + E + A2, 1, D + Ol + " +lon_0=56.76666666666667 +k=1" + aD + N + M + F + E + A2, 1, I2 + Ja + R + SE + E + A2, 1, I2 + Ja + R + Sz + E + A2, 2, D + L3 + Tf + V2 + Ab + N + C + B + E + A2, 1, D + L3 + RQ + V2 + Ab + N + C + B + E + A2, 1, D + L3 + RR + V2 + Ab + N + C + B + E + A2, 1, D + L3 + Tg + V2 + Ab + N + C + B + E + A2, 1, D + L3 + IL + V2 + Ab + N + C + B + E + A2, 1, D + L3 + Th + V2 + Ab + N + C + B + E + A2, 1, D + L3 + Ti + V2 + Ab + N + C + B + E + A2, 1, D + L3 + Ga + V2 + Ab + N + C + B + E + A2, 1, GU + Iq + Zy + ST + Ci + aE + C + B + E + A2, 1, GU + " +lat_0=47.25" + Qk + ST + u + CO + C + B + E + A2, 1, I2 + Ns + C + B + E + A2, 1, I2 + Nt + C + B + E + A2, 1, I2 + Nu + C + B + E + A2, 1, I2 + Ik + C + B + E + A2, 1, I2 + IC + C + B + E + A2, 1, I2 + Hi + C + B + E + A2, 1, I2 + Gz + C + B + E + A2, 1, I2 + ID + C + B + E + A2, 2, DT + " +lat_1=55" + QY + Yu + Ms + s + N + X + J + A2, 1, D + DM + DB + AO + MM + GI + C + B + J + A2, 1, D + DM + DC + AO + HT + GI + C + B + J + A2, 1, D + DM + DB + AO + MM + GI + C + B + J + A2, 1, D + DM + DC + AO + HT + GI + C + B + J + A2, 1, I2 + Gz + R + TA + E + A2, 1, I2 + Gz + R + SF + E + A2, 1, I2 + Io + R + NH + E + A2, 1, I2 + Io + C + B + E + A2, 1, I2 + Gz + R + TO + E + A2, 2, I2 + Me + o + C + B + E + A2, 1, I2 + Ro + o + R + TP + E + A2, 1, I2 + RG + o + R + Lr + E + A2, 1, I2 + RH + o + R + UD + E + A2, 2, I2 + JZ + o + R + SG + E + A2, 1, I2 + MA + o + R + QM + E + A2, 6, I2 + ID + i + TZ + E + A2, 1, I2 + SK + o + R + SH + E + A2, 3, H + JT + Hl + GH + AJ + u + N + C + B + E + A2, 1, H + JT + Hl + GH + AJ + Lc + N + C + B + t + A2, 1, H + JT + Hl + GH + AJ + u + N + C + B + E + A2, 1, H + JT + Hl + GH + AJ + Lc + N + C + B + t + A2, 1, I2 + MA + o + R + Jf + E + A2, 1, I2 + MA + o + R + TB + E + A2, 1, I2 + MA + o + R + Ke + E + A2, 1, I2 + MA + o + R + HH + E + A2, 1, I2 + JZ + o + R + SI + E + A2, 1, JU + " +lon_0=110" + ZP + Pl + Qp + Y + Hf + E + A2, 1, JU + " +lon_0=110" + ZP + Pl + Qp + Y + Cj + E + A2, 1, JU + " +lon_0=110" + ZP + Pl + Qp + Y + HZ + E + A2, 1, D + L3 + KB + AP + AV + N + R + CK + E + A2, 1, D + L3 + Gj + AP + " +x_0=2520000" + N + R + CK + E + A2, 1, DT + Yv + " +lat_2=58.5" + IP + " +lon_0=-126" + BZ + N + C + B + E + A2, 1, I2 + KC + C + B + E + A2, 1, D + L3 + IH + " +k=1" + Bn + N + C + B + E + A2, 1, D + L3 + " +lon_0=13.5 +k=1" + Bn + N + C + B + E + A2, 1, D + L3 + Gj + " +k=1" + Bn + N + C + B + E + A2, 1, D + L3 + YE + " +k=1" + Bn + N + C + B + E + A2, 1, D + L3 + QR + " +k=1" + Bn + N + C + B + E + A2, 1, D + L3 + " +lon_0=14.25 +k=1" + Bn + N + C + B + E + A2, 1, D + L3 + " +lon_0=15.75 +k=1" + Bn + N + C + B + E + A2, 1, D + L3 + " +lon_0=17.25 +k=1" + Bn + N + C + B + E + A2, 1, D + L3 + " +lon_0=18.75 +k=1" + Bn + N + C + B + E + A2, 1, D + L3 + " +lon_0=20.25 +k=1" + Bn + N + C + B + E + A2, 1, D + L3 + " +lon_0=21.75 +k=1" + Bn + N + C + B + E + A2, 1, D + L3 + " +lon_0=23.25 +k=1" + Bn + N + C + B + E + A2, 1, D + L3 + Vw + " +k=1" + AV + N + Y + BW + E + A2, 1, D + L3 + Vx + " +k=1" + AV + N + Y + BW + E + A2, 1, D + L3 + Vy + " +k=1" + AV + N + Y + BW + E + A2, 1, D + L3 + Vz + " +k=1" + AV + N + Y + BW + E + A2, 1, D + L3 + WA + " +k=1" + AV + N + Y + BW + E + A2, 1, D + L3 + WB + " +k=1" + AV + N + Y + BW + E + A2, 1, D + L3 + Vw + " +k=1" + AV + N + Y + E + A2, 1, D + L3 + Vx + " +k=1" + AV + N + Y + E + A2, 1, D + L3 + Vy + " +k=1" + AV + N + Y + E + A2, 1, D + L3 + Vz + " +k=1" + AV + N + Y + E + A2, 1, D + L3 + WA + " +k=1" + AV + N + Y + E + A2, 1, D + L3 + WB + " +k=1" + AV + N + Y + E + A2, 1, BP + m + " +lat_ts=-71" + HN + " +k=1" + s + N + S + E + A2, 1, BP + m + " +lat_ts=-71 +lon_0=70 +k=1" + Pk + Hh + S + E + A2, 1, H + " +lat_1=-68.5 +lat_2=-74.5 +lat_0=-50 +lon_0=70" + Pk + Hh + S + E + A2, 1, H + Yw + QY + PU + Lu + LU + RU + C + B + E + A2, 1, He + PU + Lu + RV + RW + C + B + E + A2, 1, I2 + Mf + o + j + KR + E + A2, 1, I2 + KD + o + j + KR + E + A2, 3, I2 + Ja + C + B + E + A2, 1, I2 + KA + C + B + E + A2, 1, I2 + Oq + C + B + E + A2, 1, I2 + QD + C + B + E + A2, 1, I2 + JN + C + B + E + A2, 1, I2 + KC + C + B + E + A2, 1, I2 + NR + C + B + E + A2, 1, I2 + Ki + C + B + E + A2, 1, I2 + Mf + C + B + E + A2, 1, I2 + KD + C + B + E + A2, 5, I2 + Os + R + Jd + E + A2, 1, I2 + SL + R + Jd + E + A2, 1, I2 + Ja + R + Jd + E + A2, 1, H + " +lat_1=64.25 +lat_2=65.75 +lat_0=65 +lon_0=-19" + O2 + Ae + C + B + E + A2, 1, D + L3 + " +lon_0=-8.5 +k=1" + Jm + " +y_0=-7800000" + R + Jz + E + A2, 1, D + L3 + II + AP + O2 + " +y_0=-6000000" + C + B + E + A2, 1, I2 + MA + o + R + Qc + E + A2, 1, I2 + Ja + R + PI + E + A2, 1, I2 + Os + R + Pt + E + A2, 1, I2 + Os + R + Pa + E + A2, 1, I2 + JN + j + B + E + A2, 1, I2 + KC + j + B + E + A2, 1, D + L3 + " +lon_0=37" + UG + O2 + ZL + R + n + E + A2, 1, I2 + Ki + C + B + E + A2, 1, Ck + " +lat_0=52.41864827777778 +lon_0=13.62720366666667" + Of + " +y_0=10000" + Y + AC + E + A2, 1, D + L3 + Bu + AP + O2 + " +y_0=-4500000" + X + E + A2, 1, D + L3 + Bu + AP + YF + Sh + C + B + E + A2, 1, D + L3 + Bu + AP + YF + Sh + C + B + E + A2, 1, D + AL + Rf + JE + EW + N + C + B + E + A2, 2, D + BD + Rg + JE + AI + N + C + B + E + A2, 1, D + AL + Rf + JE + EW + N + C + B + E + A2, 2, D + BD + Rg + JE + AI + N + C + B + E + A2, 1, CU + Kr + " +lonc=-86" + QI + AP + QJ + PY + KE + QK + C + B + E + A2, 1, CU + Kr + " +lonc=-86" + QI + AP + QJ + PY + KE + QK + C + B + E + A2, 1, H + WC + WD + WE + CS + " +x_0=914400 +y_0=914400" + X + t + A2, 1, H + WC + WD + WE + CS + BZ + AH + C + B + E + A2, 1, H + OM + RO + OX + CS + AV + Ju + C + B + E + A2, 1, DT + OM + RO + OX + CS + AV + Hh + C + B + E + A2, 1, H + OM + RO + OX + CS + AV + Ju + C + B + E + A2, 1, DT + OM + RO + OX + CS + AV + Hh + C + B + E + A2, 1, DT + " +lat_1=24" + YG + " +lat_0=24" + NV + u + N + C + B + E + A2, 1, DT + " +lat_1=24" + YG + " +lat_0=24" + NV + u + N + C + B + E + A2, 1, H + Fi + Fj + AB + EY + AV + AH + C + B + E + A2, 1, H + Fi + Fj + AB + EY + AV + CN + C + B + J + A2, 1, H + Fi + Fj + AB + EY + AV + AH + C + B + E + A2, 1, H + Fi + Fj + AB + EY + AV + CN + C + B + J + A2, 1, I2 + Mg + Y + g + E + A2, 1, I2 + NT + Y + g + E + A2, 1, I2 + Ot + Y + g + E + A2, 1, I2 + Nv + Y + g + E + A2, 1, I2 + PM + Y + g + E + A2, 1, I2 + Mg + C + B + E + A2, 1, I2 + NT + C + B + E + A2, 1, I2 + Ot + C + B + E + A2, 1, I2 + Nv + C + B + E + A2, 1, I2 + PM + C + B + E + A2, 1, H + " +lat_1=-14.26666666666667 +lat_0=-14.26666666666667" + SW + " +k_0=1" + e + " +y_0=95169.31165862332" + i + TC + J + A2, 4, D + L3 + Hq + AP + O2 + N + By + Ay + RF + E + A2, 1, H + " +lat_1=-28" + ZT + " +lat_0=-32" + Fn + BZ + Cl + C + B + E + A2, 1, D + SS + " +lon_0=-2.416666666666667 +k=0.999997 +x_0=47000" + Rz + C + B + E + A2, 1, D + " +lat_0=49.225 +lon_0=-2.135 +k=0.9999999000000001" + Of + " +y_0=70000" + C + B + E + A2, 1, H + " +lat_1=-36 +lat_2=-38 +lat_0=-37 +lon_0=145" + Ci + Gb + x + r + E + A2, 1, H + " +lat_1=-36 +lat_2=-38 +lat_0=-37 +lon_0=145" + Ci + JH + C + B + E + A2, 1, H + " +lat_1=-18" + ZT + L3 + " +lon_0=134" + s + N + C + B + E + A2, 1, D + " +lat_0=-28" + NY + Jl + Jm + EK + C + B + E + A2, 1, D + Ie + " +lon_0=-80.07750791666666 +k=1" + BZ + AH + C + B + E + A2, 1, D + Ie + " +lon_0=-77.07750791666666 +k=1" + BZ + AH + C + B + E + A2, 1, D + Ie + " +lon_0=-74.07750791666666 +k=1" + BZ + AH + C + B + E + A2, 1, D + Ie + " +lon_0=-71.07750791666666 +k=1" + BZ + AH + C + B + E + A2, 1, D + Ie + " +lon_0=-68.07750791666666 +k=1" + BZ + AH + C + B + E + A2, 1, D + L3 + YH + " +k=0.999" + BZ + AH + R + Qe + E + A2, 1, GU + " +lat_0=50.625 +lon_0=21.08333333333333" + UG + " +x_0=4637000 +y_0=5467000" + M + b + E + A2, 1, D + L3 + Fm + CP + O2 + N + i + BX + E + A2, 1, D + L3 + ZU + CP + O2 + N + i + BX + E + A2, 1, D + L3 + ZV + CP + O2 + N + i + BX + E + A2, 1, D + L3 + Fr + CP + O2 + N + i + BX + E + A2, 1, D + L3 + Ru + CP + O2 + N + i + BX + E + A2, 1, D + L3 + RI + " +k=1" + O2 + N + C + B + E + A2, 1, D + L3 + UI + " +k=1" + O2 + N + C + B + E + A2, 1, D + L3 + Gl + " +k=1" + O2 + N + C + B + E + A2, 1, D + L3 + Yx + " +k=1" + O2 + N + C + B + E + A2, 1, D + L3 + SP + " +k=1" + O2 + N + C + B + E + A2, 1, D + L3 + II + " +k=1" + O2 + N + C + B + E + A2, 1, D + L3 + RJ + " +k=1" + O2 + N + C + B + E + A2, 1, D + L3 + UJ + " +k=1" + O2 + N + C + B + E + A2, 1, D + L3 + HO + " +k=1" + O2 + N + C + B + E + A2, 1, D + L3 + RP + " +k=1" + O2 + N + C + B + E + A2, 1, D + L3 + " +lon_0=29 +k=1" + O2 + N + C + B + E + A2, 1, D + L3 + Ia + " +k=1" + O2 + N + C + B + E + A2, 1, D + L3 + QQ + " +k=1" + O2 + N + C + B + E + A2, 2, Ck + " +lat_0=-18 +lon_0=178 +x_0=109435.392 +y_0=141622.272" + UW + Ym + Nl + " +to_meter=0.201168" + A2, 1, I2 + PL + o + R + JD + E + A2, 1, I2 + SK + o + R + JD + E + A2, 6, I2 + Mh + By + Ay + JP + E + A2, 1, I2 + Mi + By + Ay + JP + E + A2, 3, D + L3 + " +lon_0=18.05779 +k=0.99999425 +x_0=100178.1808 +y_0=-6500614.7836" + C + B + E + A2, 1, DT + Yv + " +lat_2=58.5" + IP + " +lon_0=-126" + BZ + N + C + B + E + A2, 1, I2 + RH + C + B + E + A2, 1, I2 + TW + C + B + E + A2, 1, I2 + TX + C + B + E + A2, 1, I2 + QE + C + B + E + A2, 1, I2 + Nw + C + B + E + A2, 1, I2 + NP + C + B + E + A2, 1, I2 + NQ + C + B + E + A2, 1, H + YI + " +lat_2=53.5" + L3 + SA + " +x_0=930000 +y_0=6430000" + C + B + E + A2, 1, H + YI + " +lat_2=53.5" + L3 + SA + " +x_0=930000 +y_0=6430000" + C + B + E + A2, 1, H + " +lat_1=-20.66666666666667 +lat_2=-22.33333333333333 +lat_0=-21.5" + ZW + u + Hk + C + B + E + A2, 1, I2 + MA + o + j + QB + E + A2, 1, H + " +lat_1=-22.24469175 +lat_2=-22.29469175 +lat_0=-22.26969175 +lon_0=166.44242575 +x_0=0.66 +y_0=1.02" + R + HH + E + A2, 1, H + " +lat_1=-22.24472222222222 +lat_2=-22.29472222222222 +lat_0=-22.26972222222222 +lon_0=166.4425 +x_0=8.313000000000001 +y_0=-2.354" + R + HH + E + A2, 1, CU + Qi + aF + aT + Ph + Of + N + KE + GZ + Yn + Qz + " +to_meter=20.116756" + A2, 1, CU + Qi + aF + aT + Ph + " +x_0=804670.24" + N + KE + GZ + Yn + Qz + E + A2, 1, I2 + SM + o + C + B + E + A2, 1, I2 + MA + o + C + B + E + A2, 1, I2 + Nq + o + C + B + E + A2, 1, I2 + Nq + o + R + Jf + E + A2, 2, DT + " +lat_1=42.122774 +lat_2=49.01518 +lat_0=45.568977 +lon_0=-84.455955" + BZ + AH + C + B + E + A2, 1, DT + " +lat_1=42.122774 +lat_2=49.01518 +lat_0=45.568977 +lon_0=-83.248627" + BZ + AH + C + B + E + A2, 1, D + L3 + ZQ + AP + O2 + N + By + Ay + JP + E + A2, 1, D + L3 + UE + " +k=0.9965000000000001" + BZ + N + R + w + E + A2, 1, I2 + IC + C + B + E + A2, 1, I2 + Hi + C + B + E + A2, 1, I2 + Gz + C + B + E + A2, 1, I2 + ID + C + B + E + A2, 1, I2 + Io + C + B + E + A2, 1, I2 + MB + C + B + E + A2, 1, I2 + Nx + C + B + E + A2, 1, I2 + Nr + C + B + E + A2, 1, I2 + Os + C + B + E + A2, 1, I2 + SL + C + B + E + A2, 1, I2 + Ja + C + B + E + A2, 1, I2 + KA + C + B + E + A2, 1, D + L3 + KB + CP + h + N + R + w + E + A2, 1, D + L3 + " +lon_0=11" + CP + h + N + R + w + E + A2, 1, D + L3 + " +lon_0=13" + CP + h + N + R + w + E + A2, 1, D + L3 + Gj + CP + h + N + R + w + E + A2, 1, D + L3 + UE + CP + h + N + R + w + E + A2, 1, D + L3 + RI + CP + h + N + R + w + E + A2, 1, D + L3 + Gl + CP + h + N + R + w + E + A2, 1, D + L3 + SP + CP + h + N + R + w + E + A2, 1, D + L3 + RJ + CP + h + N + R + w + E + A2, 1, I2 + JN + R + w + E + A2, 1, H + Qq + Li + JS + PZ + AV + aG + c + QC + E + A2, 1, I2 + KC + R + w + E + A2, 1, I2 + NR + R + w + E + A2, 1, I2 + Ki + R + w + E + A2, 1, H + Om + On + m + Pe + s + N + S + E + A2, 1, H + Om + On + m + Nb + s + N + S + E + A2, 1, H + Om + On + m + " +lon_0=-42" + s + N + S + E + A2, 1, H + BQ + BR + m + SU + s + N + S + E + A2, 1, H + BQ + BR + m + Pe + s + N + S + E + A2, 1, H + BQ + BR + m + Nb + s + N + S + E + A2, 1, H + BQ + BR + m + PO + s + N + S + E + A2, 1, H + BQ + BR + m + SR + s + N + S + E + A2, 1, H + BQ + BR + m + UH + s + N + S + E + A2, 1, H + BQ + BR + m + Lt + s + N + S + E + A2, 1, H + BQ + BR + m + Hq + s + N + S + E + A2, 1, H + BQ + BR + m + Jj + s + N + S + E + A2, 1, H + BQ + BR + m + Im + s + N + S + E + A2, 1, H + BQ + BR + m + Jk + s + N + S + E + A2, 1, H + BQ + BR + m + Rx + s + N + S + E + A2, 1, H + BQ + BR + m + Oe + s + N + S + E + A2, 1, H + BQ + BR + m + Ql + s + N + S + E + A2, 1, H + AM + AN + m + " +lon_0=-102" + s + N + S + E + A2, 1, H + AM + AN + m + Bu + s + N + S + E + A2, 1, H + AM + AN + m + " +lon_0=-78" + s + N + S + E + A2, 1, H + AM + AN + m + Pe + s + N + S + E + A2, 1, H + AM + AN + m + " +lon_0=-18" + s + N + S + E + A2, 1, H + AM + AN + m + " +lon_0=-6" + s + N + S + E + A2, 1, H + AM + AN + m + ZO + s + N + S + E + A2, 1, H + AM + AN + m + QR + s + N + S + E + A2, 1, H + AM + AN + m + Ia + s + N + S + E + A2, 1, H + AM + AN + m + PO + s + N + S + E + A2, 1, H + AM + AN + m + SR + s + N + S + E + A2, 1, H + AM + AN + m + UH + s + N + S + E + A2, 1, H + AM + AN + m + Lt + s + N + S + E + A2, 1, H + AM + AN + m + Hq + s + N + S + E + A2, 1, H + AM + AN + m + Jj + s + N + S + E + A2, 1, H + AM + AN + m + Im + s + N + S + E + A2, 1, H + AM + AN + m + Jk + s + N + S + E + A2, 1, H + AM + AN + m + Rx + s + N + S + E + A2, 1, H + AM + AN + m + Oe + s + N + S + E + A2, 1, H + AM + AN + m + Ql + s + N + S + E + A2, 1, H + AM + AN + m + UP + s + N + S + E + A2, 1, H + Ah + AZ + m + YJ + s + N + S + E + A2, 1, H + Ah + AZ + m + YK + s + N + S + E + A2, 1, H + Ah + AZ + m + Lj + s + N + S + E + A2, 1, H + Ah + AZ + m + Ji + s + N + S + E + A2, 1, H + Ah + AZ + m + CR + s + N + S + E + A2, 1, H + Ah + AZ + m + Qk + s + N + S + E + A2, 1, H + Ah + AZ + m + " +lon_0=-27" + s + N + S + E + A2, 1, H + Ah + AZ + m + " +lon_0=-9" + s + N + S + E + A2, 1, H + Ah + AZ + m + KB + s + N + S + E + A2, 1, H + Ah + AZ + m + HO + s + N + S + E + A2, 1, H + Ah + AZ + m + JS + s + N + S + E + A2, 1, H + Ah + AZ + m + QW + s + N + S + E + A2, 1, H + Ah + AZ + m + HQ + s + N + S + E + A2, 1, H + Ah + AZ + m + HS + s + N + S + E + A2, 1, H + Ah + AZ + m + Fm + s + N + S + E + A2, 1, H + Ah + AZ + m + Fn + s + N + S + E + A2, 1, H + Ah + AZ + m + NY + s + N + S + E + A2, 1, H + Ah + AZ + m + Lf + s + N + S + E + A2, 1, H + Ai + Aj + m + SV + s + N + S + E + A2, 1, H + Ai + Aj + m + " +lon_0=-144" + s + N + S + E + A2, 1, H + Ai + Aj + m + Mt + s + N + S + E + A2, 1, H + Ai + Aj + m + OZ + s + N + S + E + A2, 1, H + Ai + Aj + m + UQ + s + N + S + E + A2, 1, H + Ai + Aj + m + " +lon_0=-48" + s + N + S + E + A2, 1, H + Ai + Aj + m + " +lon_0=-24" + s + N + S + E + A2, 1, H + Ai + Aj + m + HN + s + N + S + E + A2, 1, H + Ai + Aj + m + II + s + N + S + E + A2, 1, H + Ai + Aj + m + SQ + s + N + S + E + A2, 1, H + Ai + Aj + m + Yt + s + N + S + E + A2, 1, H + Ai + Aj + m + Mj + s + N + S + E + A2, 1, H + Ai + Aj + m + KF + s + N + S + E + A2, 1, H + Ai + Aj + m + UN + s + N + S + E + A2, 1, H + Ai + Aj + m + UO + s + N + S + E + A2, 1, BP + m + AW + SX + " +k=1" + s + N + S + E + A2, 1, BP + m + AW + YK + " +k=1" + s + N + S + E + A2, 1, BP + m + AW + " +lon_0=-105 +k=1" + s + N + S + E + A2, 1, BP + m + AW + UR + " +k=1" + s + N + S + E + A2, 1, BP + m + AW + " +lon_0=-45 +k=1" + s + N + S + E + A2, 1, BP + m + AW + " +lon_0=-15 +k=1" + s + N + S + E + A2, 1, BP + m + AW + Gj + " +k=1" + s + N + S + E + A2, 1, BP + m + AW + JS + " +k=1" + s + N + S + E + A2, 1, BP + m + AW + HP + " +k=1" + s + N + S + E + A2, 1, BP + m + AW + EN + " +k=1" + s + N + S + E + A2, 1, BP + m + AW + Fn + " +k=1" + s + N + S + E + A2, 1, BP + m + AW + NZ + " +k=1" + s + N + S + E + A2, 1, BP + m + AW + ON + " +k=1" + s + N + S + E + A2, 1, BP + m + AW + Bu + " +k=1" + s + N + S + E + A2, 1, BP + m + AW + " +lon_0=-30 +k=1" + s + N + S + E + A2, 1, BP + m + AW + Ia + " +k=1" + s + N + S + E + A2, 1, BP + m + AW + Hq + " +k=1" + s + N + S + E + A2, 1, BP + m + AW + Oe + " +k=1" + s + N + S + E + A2, 1, BP + m + AW + HN + " +k=1" + s + N + S + E + A2, 1, H + Ai + Aj + " +lat_0=-78" + Ql + s + N + S + E + A2, 2, I2 + RG + o + C + Bm + E + A2, 1, I2 + Ro + o + C + Bm + E + A2, 1, I2 + RH + o + C + Bm + E + A2, 1, I2 + TW + o + C + Bm + E + A2, 1, H + WF + " +lat_2=58" + WG + II + O2 + " +y_0=6375000" + C + Lw + E + A2, 1, H + WF + " +lat_2=58" + WG + II + O2 + " +y_0=6375000" + C + B + E + A2, 1, I2 + RH + o + R + Lq + E + A2, 1, I2 + RH + o + R + Kc + E + A2, 1, I2 + Ro + o + R + Kg + E + A2, 1, I2 + Ro + o + R + Kh + E + A2, 1, I2 + RG + o + R + QN + E + A2, 1, I2 + JM + j + TD + E + A2, 1, H + " +lat_1=-30.75 +lat_2=-35.75 +lat_0=-33.25" + Od + " +x_0=9300000" + Gb + C + B + E + A2, 1, DT + Yy + SY + L3 + Mt + s + QZ + X + E + A2, 1, DT + Yy + SY + L3 + Mt + s + QZ + C + B + E + A2, 1, DT + Yy + SY + L3 + Mt + s + QZ + C + B + E + A2, 1, I2 + ID + R + NH + E + A2, 1, I2 + ID + C + B + E + A2, 3, D + L3 + Yx + V2 + O2 + Ak + c + E + A2, 1, D + L3 + II + V2 + O2 + Ak + c + E + A2, 1, D + L3 + IH + V2 + O2 + Ak + c + E + A2, 1, D + L3 + " +lon_0=14" + V2 + O2 + Ak + c + E + A2, 1, D + L3 + " +lon_0=16" + V2 + O2 + Ak + c + E + A2, 1, D + L3 + QR + V2 + O2 + Ak + c + E + A2, 1, D + L3 + UI + V2 + O2 + Ak + c + E + A2, 1, D + L3 + Yx + V2 + O2 + Ak + c + E + A2, 1, D + L3 + II + V2 + O2 + Ak + c + E + A2, 1, D + L3 + UJ + V2 + O2 + Ak + c + E + A2, 1, D + L3 + RP + V2 + O2 + Ak + c + E + A2, 1, D + L3 + Ia + V2 + O2 + Ak + c + E + A2, 1, GU + " +lat_0=52.16666666666666 +lon_0=19.16666666666667 +k=0.999714" + O2 + Ae + M + b + E + A2, 1, D + L3 + Gj + " +k=1" + Eg + N + M + b + E + A2, 1, D + L3 + QR + " +k=1" + Jt + N + M + b + E + A2, 1, D + L3 + Gl + " +k=1" + IM + N + M + b + E + A2, 1, D + L3 + II + " +k=1" + MS + N + M + b + E + A2, 1, D + L3 + Gj + " +k=1" + Bo + N + M + b + E + A2, 1, D + L3 + Gl + " +k=1" + DP + N + M + b + E + A2, 1, D + L3 + HO + " +k=1" + Eg + N + M + b + E + A2, 1, I2 + Rc + o + R + TE + E + A2, 1, H + " +lat_1=-20.19506944444445 +lat_0=-20.19506944444445 +lon_0=57.52182777777778 +k_0=1" + BZ + AH + c + Qf + E + A2, 1, DT + " +lat_1=55" + QY + Yu + Ms + s + N + C + B + E + A2, 1, D + L3 + IH + V2 + O2 + Ak + c + GN + E + A2, 1, D + L3 + " +lon_0=14" + V2 + O2 + Ak + c + GN + E + A2, 1, D + L3 + " +lon_0=16" + V2 + O2 + Ak + c + GN + E + A2, 1, I2 + KC + o + c + GN + E + A2, 1, I2 + Ja + C + B + E + A2, 1, I2 + KA + C + B + E + A2, 1, I2 + Oq + C + B + E + A2, 1, D + L3 + II + UG + O2 + N + C + B + E + A2, 1, H + LM + IJ + " +lat_0=63.390675" + UY + " +x_0=6200000" + Fq + C + B + E + A2, 1, H + LM + IJ + " +lat_0=63.390675" + UY + " +x_0=6200000" + Fq + C + B + E + A2, 2, D + " +lat_0=0.1 +lon_0=21.95 +k=1" + Bv + N + M + F + E + A2, 1, D + " +lat_0=0.1 +lon_0=24.95 +k=1 +x_0=1250000" + N + M + F + E + A2, 1, D + " +lat_0=0.1 +lon_0=27.95 +k=1 +x_0=2250000" + N + M + F + E + A2, 1, I2 + JN + o + R + E + A2, 1, I2 + JN + o + R + E + A2, 1, D + Gm + QQ + " +k=1 +x_0=615000 +y_0=810000" + Gn + Qg + E + A2, 3, H + Et + Eu + LT + NW + Rh + N + C + B + E + A2, 2, H + FC + OD + Dr + CR + OE + N + C + B + E + A2, 1, H + FC + OD + Dr + CR + OE + N + C + B + t + A2, 1, H + MW + FB + BB + Ea + a + N + C + B + E + A2, 1, H + MW + FB + BB + Ea + a + N + C + B + J + A2, 1, H + Dp + Dq + y + Ea + a + N + C + B + E + A2, 1, H + Dp + Dq + y + Ea + a + N + C + B + J + A2, 2, I2 + Ja + c + E + A2, 1, I2 + KA + c + E + A2, 1, I2 + Oq + c + E + A2, 1, I2 + Nq + X + E + A2, 1, I2 + PL + X + E + A2, 1, I2 + Nq + C + B + E + A2, 1, I2 + PL + C + B + E + A2, 1, I2 + KA + R + E + A2, 1, CU + Qi + aF + " +alpha=323.0257964666666" + Ph + " +x_0=804671" + N + KE + GZ + C + E + A2, 1, CU + Qi + Yz + aU + Ph + s + N + KE + If + C + E + A2, 1, Ck + " +lat_0=2.121679744444445 +lon_0=103.4279362361111 +x_0=-14810.562 +y_0=8758.32" + C + E + A2, 1, Ck + " +lat_0=2.682347636111111 +lon_0=101.9749050416667 +x_0=3673.785 +y_0=-4240.573" + C + E + A2, 1, Ck + " +lat_0=3.769388088888889 +lon_0=102.3682989833333 +x_0=-7368.228 +y_0=6485.858" + C + E + A2, 1, Ck + " +lat_0=3.68464905 +lon_0=101.3891079138889 +x_0=-34836.161 +y_0=56464.049" + C + E + A2, 1, Ck + " +lat_0=4.9762852 +lon_0=103.070275625 +x_0=19594.245 +y_0=3371.895" + C + E + A2, 1, Ck + " +lat_0=5.421517541666667 +lon_0=100.3443769638889 +x_0=-23.414 +y_0=62.283" + C + E + A2, 1, Ck + " +lat_0=5.964672713888889 +lon_0=100.6363711111111" + s + N + C + E + A2, 1, Ck + " +lat_0=4.859063022222222 +lon_0=100.8154105861111 +x_0=-1.769 +y_0=133454.779" + C + E + A2, 1, Ck + " +lat_0=5.972543658333334 +lon_0=102.2952416694444 +x_0=13227.851 +y_0=8739.894" + C + E + A2, 1, D + L3 + QR + " +k=1" + O2 + N + R + At + E + A2, 1, D + L3 + IG + " +k=1" + Eg + N + R + At + E + A2, 1, JU + PS + " +lat_ts=42" + s + N + M + F + E + A2, 1, D + L3 + Ry + " +k=1 +x_0=60500000" + N + M + F + E + A2, 1, D + L3 + Ry + " +k=1 +x_0=60500000" + N + M + G + E + A2, 1, I2 + KD + c + EU + E + A2, 1, I2 + JZ + c + EU + E + A2, 1, I2 + JM + c + EU + E + A2, 1, H + Qq + Li + JS + PZ + AV + aG + c + E + A2, 1, JU + HN + " +k=1" + s + N + S + E + A2, 1, D + L3 + KB + " +k=1" + Bo + N + Y + E + A2, 1, D + L3 + IH + " +k=1" + DP + N + Y + E + A2, 1, D + L3 + IH + " +k=1" + DP + N + Y + E + A2, 1, D + L3 + Gj + " +k=1" + Eg + N + Y + E + A2, 1, D + L3 + SZ + " +k=0.9992" + O2 + N + C + B + E + A2, 1, D + L3 + SZ + " +k=0.9992" + s + N + C + B + E + A2, 1, D + L3 + SZ + " +k=0.9992" + O2 + N + C + B + E + A2, 1, D + L3 + SZ + " +k=0.9992" + s + N + C + B + E + A2, 1, H + Et + Eu + LT + NW + Z2 + N + C + B + J + A2, 1, I2 + Mh + j + Fu + E + A2, 1, I2 + Mi + j + Fu + E + A2, 1, Ck + Vt + Vu + " +x_0=40243.57775604237 +y_0=19069.93351512578" + Ee + Ef + ML + A2, 1, He + Hr + HN + s + N + ZX + ZY + E + A2, 1, He + m + HN + s + N + ZX + ZY + E + A2, 1, "+proj=cea" + HN + " +lat_ts=30" + s + N + ZX + ZY + E + A2, 1, BP + Hr + " +lat_ts=70 +lon_0=-45 +k=1" + s + N + ZZ + Ri + E + A2, 1, BP + m + " +lat_ts=-70" + HN + " +k=1" + s + N + ZZ + Ri + E + A2, 1, BP + Hr + " +lat_ts=70 +lon_0=-45 +k=1" + s + N + S + E + A2, 1, D + " +lat_0=1.366666666666667 +lon_0=103.8333333333333 +k=1 +x_0=28001.642 +y_0=38744.572" + j + E + A2, 1, H + " +lat_1=18 +lat_2=24 +lat_0=21" + Im + O2 + Ae + T + Q + E + A2, 1, H + LM + Nh + " +lat_0=47.5" + Ig + u + Is + C + B + E + A2, 1, H + EB + EC + Fo + GG + AV + GJ + C + B + J + A2, 1, H + AY + ED + Fs + GG + AG + N + C + B + J + A2, 1, H + EE + EF + AQ + Fl + Au + N + C + B + J + A2, 1, H + EG + EH + f + CV + Au + Gt + C + B + J + A2, 1, D + CQ + DF + V2 + Gu + MN + C + B + J + A2, 1, D + CQ + DG + V2 + AG + Hh + C + B + J + A2, 1, D + CQ + DH + V2 + An + NE + C + B + J + A2, 1, D + BA + Gp + V2 + Bn + N + C + B + J + A2, 1, H + EB + EC + Fo + GG + AV + GJ + C + B + J + A2, 1, H + AY + ED + Fs + GG + AG + N + C + B + J + A2, 1, H + EE + EF + AQ + Fl + Au + N + C + B + J + A2, 1, H + EG + EH + f + CV + Au + Gt + C + B + J + A2, 1, D + CQ + DF + V2 + Gu + MN + C + B + J + A2, 1, D + CQ + DG + V2 + AG + Hh + C + B + J + A2, 1, D + CQ + DH + V2 + An + NE + C + B + J + A2, 1, D + BA + Gp + V2 + Bn + N + C + B + J + A2, 1, H + Dx + Dy + BC + IF + Au + N + C + B + J + A2, 1, H + Dz + Mq + EA + IF + Au + Gt + C + B + J + A2, 1, D + f + Cz + EQ + BF + N + C + B + J + A2, 1, D + f + DA + Am + MO + N + C + B + J + A2, 1, D + Fp + DI + AO + BF + N + C + B + J + A2, 1, D + EI + GE + Lb + JV + N + C + B + J + A2, 1, I2 + JM + c + Gg + E + A2, 1, I2 + Me + c + Gg + E + A2, 1, H + Dx + Dy + BC + IF + Au + N + C + B + J + A2, 1, H + Dz + Mq + EA + IF + Au + Gt + C + B + J + A2, 1, D + f + Cz + EQ + BF + N + C + B + J + A2, 1, D + f + DA + Am + MO + N + C + B + J + A2, 1, D + Fp + DI + AO + BF + N + C + B + J + A2, 1, D + EI + GE + Lb + JV + N + C + B + J + A2, 1, H + Ks + Kt + " +lat_0=50.797815" + WH + " +x_0=150328 +y_0=166262" + C + B + E + A2, 1, H + " +lat_1=18" + OX + Ld + " +k_0=1" + YL + " +y_0=650000" + j + B + E + A2, 1, I2 + Ik + j + B + E + A2, 1, I2 + IC + j + B + E + A2, 1, H + FS + FT + IY + Hg + Eb + N + C + B + J + A2, 1, H + OH + OI + OJ + Bi + Eb + N + C + B + J + A2, 1, H + CD + CE + " +lat_0=25.5" + Bi + Eb + N + C + B + J + A2, 2, H + OL + Ff + EJ + Ag + a + N + C + B + J + A2, 1, H + FS + FT + IY + Hg + Eb + N + C + B + J + A2, 1, H + OH + OI + OJ + Bi + Eb + N + C + B + J + A2, 1, H + Fd + Fe + AL + CS + a + N + C + B + J + A2, 1, H + OL + Ff + EJ + Ag + a + N + C + B + J + A2, 1, D + " +lat_0=-17 +lon_0=178.75 +k=0.99985" + Bd + LV + T + P + E + A2, 1, I2 + Ja + AU + BN + Nm + E + A2, 1, I2 + KA + AU + BN + Nm + E + A2, 1, D + YM + Rj + JE + O2 + N + C + B + E + A2, 1, D + YM + Rj + JE + O2 + N + C + B + E + A2, 1, D + IY + IV + Pc + h + N + C + B + E + A2, 1, D + Gm + OS + BG + a + N + C + B + E + A2, 1, DT + " +lat_1=55" + QY + Yu + Ms + s + N + C + B + E + A2, 1, CU + " +lat_0=57" + Ku + Kv + V2 + LX + EO + KE + GZ + C + B + E + A2, 1, D + Ft + YN + V2 + O2 + N + C + B + E + A2, 1, D + Ft + YO + V2 + O2 + N + C + B + E + A2, 1, D + Ft + ON + V2 + O2 + N + C + B + E + A2, 1, D + Ft + Ms + V2 + O2 + N + C + B + E + A2, 1, D + Ft + KI + V2 + O2 + N + C + B + E + A2, 1, D + Ft + YP + V2 + O2 + N + C + B + E + A2, 1, D + Ft + YQ + V2 + O2 + N + C + B + E + A2, 1, D + Ft + SW + V2 + O2 + N + C + B + E + A2, 1, H + Kw + Kx + UK + YR + BZ + N + C + B + E + A2, 1, D + Bl + Co + V2 + EX + N + C + B + E + A2, 1, D + Bl + Co + V2 + EX + N + C + B + t + A2, 1, D + Bl + Cn + V2 + EX + N + C + B + E + A2, 1, D + Bl + Cn + V2 + EX + N + C + B + t + A2, 1, D + Bl + Iv + BG + EX + N + C + B + E + A2, 1, D + Bl + Iv + BG + EX + N + C + B + t + A2, 1, H + Dx + Dy + BC + IF + u + N + C + B + E + A2, 1, H + Dx + Dy + BC + IF + Au + N + C + B + J + A2, 1, H + Dz + Mq + EA + IF + u + Is + C + B + E + A2, 1, H + Dz + Mq + EA + IF + Au + Gt + C + B + J + A2, 1, DT + Yy + SY + L3 + Mt + s + QZ + C + B + E + A2, 1, H + DW + Jn + y + HA + Bd + Ae + C + B + E + A2, 1, H + DW + Jn + y + HA + Ac + AD + C + B + J + A2, 1, H + DX + DY + AA + HA + Bd + Ae + C + B + E + A2, 1, H + DX + DY + AA + HA + Ac + AD + C + B + J + A2, 1, H + Ap + DZ + Ml + AJ + Bd + Ae + C + B + E + A2, 1, H + Ap + DZ + Ml + AJ + Ac + AD + C + B + J + A2, 1, H + LO + QS + Da + Mm + Bd + Ae + C + B + E + A2, 1, H + LO + QS + Da + Mm + Ac + AD + C + B + J + A2, 1, H + Db + Dc + Mn + Ir + Bd + Ae + C + B + E + A2, 1, H + Db + Dc + Mn + Ir + Ac + AD + C + B + J + A2, 1, H + Dd + De + Df + Iw + Bd + Ae + C + B + E + A2, 1, H + Dd + De + Df + Iw + Ac + AD + C + B + J + A2, 1, H + LP + LQ + CY + Ba + Fw + Fx + C + B + E + A2, 1, H + LP + LQ + CY + Ba + Bw + CL + C + B + J + A2, 1, H + Eh + Ei + y + Ba + Fw + Fx + C + B + E + A2, 1, H + Eh + Ei + y + Ba + Bw + CL + C + B + J + A2, 1, H + Ap + Dg + f + Ba + Fw + Fx + C + B + E + A2, 1, H + Ap + Dg + f + Ba + Bw + CL + C + B + J + A2, 1, H + Dh + Mo + Di + Jq + QG + QH + C + B + E + A2, 1, H + Dh + Mo + Di + Jq + MC + MD + C + B + J + A2, 1, D + Ch + Cp + Mp + h + N + C + B + E + A2, 1, D + Ch + Cp + Mp + AE + N + C + B + J + A2, 1, D + Aq + CR + Am + h + N + C + B + E + A2, 1, D + Aq + CR + Am + AE + N + C + B + J + A2, 1, DT + " +lat_1=24" + YG + " +lat_0=24" + NV + u + N + C + B + E + A2, 1, H + LR + Dj + QT + LS + a + N + C + B + E + A2, 1, H + LR + Dj + QT + LS + a + N + C + B + J + A2, 1, D + Aq + Ob + Am + h + N + C + B + E + A2, 1, D + Aq + Ob + Am + AE + N + C + B + J + A2, 1, D + Gm + Cq + V2 + h + N + C + B + E + A2, 1, D + Gm + Cq + V2 + AE + N + C + B + J + A2, 1, D + Gm + Cr + V2 + EW + N + C + B + E + A2, 1, D + Gm + Cr + V2 + CM + N + C + B + J + A2, 1, D + p + Jb + BJ + O2 + N + C + B + E + A2, 1, D + p + Jb + BJ + AF + N + C + B + J + A2, 1, D + p + Cs + BJ + h + N + C + B + E + A2, 1, D + p + Cs + BJ + AE + N + C + B + J + A2, 1, D + p + Ix + BG + CX + N + C + B + E + A2, 1, D + p + Ix + BG + ME + N + C + B + J + A2, 1, D + f + Cz + EQ + AI + N + C + B + E + A2, 1, D + f + Cz + EQ + BF + N + C + B + J + A2, 1, D + f + DA + Am + EW + N + C + B + E + A2, 1, D + f + DA + Am + MO + N + C + B + J + A2, 1, D + DM + DB + AO + BU + KJ + C + B + E + A2, 1, D + DM + DB + AO + MM + GI + C + B + J + A2, 1, D + DM + DC + AO + HT + KJ + C + B + E + A2, 1, D + DM + DC + AO + HT + GI + C + B + J + A2, 1, H + EB + EC + Fo + GG + AV + AH + C + B + E + A2, 1, H + EB + EC + Fo + GG + AV + GJ + C + B + J + A2, 1, H + AY + ED + Fs + GG + O2 + N + C + B + E + A2, 1, H + AY + ED + Fs + GG + AG + N + C + B + J + A2, 1, H + EE + EF + AQ + Fl + u + N + C + B + E + A2, 1, H + EE + EF + AQ + Fl + Au + N + C + B + J + A2, 1, H + EG + EH + f + CV + u + Is + C + B + E + A2, 1, H + EG + EH + f + CV + Au + Gt + C + B + J + A2, 1, H + Az + DV + DM + Jo + O2 + N + C + B + E + A2, 1, H + Az + DV + DM + Jo + AF + N + C + B + J + A2, 1, H + Fi + Fj + AB + EY + AV + AH + C + B + E + A2, 1, H + Fi + Fj + AB + EY + AV + CN + C + B + J + A2, 1, H + Ej + Ek + AB + EY + O2 + Ae + C + B + E + A2, 1, H + Ej + Ek + AB + EY + AF + AD + C + B + J + A2, 1, H + FS + FT + IY + Hg + BZ + N + C + B + E + A2, 1, H + FS + FT + IY + Hg + Eb + N + C + B + J + A2, 1, H + OH + OI + OJ + Bi + BZ + N + C + B + E + A2, 1, H + OH + OI + OJ + Bi + Eb + N + C + B + J + A2, 1, D + YM + Rj + JE + O2 + N + C + B + E + A2, 1, D + AL + Rf + JE + EW + N + C + B + E + A2, 1, D + BD + Rg + JE + AI + N + C + B + E + A2, 1, D + AK + HJ + V2 + AI + N + C + B + E + A2, 1, D + BD + DD + AO + HT + N + C + B + E + A2, 1, H + MU + Nz + AA + Ld + u + N + C + B + E + A2, 1, H + AY + CF + Br + BI + AG + GJ + C + B + J + A2, 1, D + Kn + Sf + AO + e + N + i + GB + J + A2, 1, D + Ko + KO + AO + e + N + i + GB + J + A2, 1, D + GV + KI + Jl + e + N + i + GB + J + A2, 1, D + Kp + Sg + Jl + e + N + i + GB + J + A2, 1, D + Kq + KP + " +k=1" + e + N + i + GB + J + A2, 1, H + JF + CG + AQ + BI + AG + NF + C + B + J + A2, 1, H + JG + CH + f + BI + AG + Fq + C + B + J + A2, 1, H + AY + CF + Br + BI + AG + GJ + C + B + J + A2, 1, H + JF + CG + AQ + BI + AG + NF + C + B + J + A2, 1, H + JG + CH + f + BI + AG + Fq + C + B + J + A2, 1, He + Hr + Ry + s + N + S + E + A2, 1, He + Hr + ON + s + N + S + E + A2, 1, He + Hr + CS + s + N + S + E + A2, 1, He + Hr + " +lon_0=-40" + s + N + S + E + A2, 1, He + Hr + Lu + s + N + S + E + A2, 1, He + Hr + Hq + s + N + S + E + A2, 1, DT + " +lat_1=-18" + ZT + L3 + Il + s + N + C + B + E + A2, 1, DT + WI + " +lat_2=68 +lat_0=59 +lon_0=-132.5" + O2 + Ae + C + B + E + A2, 1, DT + WI + " +lat_2=68 +lat_0=59 +lon_0=-132.5" + O2 + Ae + C + B + E + A2, 1, H + " +lat_1=62 +lat_2=70" + L3 + " +lon_0=-112" + s + N + C + B + E + A2, 1, H + " +lat_1=62 +lat_2=70" + L3 + " +lon_0=-112" + s + N + C + B + E + A2, 1, H + MU + Nz + AA + Ld + MF + N + C + B + J + A2, 1, H + Em + En + Ip + IL + O2 + N + C + B + E + A2, 1, H + Em + En + Ip + IL + AF + N + C + B + J + A2, 1, H + El + Dk + Ip + GE + h + Mk + C + B + E + A2, 1, H + El + Dk + Ip + GE + AE + Mk + C + B + J + A2, 1, H + OA + Er + Es + BE + Pk + N + C + B + E + A2, 1, H + OA + Er + Es + BE + MH + N + C + B + t + A2, 1, H + Eo + Ep + Eq + Jh + Tl + N + C + B + E + A2, 1, H + Eo + Ep + Eq + Jh + MG + N + C + B + t + A2, 1, CU + Kr + " +lonc=-86" + QI + AP + QJ + PY + KE + QK + C + B + E + A2, 1, H + Bq + OB + Fo + BE + LU + N + C + B + E + A2, 1, H + Bq + OB + Fo + BE + OT + N + C + B + t + A2, 1, H + Ma + FW + IP + Js + CX + EK + C + B + E + A2, 1, H + FU + FV + Iq + DE + CX + EK + C + B + E + A2, 1, H + FX + FY + Nj + Na + CX + EK + C + B + E + A2, 1, D + Hj + Ct + CP + AI + N + C + B + E + A2, 1, D + Hj + Ct + CP + BF + N + C + B + J + A2, 1, D + Hj + Bx + CP + EW + N + C + B + E + A2, 1, D + Hj + Bx + CP + CM + N + C + B + J + A2, 1, D + Cd + Hg + BG + O2 + N + C + B + E + A2, 1, D + Cd + RS + BG + Bv + N + C + B + E + A2, 1, D + Id + RT + Am + YC + N + C + B + E + A2, 1, H + LM + RK + MV + IS + a + N + C + B + E + A2, 1, H + LM + RK + MV + IS + DR + N + C + B + t + A2, 1, H + JT + Jn + FZ + CS + O2 + N + C + B + E + A2, 1, D + CQ + DG + V2 + O2 + Hh + C + B + E + A2, 1, D + CQ + DG + V2 + AG + Hh + C + B + J + A2, 1, D + CQ + DF + V2 + h + Tm + C + B + E + A2, 1, D + CQ + DF + V2 + Gu + MN + C + B + J + A2, 1, D + CQ + DH + V2 + CX + LV + C + B + E + A2, 1, D + CQ + DH + V2 + An + NE + C + B + J + A2, 1, D + Fp + DI + AO + AI + N + C + B + E + A2, 1, D + Fp + DI + AO + BF + N + C + B + J + A2, 1, D + BA + Gp + V2 + Bn + N + C + B + E + A2, 1, D + BA + Gp + V2 + Bn + N + C + B + J + A2, 1, D + Bl + Iy + V2 + O2 + N + C + B + E + A2, 1, D + Bl + Iy + V2 + AF + N + C + B + J + A2, 1, D + Bl + Cu + Hm + OC + N + C + B + E + A2, 1, D + Bl + Cu + Hm + OC + N + C + B + J + A2, 1, D + Bl + Cv + Iz + YD + N + C + B + E + A2, 1, D + Bl + Cv + Iz + MI + N + C + B + J + A2, 1, D + Fs + Cw + Ad + Bv + N + C + B + E + A2, 1, D + Fs + Cw + Ad + MJ + N + C + B + J + A2, 1, D + BA + Gp + V2 + Bn + N + C + B + E + A2, 1, D + BA + Gp + V2 + Bn + N + C + B + J + A2, 1, H + Dl + Dm + BB + Oc + AI + N + C + B + E + A2, 1, H + Dl + Dm + BB + Oc + BF + N + C + B + J + A2, 1, D + Fs + Cx + Ad + Qo + N + C + B + E + A2, 1, D + Fs + Cx + Ad + MK + N + C + B + J + A2, 1, H + Et + Eu + LT + NW + Rh + N + C + B + E + A2, 1, H + Et + Eu + LT + NW + Z2 + N + C + B + J + A2, 1, H + BH + Ev + Ib + EZ + a + N + C + B + E + A2, 1, H + BH + Ev + Ib + EZ + DR + N + C + B + t + A2, 1, H + Ew + Ex + Be + EZ + a + N + C + B + E + A2, 1, H + Ew + Ex + Be + EZ + DR + N + C + B + t + A2, 1, H + OK + Fa + BY + ET + a + N + C + B + E + A2, 1, H + Fb + Fc + Ch + ET + a + N + C + B + E + A2, 1, H + Dn + Ey + QU + Fl + a + N + C + B + E + A2, 1, H + Dn + Ey + QU + Fl + a + N + C + B + J + A2, 1, H + Ez + FA + Do + Fl + a + N + C + B + E + A2, 1, H + Ez + FA + Do + Fl + a + N + C + B + J + A2, 1, H + JT + Hl + GH + AJ + u + N + C + B + E + A2, 1, H + JT + Hl + GH + AJ + Lc + N + C + B + t + A2, 1, H + PP + CZ + AK + AJ + Ci + N + C + B + E + A2, 1, H + PP + CZ + AK + AJ + KL + N + C + B + t + A2, 1, H + PQ + Ca + p + AJ + AV + N + C + B + E + A2, 1, H + PQ + Ca + p + AJ + KM + N + C + B + t + A2, 1, H + MW + FB + BB + Ea + a + N + C + B + E + A2, 1, H + MW + FB + BB + Ea + a + N + C + B + J + A2, 1, H + Dp + Dq + y + Ea + a + N + C + B + E + A2, 1, H + Dp + Dq + y + Ea + a + N + C + B + J + A2, 1, D + EI + GE + Lb + BU + N + C + B + E + A2, 1, D + EI + GE + Lb + JV + N + C + B + J + A2, 1, H + FC + OD + Dr + CR + OE + N + C + B + E + A2, 1, H + FC + OD + Dr + CR + OE + N + C + B + t + A2, 1, H + Fd + Fe + AL + CS + a + N + C + B + E + A2, 1, H + Fd + Fe + AL + CS + a + N + C + B + J + A2, 1, H + OL + Ff + EJ + Ag + a + N + C + B + E + A2, 1, H + OL + Ff + EJ + Ag + a + N + C + B + J + A2, 1, H + FD + MX + BC + MQ + a + N + C + B + E + A2, 1, H + FD + MX + BC + MQ + a + N + C + B + J + A2, 1, H + FH + FI + Cb + Ag + EW + Fq + C + B + E + A2, 1, H + FH + FI + Cb + Ag + CM + Fq + C + B + J + A2, 1, DT + OM + RO + OX + CS + AV + Hh + C + B + E + A2, 1, H + OM + RO + OX + CS + AV + Ju + C + B + E + A2, 1, H + FE + MY + QV + Jr + h + AH + C + B + E + A2, 1, H + FE + MY + QV + Jr + AE + CN + C + B + J + A2, 1, H + FF + FG + Ds + CV + a + Cl + C + B + E + A2, 1, H + FF + FG + Ds + CV + a + Gr + C + B + J + A2, 1, H + CD + CE + Cc + CV + AI + Ju + C + B + E + A2, 1, H + CD + CE + Cc + CV + BF + Nf + C + B + J + A2, 1, H + FJ + FK + Dt + Ji + a + LV + C + B + E + A2, 1, H + FJ + FK + Dt + Ji + a + Ne + C + B + J + A2, 1, H + JF + CG + AQ + BI + O2 + Cl + C + B + E + A2, 1, H + JF + CG + AQ + BI + Gd + RY + C + B + t + A2, 1, H + JF + CG + AQ + BI + AG + NF + C + B + J + A2, 1, H + AY + CF + Br + BI + O2 + AH + C + B + E + A2, 1, H + AY + CF + Br + BI + Gd + Pw + C + B + t + A2, 1, H + AY + CF + Br + BI + AG + GJ + C + B + J + A2, 1, H + JG + CH + f + BI + O2 + Fq + C + B + E + A2, 1, H + JG + CH + f + BI + Gd + RZ + C + B + t + A2, 1, H + JG + CH + f + BI + AG + Fq + C + B + J + A2, 1, D + Fp + LW + JA + O2 + N + C + B + E + A2, 1, H + OF + FL + AA + GF + Bo + Cl + C + B + E + A2, 1, H + OF + FL + AA + GF + Gs + Gr + C + B + J + A2, 1, H + Az + Du + AB + GF + Bo + AH + C + B + E + A2, 1, H + Az + Du + AB + GF + Gs + CN + C + B + J + A2, 1, H + BH + OG + Ib + Cy + O2 + N + C + B + E + A2, 1, H + BH + OG + Ib + Cy + AF + N + C + B + J + A2, 1, H + FM + FN + Dv + AJ + O2 + N + C + B + E + A2, 1, H + FM + FN + Dv + AJ + AF + N + C + B + J + A2, 1, H + Mb + RN + Mr + Ga + a + N + C + B + E + A2, 1, H + Fg + Fh + QX + CR + a + N + C + B + E + A2, 1, H + Jc + MZ + AL + Bu + a + N + C + B + E + A2, 1, H + Jc + MZ + AL + Bu + a + N + C + B + J + A2, 1, H + FO + FP + Dw + Bu + a + N + C + B + E + A2, 1, H + FO + FP + Dw + Bu + a + N + C + B + J + A2, 1, H + FQ + FR + PR + Bu + a + N + C + B + E + A2, 1, H + FQ + FR + PR + Bu + a + N + C + B + J + A2, 1, D + L3 + Bu + AP + YF + Sh + C + B + E + A2, 1, D + CA + DJ + Ad + h + N + C + B + E + A2, 1, D + CA + DK + Ad + u + EK + C + B + E + A2, 1, D + CA + JB + Ad + a + N + C + B + E + A2, 1, D + CA + DL + Ad + CX + EK + C + B + E + A2, 1, I2 + Nq + C + B + E + A2, 1, I2 + PL + C + B + E + A2, 1, I2 + SK + C + B + E + A2, 1, I2 + TV + C + B + E + A2, 1, I2 + Xz + C + B + E + A2, 1, I2 + TY + C + B + E + A2, 1, I2 + RG + C + B + E + A2, 1, I2 + Ro + C + B + E + A2, 1, I2 + RH + C + B + E + A2, 1, I2 + TW + C + B + E + A2, 1, I2 + TX + C + B + E + A2, 1, I2 + QE + C + B + E + A2, 1, I2 + Ns + C + B + E + A2, 1, I2 + Nt + C + B + E + A2, 1, I2 + Nu + C + B + E + A2, 1, I2 + Nw + C + B + E + A2, 1, I2 + NP + C + B + E + A2, 1, I2 + NQ + C + B + E + A2, 1, I2 + Ik + C + B + E + A2, 1, I2 + IC + C + B + E + A2, 1, I2 + Hi + C + B + E + A2, 1, D + " +lat_0=-21.11666666666667 +lon_0=55.53333333333333 +k=1 +x_0=160000" + Rz + R + SJ + E + A2, 1, H + OK + Fa + BY + ET + a + N + C + B + J + A2, 1, H + Fb + Fc + Ch + ET + a + N + C + B + J + A2, 1, D + CA + DJ + Ad + Gu + N + C + B + J + A2, 1, D + CA + DK + Ad + Au + Ao + C + B + J + A2, 1, D + CA + JB + Ad + a + N + C + B + J + A2, 1, D + CA + DL + Ad + An + Ao + C + B + J + A2, 1, H + OK + Fa + BY + ET + a + N + C + B + J + A2, 1, H + Fb + Fc + Ch + ET + a + N + C + B + J + A2, 1, D + CA + DJ + Ad + Gu + N + C + B + J + A2, 1, D + CA + DK + Ad + Au + Ao + C + B + J + A2, 1, D + CA + JB + Ad + a + N + C + B + J + A2, 1, D + CA + DL + Ad + An + Ao + C + B + J + A2, 1, I2 + QE + C + B + E + A2, 1, I2 + Ns + C + B + E + A2, 1, I2 + Nt + C + B + E + A2, 1, I2 + Nu + C + B + E + A2, 1, I2 + Nw + C + B + E + A2, 1, I2 + NP + C + B + E + A2, 1, I2 + NQ + C + B + E + A2, 1, I2 + Ik + C + B + E + A2, 1, I2 + IC + C + B + E + A2, 1, I2 + Hi + C + B + E + A2, 1, I2 + TY + C + B + E + A2, 1, I2 + RG + C + B + E + A2, 2, H + OK + Fa + BY + ET + a + N + C + B + J + A2, 1, H + Fb + Fc + Ch + ET + a + N + C + B + J + A2, 1, D + CA + DJ + Ad + Gu + N + C + B + J + A2, 1, D + CA + DK + Ad + Au + Ao + C + B + J + A2, 1, D + CA + JB + Ad + a + N + C + B + J + A2, 1, D + CA + DL + Ad + An + Ao + C + B + J + A2, 1, D + GV + KI + Jl + AG + N + C + B + J + A2, 1, D + GV + KI + Jl + AG + N + C + B + J + A2, 1, I2 + Io + C + B + E + A2, 1, H + " +lat_1=-54 +lat_2=-54.75 +lat_0=-55 +lon_0=-37" + s + N + S + E + A2, 1, D + " +lat_0=39.66825833333333 +lon_0=-8.133108333333334 +k=1" + s + N + C + B + E + A2, 1, D + Za + Si + " +k=1" + u + CO + C + B + E + A2, 1, D + L3 + YE + V2 + O2 + N + C + B + E + A2, 1, H + " +lat_1=45.91666666666666 +lat_2=43.08333333333334" + L3 + YE + s + N + C + B + E + A2, 1, I2 + KC + C + B + E + A2, 1, I2 + NR + C + B + E + A2, 1, I2 + Gz + i + TQ + E + A2, 1, D + " +lat_0=32 +lon_0=-64.75 +k=1 +x_0=550000" + EK + j + B + E + A2, 1, D + L3 + KK + V2 + s + N + X + E + A2, 1, D + L3 + Jb + V2 + s + N + X + E + A2, 1, D + L3 + Lj + V2 + s + N + X + E + A2, 2, D + L3 + KK + V2 + s + N + C + B + E + A2, 1, D + L3 + Jb + V2 + s + N + C + B + E + A2, 1, D + L3 + Lj + V2 + s + N + C + B + E + A2, 2, D + L3 + KK + V2 + s + N + C + B + E + A2, 1, D + L3 + Jb + V2 + s + N + C + B + E + A2, 1, D + L3 + Lj + V2 + s + N + C + B + E + A2, 2, D + " +lat_0=-25.06855261111111 +lon_0=-130.1129671111111 +k=1 +x_0=14200 +y_0=15500" + j + B + E + A2, 1, I2 + TX + o + R + Ta + E + A2, 4, D + L3 + ZW + " +k=1" + Bo + Ak + C + B + E + A2, 1, D + L3 + " +lon_0=169 +k=1" + Bo + Ak + C + B + E + A2, 1, D + L3 + " +lon_0=179 +k=1" + Bo + Ak + C + B + E + A2, 1, D + L3 + " +lon_0=-178 +k=1" + Bo + Ak + C + B + E + A2, 2, D + L3 + Si + " +k=1" + Bo + Ak + C + B + E + A2, 1, D + L3 + Gj + V2 + O2 + EO + C + B + E + A2, 1, H + " +lat_1=23 +lat_2=21.7 +lat_0=22.35" + CR + O2 + " +y_0=280296.016" + X + E + A2, 1, H + " +lat_1=21.3 +lat_2=20.13333333333333 +lat_0=20.71666666666667 +lon_0=-76.83333333333333" + O2 + " +y_0=229126.939" + X + E + A2, 1, H + Yv + Nh + IZ + " +lon_0=-70" + CX + N + X + E + A2, 1, H + Yv + Nh + IZ + " +lon_0=-70" + CX + N + C + B + E + A2, 1, H + Yv + Nh + IZ + " +lon_0=-70" + CX + N + C + B + E + A2, 1, D + L3 + Mt + V2 + s + N + X + E + A2, 1, D + L3 + Mt + V2 + s + N + C + B + E + A2, 1, D + L3 + Mt + V2 + s + N + C + B + E + A2, 10, H + Ks + Kt + " +lat_0=50.797815" + WH + " +x_0=649328 +y_0=665262" + C + B + E + A2, 2, D + Li + Sj + Tn + O2 + Pm + C + B + E + A2, 1, D + Li + Sj + Tn + O2 + Pm + C + B + E + A2, 1, D + Li + Sj + Tn + O2 + Pm + C + B + E + A2, 3, K + Y + " +towgs84=595.48,121.69,515.35,4.115,-2.9383,0.853,-3.408" + A2, 2, K + x + A2, 3, K + C + B + A2, 1, D + L3 + ZU + V2 + Bv + N + C + B + E + A2, 1, D + L3 + ZV + V2 + Bv + N + C + B + E + A2, 1, D + L3 + ZU + V2 + Bv + N + x + E + A2, 1, D + L3 + ZV + V2 + Bv + N + x + E + A2, 1, I2 + Mg + R + Rq + E + A2, 3, JU + Oe + " +k=1" + s + N + S + E + A2, 1, D + L3 + KB + " +k=1" + Ci + N + M + b + E + A2, 1, D + L3 + KB + " +k=1" + Ci + N + M + Ar + E + A2, 1, D + L3 + Gj + " +k=1" + Bo + N + M + Ar + E + A2, 1, D + L3 + Gl + " +k=1" + DP + N + M + Ar + E + A2, 1, D + L3 + KB + " +k=1" + Bo + N + M + b + E + A2, 1, D + L3 + IH + " +k=1" + DP + N + M + b + E + A2, 1, D + L3 + HO + " +k=1" + MT + N + M + b + E + A2, 1, D + L3 + Ia + " +k=1" + LY + N + M + b + E + A2, 1, D + L3 + QR + " +k=1" + Jt + N + M + Ar + E + A2, 3, GU + " +lat_0=46" + RJ + Rv + O2 + Ae + M + b + E + A2, 1, D + L3 + " +lon_0=11.30625 +k=1.000006 +x_0=1500025.141 +y_0=-667.282" + C + B + E + A2, 1, D + L3 + " +lon_0=13.55626666666667 +k=1.0000058 +x_0=1500044.695 +y_0=-667.13" + C + B + E + A2, 1, D + L3 + " +lon_0=15.80628452944445 +k=1.00000561024 +x_0=1500064.274 +y_0=-667.711" + C + B + E + A2, 1, D + L3 + " +lon_0=18.0563 +k=1.0000054 +x_0=1500083.521 +y_0=-668.8440000000001" + C + B + E + A2, 1, D + L3 + " +lon_0=20.30631666666667 +k=1.0000052 +x_0=1500102.765 +y_0=-670.706" + C + B + E + A2, 1, D + L3 + " +lon_0=22.55633333333333 +k=1.0000049 +x_0=1500121.846 +y_0=-672.557" + C + B + E + A2, 1, H + " +lat_1=-37.5 +lat_2=-44.5 +lat_0=-41 +lon_0=173" + aH + " +y_0=7000000" + C + B + E + A2, 1, H + Ai + Aj + m + " +lon_0=157" + O2 + N + C + B + E + A2, 2, D + L3 + " +lon_0=18.05787 +k=0.99999506 +x_0=100182.7406 +y_0=-6500620.1207" + C + B + E + A2, 3, JU + " +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0" + N + " +k=1.0" + E + " +nadgrids=@null +wktext " + A2, 16, D + L3 + RI + " +k=1" + Ht + N + C + B + E + A2, 1, D + L3 + UI + " +k=1" + HV + N + C + B + E + A2, 1, D + L3 + Gl + " +k=1" + Hw + N + C + B + E + A2, 1, D + L3 + Yx + " +k=1" + HW + N + C + B + E + A2, 1, D + L3 + SP + " +k=1" + Hx + N + C + B + E + A2, 1, D + L3 + II + " +k=1" + La + N + C + B + E + A2, 1, D + L3 + RJ + " +k=1" + Hy + N + C + B + E + A2, 1, D + L3 + UJ + " +k=1" + Hz + N + C + B + E + A2, 1, D + L3 + HO + " +k=1" + IA + N + C + B + E + A2, 1, D + L3 + RP + " +k=1" + IB + N + C + B + E + A2, 1, D + L3 + " +lon_0=29 +k=1" + Gx + N + C + B + E + A2, 1, D + L3 + Ia + " +k=1" + IT + N + C + B + E + A2, 1, D + L3 + QQ + " +k=1" + Gc + N + C + B + E + A2, 4, K + C + B + A2, 1, I2 + KD + C + B + E + A2, 1, I2 + JZ + C + B + E + A2, 1, I2 + JM + C + B + E + A2, 1, D + WJ + " +lon_0=46.5 +k=0.9994" + CX + N + R + n + E + A2, 13, K + Y + Aw + A2, 6, D + L3 + Gj + V2 + O2 + EO + Y + Aw + E + A2, 8, I2 + Gz + i + Je + E + A2, 22, H + " +lat_1=41.25 +lat_2=42.75" + PR + Or + Jv + Tj + C + B + E + A2, 1, H + " +lat_1=42.25 +lat_2=43.75" + Nj + Or + Jv + " +y_0=2200000" + C + B + E + A2, 1, H + " +lat_1=43.25 +lat_2=44.75" + IZ + Or + Jv + " +y_0=3200000" + C + B + E + A2, 1, H + " +lat_1=44.25 +lat_2=45.75" + IP + Or + Jv + " +y_0=4200000" + C + B + E + A2, 1, H + " +lat_1=45.25 +lat_2=46.75 +lat_0=46" + Or + Jv + " +y_0=5200000" + C + B + E + A2, 1, H + aI + " +lat_2=47.75" + Ib + Or + Jv + " +y_0=6200000" + C + B + E + A2, 1, H + " +lat_1=47.25 +lat_2=48.75 +lat_0=48" + Or + Jv + " +y_0=7200000" + C + B + E + A2, 1, H + " +lat_1=48.25 +lat_2=49.75 +lat_0=49" + Or + Jv + " +y_0=8200000" + C + B + E + A2, 1, H + " +lat_1=49.25 +lat_2=50.75" + Yu + Or + Jv + " +y_0=9200000" + C + B + E + A2, 18, H + " +lat_1=37" + YS + GM + Ga + s + N + C + B + E + A2, 1, H + " +lat_1=37" + YS + GM + Ga + s + N + C + B + E + A2, 1, H + " +lat_1=37" + YS + GM + Ga + s + N + C + B + E + A2, 6, BP + m + " +lat_ts=-70" + HN + " +k=1" + s + N + S + E + A2, 2, H + LM + IJ + " +lat_0=49 +lon_0=-95" + s + N + C + B + E + A2, 1, H + LM + IJ + " +lat_0=49 +lon_0=-95" + s + N + C + B + E + A2, 7, D + ZA + Ia + " +k=1" + h + Ae + i + CW + E + A2, 1, D + ZA + RP + " +k=1" + h + Ae + i + CW + E + A2, 1, D + ZA + UJ + " +k=1" + h + Ae + i + CW + E + A2, 1, D + ZA + II + " +k=1" + h + Ae + i + CW + E + A2, 2, H + GW + GX + GY + GA + e + N + i + Je + J + A2, 1, H + GW + GX + GY + GA + e + Pv + i + Je + J + A2, 2, JU + " +lon_0=100 +lat_ts=-41" + s + N + S + E + A2, 1, BP + Hr + " +lat_ts=71" + HN + " +k=1" + s + N + S + E + A2, 1, BP + Hr + " +lat_ts=75" + HN + " +k=1" + s + N + S + E + A2, 1, D + L3 + " +lon_0=55.33333333333334 +k=1" + O2 + N + S + E + A2, 4, K + PV + A2, 1, K + Ok + A2, 1, K + x + A2, 1, K + Y + A2, 1, K + Hn + EL + A2, 1, K + HB + A2, 1, K + Ee + Ef + A2, 1, K + i + A2, 2, K + Nc + Nd + A2, 1, K + AU + BN + A2, 1, K + c + A2, 1, K + Bc + BS + A2, 1, K + AU + " +b=6356514.996941779" + A2, 1, K + By + Ay + A2, 1, K + Lo + A2, 2, K + GL + Bz + A2, 1, K + C + A2, 1, K + Gn + A2, 1, K + IR + Bh + A2, 1, K + R + A2, 1, K + C + B + A2, 0, K + C + B + A2, 1, K + M + A2, 1, K + aJ + A2, 1, D + L3 + " +lon_0=28.4 +k=0.9999400000000001" + h + EO + C + B + E + A2, 1, K + " +a=6376523" + RA + A2, 1, K + Zx + Qy + A2, 1, K + Qj + Ho + A2, 1, K + j + A2, 1, K + j + A2, 1, K + " +a=6378136.2 +b=6356751.516927429" + A2, 1, K + " +a=6378136.3 +b=6356751.616592146" + A2, 1, K + RB + RC + A2, 2, K + aK + A2, 1, I2 + Ki + S + E + A2, 1, I2 + Mf + S + E + A2, 3, K + Pd + Gq + A2, 1, K + HK + Gv + A2, 1, K + T + A2, 1, K + Lp + Hp + A2, 1, K + Go + CT + A2, 1, K + C + B + A2, 1, K + " +a=6371007 +b=6371007" + A2, 1, D + L3 + IH + V2 + O2 + Ak + C + B + E + A2, 1, D + L3 + " +lon_0=14" + V2 + O2 + Ak + C + B + E + A2, 1, D + L3 + " +lon_0=16" + V2 + O2 + Ak + C + B + E + A2, 1, D + L3 + QR + V2 + O2 + Ak + C + B + E + A2, 1, K + " +a=6370997 +b=6370997" + A2, 1, K + ZX + ZY + A2, 1, K + ZZ + Ri + A2, 2, D + L3 + UI + V2 + O2 + Ak + C + B + E + A2, 1, D + L3 + Yx + V2 + O2 + Ak + C + B + E + A2, 1, D + L3 + II + V2 + O2 + Ak + C + B + E + A2, 1, D + L3 + UJ + V2 + O2 + Ak + C + B + E + A2, 1, D + L3 + RP + V2 + O2 + Ak + C + B + E + A2, 1, I2 + KC + o + C + B + E + A2, 1, I2 + NR + o + C + B + E + A2, 1, I2 + Ki + o + C + B + E + A2, 8, I2 + MB + o + R + TF + E + A2, 4, K + C + B + A2, 6, K + C + B + A2, 1, I2 + SL + C + B + E + A2, 1, I2 + Ja + C + B + E + A2, 4, "+proj=eqc +lat_ts=0" + L3 + HN + s + N + S + E + A2, 1, "+proj=eqc +lat_ts=0" + L3 + HN + s + N + " +a=6371007 +b=6371007" + E + A2, 5, D + L3 + KB + JE + h + EO + C + B + E + A2, 1, D + L3 + Lu + JE + u + EO + C + B + E + A2, 1, D + L3 + " +lon_0=11.75" + JE + a + EO + C + B + E + A2, 1, D + L3 + Gj + " +k=1" + CX + EO + C + B + E + A2, 24, K + Y + A2, 1, K + C + Qb + A2, 1, K + Pd + Gq + A2, 1, K + R + At + A2, 1, K + Y + BW + A2, 3, K + i + HF + A2, 1, K + i + A2, 1, K + i + A2, 1, K + j + KR + A2, 1, K + By + Ay + JP + A2, 1, K + c + QC + A2, 1, K + C + Lw + A2, 1, K + c + Gg + A2, 1, K + i + GB + A2, 1, K + i + A2, 1, K + i + A2, 1, K + i + A2, 1, K + i + Je + A2, 2, K + C + UC + A2, 1, K + c + JO + A2, 1, K + c + IE + A2, 1, K + By + Ay + JQ + A2, 1, K + Lp + Hp + GQ + A2, 1, K + Go + CT + BT + A2, 1, K + M + HG + A2, 1, K + j + B + A2, 1, K + Y + Gf + A2, 1, K + Y + Py + A2, 1, K + C + B + A2, 1, K + C + B + A2, 1, K + R + Pz + A2, 1, K + R + Gy + A2, 1, K + AU + BN + Nm + A2, 1, K + Y + Gh + A2, 1, K + Ee + Ef + A2, 1, K + R + QA + A2, 1, K + R + v + A2, 1, K + R + A2, 1, K + R + SD + A2, 1, K + Y + A2, 1, K + j + B + A2, 1, K + M + NK + A2, 1, K + R + TM + A2, 1, K + j + B + A2, 1, K + C + B + A2, 1, K + Qj + Ho + NI + A2, 1, K + i + TC + A2, 1, K + C + B + A2, 1, K + C + B + A2, 2, K + C + B + A2, 1, K + Qj + Ho + A2, 1, K + c + OW + A2, 1, K + C + B + A2, 2, K + M + Ar + A2, 1, K + M + b + A2, 1, K + C + B + A2, 1, K + R + Jx + A2, 1, K + R + Sw + A2, 1, K + R + Sx + A2, 1, K + R + TN + A2, 4, K + PV + Bb + A2, 1, K + C + B + A2, 1, K + C + B + A2, 1, K + M + A2, 1, K + R + Qe + A2, 1, K + AU + BN + RD + A2, 1, K + R + NG + A2, 1, K + R + " +towgs84=105,326,-102.5,0,0,0.814,-0.6" + A2, 1, K + R + " +towgs84=-45,417,-3.5,0,0,0.814,-0.6" + A2, 1, K + c + A2, 1, K + c + A2, 1, K + R + A2, 1, K + M + G + A2, 1, K + c + HX + A2, 1, K + x + r + A2, 1, K + x + CB + A2, 1, K + R + Cm + A2, 1, K + M + NL + A2, 1, K + AU + BN + A2, 1, K + R + EV + A2, 1, K + R + Ec + A2, 1, K + Bc + BS + In + A2, 1, K + c + ER + A2, 1, K + Y + Cj + A2, 1, K + c + Jw + A2, 1, K + AU + BN + Sy + A2, 1, K + M + U + A2, 1, K + R + A2, 1, K + i + TQ + A2, 1, D + L3 + Lf + AP + k + N + C + B + J + A2, 0, D + L3 + Lf + AP + k + N + C + B + J + A2, 1, K + R + ES + A2, 1, K + Y + " +towgs84=-384,664,-48,0,0,0,0" + A2, 1, K + c + GO + A2, 1, K + R + Bs + A2, 1, K + Bc + BS + Ax + A2, 1, K + AU + BN + Gi + A2, 1, K + R + TF + A2, 1, K + R + GR + A2, 2, K + AU + BN + HI + A2, 2, K + Gn + HY + A2, 1, K + R + n + A2, 1, K + R + " +towgs84=-83.11,-97.38,-117.22,0.00569291,-0.0446976,0.0442851,0.1218" + A2, 1, K + c + NM + A2, 4, K + R + Rq + A2, 1, K + aK + RE + A2, 1, K + IR + Bh + Av + A2, 1, K + By + Ay + JR + A2, 1, K + By + Ay + NN + A2, 1, K + RB + RC + A2, 1, K + i + TG + A2, 1, K + HK + Gv + A2, 1, K + By + Ay + Tb + A2, 1, K + GL + Bz + BV + A2, 1, K + c + Qh + A2, 1, K + R + Hc + A2, 1, K + R + AX + A2, 1, K + R + A2, 1, K + c + TR + A2, 1, K + c + " +towgs84=-90,40,88,0,0,0,0" + A2, 1, K + AU + BN + A2, 1, K + i + GC + A2, 1, K + R + OV + A2, 1, K + R + " +towgs84=-333,-222,114,0,0,0,0" + A2, 1, K + c + " +towgs84=41,-220,-134,0,0,0,0" + A2, 1, K + Y + HZ + A2, 1, K + C + B + A2, 1, K + R + Qd + A2, 2, K + AU + BN + IO + A2, 1, K + Y + Tc + A2, 1, K + c + GS + A2, 2, K + R + CK + A2, 1, K + AU + BN + NO + A2, 1, K + X + A2, 2, K + C + B + A2, 1, K + c + DO + A2, 1, K + R + TS + A2, 1, K + R + W + A2, 1, K + Hn + EL + Aa + A2, 1, K + R + JL + A2, 1, K + AU + BN + Bk + A2, 1, K + aJ + A2, 1, K + PV + Lx + A2, 1, K + PV + A2, 1, K + PV + A2, 1, K + Y + A2, 1, K + Nc + Nd + DS + A2, 1, K + AU + BN + TH + A2, 1, K + C + B + A2, 1, K + M + F + A2, 1, K + R + QO + A2, 1, K + Gn + A2, 2, K + R + A2, 1, K + Y + Fv + A2, 3, K + R + Nn + A2, 1, K + HB + Bt + A2, 2, K + Y + A2, 2, K + R + HD + A2, 1, K + Lo + GD + A2, 1, K + Ok + Bb + A2, 1, K + Ok + Bb + A2, 1, K + Y + g + A2, 1, K + Ee + Ef + JK + A2, 1, K + Gn + A2, 1, K + AU + BN + JC + A2, 2, K + Y + A2, 1, K + c + Af + A2, 1, K + Y + A2, 1, K + R + " +towgs84=-155,171,37,0,0,0,0" + A2, 1, K + AU + BN + A2, 1, K + R + HE + A2, 1, K + Y + z + A2, 1, K + R + GP + A2, 1, K + Y + AC + A2, 1, K + AU + BN + No + A2, 1, K + R + QP + A2, 2, K + j + MR + A2, 1, K + C + Rr + A2, 3, K + T + P + A2, 2, K + T + Q + A2, 2, K + S + A2, 64, Ck + " +lat_0=2.042583333333333 +lon_0=103.5627583333333" + s + N + GL + Bz + BV + E + A2, 1, Ck + " +lat_0=2.712283333333334 +lon_0=101.9411666666667 +x_0=-242.005 +y_0=-948.547" + GL + Bz + BV + E + A2, 1, Ck + " +lat_0=3.710972222222222 +lon_0=102.4361777777778" + s + N + GL + Bz + BV + E + A2, 1, Ck + " +lat_0=3.680344444444444 +lon_0=101.5082444444444 +x_0=-21759.438 +y_0=55960.906" + GL + Bz + BV + E + A2, 1, Ck + " +lat_0=4.946141666666667 +lon_0=102.8952083333333" + s + N + GL + Bz + BV + E + A2, 1, Ck + " +lat_0=5.421325 +lon_0=100.3458694444444" + s + N + GL + Bz + BV + E + A2, 1, Ck + " +lat_0=5.965147222222223 +lon_0=100.6375944444444" + s + N + GL + Bz + BV + E + A2, 1, Ck + " +lat_0=4.859380555555555 +lon_0=100.8167666666667" + s + " +y_0=133453.669" + GL + Bz + BV + E + A2, 1, Ck + " +lat_0=5.893922222222222 +lon_0=102.1772916666667" + s + N + GL + Bz + BV + E + A2, 1, D + L3 + Lf + AP + k + N + X + J + A2, 1, D + L3 + KG + AP + k + N + X + J + A2, 1, D + L3 + KH + AP + k + N + X + J + A2, 1, D + L3 + Lh + AP + k + N + X + J + A2, 1, D + L3 + SX + AP + k + N + X + J + A2, 1, D + L3 + " +lon_0=-159" + AP + k + N + X + J + A2, 0, D + L3 + " +lon_0=-159" + AP + k + N + X + J + A2, 1, D + L3 + YJ + AP + k + N + X + J + A2, 1, D + L3 + Qr + AP + k + N + X + J + A2, 1, D + L3 + " +lon_0=-141" + AP + k + N + X + J + A2, 1, D + L3 + YK + AP + k + N + X + J + A2, 1, D + L3 + YT + AP + k + N + X + J + A2, 1, D + L3 + " +lon_0=-123" + AP + k + N + X + J + A2, 1, D + L3 + Lj + AP + k + N + X + J + A2, 1, D + L3 + KK + AP + k + N + X + J + A2, 1, D + L3 + " +lon_0=-105" + AP + k + N + X + J + A2, 1, D + " +lat_0=13.5 +lon_0=144.75 +k=1" + BU + IK + C + B + E + A2, 1, H + " +lat_1=-6.5 +lat_2=-11.5" + ZA + UJ + O2 + Ae + i + CW + E + A2, 2, D + L3 + Gl + " +k=1" + IM + N + M + Ar + E + A2, 1, D + L3 + UR + AP + k + N + X + J + A2, 1, D + L3 + MP + AP + k + N + X + J + A2, 1, D + L3 + KG + AP + k + N + C + B + J + A2, 1, D + L3 + KH + AP + k + N + C + B + J + A2, 1, D + L3 + Lh + AP + k + N + C + B + J + A2, 1, D + L3 + SX + AP + k + N + C + B + J + A2, 1, D + L3 + " +lon_0=-159" + AP + k + N + C + B + J + A2, 1, D + L3 + YJ + AP + k + N + C + B + J + A2, 1, D + L3 + Qr + AP + k + N + C + B + J + A2, 1, D + L3 + " +lon_0=-141" + AP + k + N + C + B + J + A2, 1, D + L3 + YK + AP + k + N + C + B + J + A2, 1, D + L3 + YT + AP + k + N + C + B + J + A2, 1, D + L3 + " +lon_0=-123" + AP + k + N + C + B + J + A2, 1, D + L3 + Lj + AP + k + N + C + B + J + A2, 1, D + L3 + KK + AP + k + N + C + B + J + A2, 1, D + L3 + " +lon_0=-105" + AP + k + N + C + B + J + A2, 1, D + L3 + II + " +k=1" + MS + N + M + Ar + E + A2, 3, H + GW + GX + GY + GA + h + IK + C + B + E + A2, 1, D + L3 + UR + AP + k + N + C + B + J + A2, 1, D + L3 + MP + AP + k + N + C + B + J + A2, 16, H + Dp + Dq + y + Ea + Z2 + N + X + J + A2, 1, H + Dl + Dm + CA + Oc + Z2 + Pv + X + J + A2, 1, H + Fd + Fe + AL + CS + a + N + C + B + J + A2, 5, H + " +lat_1=-18" + ZT + " +lat_0=-27" + Il + s + N + S + E + A2, 1, K + C + B + A2, 4, I2 + ID + C + B + E + A2, 3, K + C + B + A2, 1, I2 + JZ + o + C + B + E + A2, 4, K + R + PJ + A2, 8, K + C + B + A2, 1, I2 + Ns + C + B + E + A2, 1, I2 + Nt + C + B + E + A2, 1, I2 + Nu + C + B + E + A2, 1, I2 + Nw + C + B + E + A2, 1, I2 + NP + C + B + E + A2, 1, I2 + NQ + C + B + E + A2, 1, K + C + A2, 1, D + L3 + HP + " +k=1" + HU + N + C + E + A2, 1, D + L3 + HQ + " +k=1" + Gw + N + C + E + A2, 1, D + L3 + Hd + " +k=1" + Hu + N + C + E + A2, 1, D + L3 + HR + " +k=1" + Hv + N + C + E + A2, 1, D + L3 + HS + " +k=1" + It + N + C + E + A2, 1, D + L3 + EN + " +k=1" + Hs + N + C + E + A2, 1, D + L3 + Fy + " +k=1" + Ht + N + C + E + A2, 1, D + L3 + Fm + " +k=1" + HV + N + C + E + A2, 1, D + L3 + Fr + " +k=1" + Hw + N + C + E + A2, 1, D + L3 + Ed + " +k=1" + HW + N + C + E + A2, 1, D + L3 + Fn + " +k=1" + Hx + N + C + E + A2, 1, D + L3 + HP + " +k=1" + O2 + N + C + E + A2, 1, D + L3 + HQ + " +k=1" + O2 + N + C + E + A2, 1, D + L3 + Hd + " +k=1" + O2 + N + C + E + A2, 1, D + L3 + HR + " +k=1" + O2 + N + C + E + A2, 1, D + L3 + HS + " +k=1" + O2 + N + C + E + A2, 1, D + L3 + EN + " +k=1" + O2 + N + C + E + A2, 1, D + L3 + Fy + " +k=1" + O2 + N + C + E + A2, 1, D + L3 + Fm + " +k=1" + O2 + N + C + E + A2, 1, D + L3 + Fr + " +k=1" + O2 + N + C + E + A2, 1, D + L3 + Ed + " +k=1" + O2 + N + C + E + A2, 1, D + L3 + Fn + " +k=1" + O2 + N + C + E + A2, 1, D + L3 + HP + " +k=1" + Hy + N + C + E + A2, 1, D + L3 + Lt + " +k=1" + Hz + N + C + E + A2, 1, D + L3 + HQ + " +k=1" + IA + N + C + E + A2, 1, D + L3 + Ni + " +k=1" + IB + N + C + E + A2, 1, D + L3 + Hd + " +k=1" + Gx + N + C + E + A2, 1, D + L3 + Hq + " +k=1" + IT + N + C + E + A2, 1, D + L3 + HR + " +k=1" + Gc + N + C + E + A2, 1, D + L3 + Mj + " +k=1" + IU + N + C + E + A2, 1, D + L3 + HS + " +k=1" + Iu + N + C + E + A2, 1, D + L3 + Jj + " +k=1" + Mu + N + C + E + A2, 1, D + L3 + EN + " +k=1" + Mv + N + C + E + A2, 1, D + L3 + Le + " +k=1" + Mw + N + C + E + A2, 1, D + L3 + Fy + " +k=1" + Mx + N + C + E + A2, 1, D + L3 + Im + " +k=1" + My + N + C + E + A2, 1, D + L3 + Fm + " +k=1" + Mz + N + C + E + A2, 1, D + L3 + KF + " +k=1" + NA + N + C + E + A2, 1, D + L3 + Fr + " +k=1" + NB + N + C + E + A2, 1, D + L3 + Jk + " +k=1" + Oh + N + C + E + A2, 1, D + L3 + Ed + " +k=1" + NC + N + C + E + A2, 1, D + L3 + Il + " +k=1" + Oi + N + C + E + A2, 1, D + L3 + Fn + " +k=1" + ND + N + C + E + A2, 1, D + L3 + HP + " +k=1" + O2 + N + C + E + A2, 1, D + L3 + Lt + " +k=1" + O2 + N + C + E + A2, 1, D + L3 + HQ + " +k=1" + O2 + N + C + E + A2, 1, D + L3 + Ni + " +k=1" + O2 + N + C + E + A2, 1, D + L3 + Hd + " +k=1" + O2 + N + C + E + A2, 1, D + L3 + Hq + " +k=1" + O2 + N + C + E + A2, 1, D + L3 + HR + " +k=1" + O2 + N + C + E + A2, 1, D + L3 + Mj + " +k=1" + O2 + N + C + E + A2, 1, D + L3 + HS + " +k=1" + O2 + N + C + E + A2, 1, D + L3 + Jj + " +k=1" + O2 + N + C + E + A2, 1, D + L3 + EN + " +k=1" + O2 + N + C + E + A2, 1, D + L3 + Le + " +k=1" + O2 + N + C + E + A2, 1, D + L3 + Fy + " +k=1" + O2 + N + C + E + A2, 1, D + L3 + Im + " +k=1" + O2 + N + C + E + A2, 1, D + L3 + Fm + " +k=1" + O2 + N + C + E + A2, 1, D + L3 + KF + " +k=1" + O2 + N + C + E + A2, 1, D + L3 + Fr + " +k=1" + O2 + N + C + E + A2, 1, D + L3 + Jk + " +k=1" + O2 + N + C + E + A2, 1, D + L3 + Ed + " +k=1" + O2 + N + C + E + A2, 1, D + L3 + Il + " +k=1" + O2 + N + C + E + A2, 1, D + L3 + Fn + " +k=1" + O2 + N + C + E + A2, 1, K + M + A2, 3, K + C + B + A2, 1, I2 + Gz + C + B + E + A2, 9, D + L3 + HP + " +k=1" + HU + N + M + E + A2, 1, D + L3 + HQ + " +k=1" + Gw + N + M + E + A2, 1, D + L3 + Hd + " +k=1" + Hu + N + M + E + A2, 1, D + L3 + HR + " +k=1" + Hv + N + M + E + A2, 1, D + L3 + HS + " +k=1" + It + N + M + E + A2, 1, D + L3 + EN + " +k=1" + Hs + N + M + E + A2, 1, D + L3 + Fy + " +k=1" + Ht + N + M + E + A2, 1, D + L3 + Fm + " +k=1" + HV + N + M + E + A2, 1, D + L3 + Fr + " +k=1" + Hw + N + M + E + A2, 1, D + L3 + Ed + " +k=1" + HW + N + M + E + A2, 1, D + L3 + Fn + " +k=1" + Hx + N + M + E + A2, 1, D + L3 + HP + " +k=1" + O2 + N + M + E + A2, 1, D + L3 + HQ + " +k=1" + O2 + N + M + E + A2, 1, D + L3 + Hd + " +k=1" + O2 + N + M + E + A2, 1, D + L3 + HR + " +k=1" + O2 + N + M + E + A2, 1, D + L3 + HS + " +k=1" + O2 + N + M + E + A2, 1, D + L3 + EN + " +k=1" + O2 + N + M + E + A2, 1, D + L3 + Fy + " +k=1" + O2 + N + M + E + A2, 1, D + L3 + Fm + " +k=1" + O2 + N + M + E + A2, 1, D + L3 + Fr + " +k=1" + O2 + N + M + E + A2, 1, D + L3 + Ed + " +k=1" + O2 + N + M + E + A2, 1, D + L3 + Fn + " +k=1" + O2 + N + M + E + A2, 11, K + c + A2, 1, K + c + TI + A2, 1, K + c + TJ + A2, 1, K + c + TK + A2, 1, K + c + TL + A2, 1, K + c + UB + A2, 1, K + c + Sv + A2, 1, K + c + Ps + A2, 1, K + i + A2, 1, K + i + A2, 1, K + As + d + A2, 1, K + R + Jg + A2, 1, K + C + B + A2, 1, K + Y + Hf + A2, 1, K + R + Jy + A2, 1, K + R + SE + A2, 1, K + R + Sz + A2, 1, K + C + B + A2, 1, K + x + Al + A2, 1, K + C + B + A2, 1, K + c + " +towgs84=-106,-129,165,0,0,0,0" + A2, 1, K + R + TA + A2, 1, K + R + SF + A2, 1, K + R + NH + A2, 1, K + C + B + A2, 1, K + R + TO + A2, 1, K + R + SJ + A2, 1, K + C + B + A2, 1, K + R + TP + A2, 1, K + R + Lr + A2, 1, K + R + UD + A2, 2, K + R + SG + A2, 1, K + R + QM + A2, 3, K + R + " +towgs84=365,194,166,0,0,0,0" + A2, 1, K + R + " +towgs84=325,154,172,0,0,0,0" + A2, 1, K + i + TZ + A2, 1, K + R + SH + A2, 2, K + R + Jf + A2, 1, K + R + TB + A2, 1, K + R + Ke + A2, 1, K + R + HH + A2, 2, K + R + SI + A2, 1, D + L3 + KB + AP + IU + N + C + B + E + A2, 5, D + L3 + HP + " +k=1" + Hy + N + M + E + A2, 1, D + L3 + Lt + " +k=1" + Hz + N + M + E + A2, 1, D + L3 + HQ + " +k=1" + IA + N + M + E + A2, 1, D + L3 + Ni + " +k=1" + IB + N + M + E + A2, 1, D + L3 + Hd + " +k=1" + Gx + N + M + E + A2, 1, K + " +a=6377019.27 +b=6355762.5391 +towgs84=-28,199,5,0,0,0,0" + A2, 1, K + R + Jd + A2, 1, K + C + B + A2, 1, K + R + Jz + A2, 1, K + C + B + A2, 1, K + R + Qc + A2, 1, K + R + PI + A2, 1, K + R + Pt + A2, 1, K + R + Pa + A2, 1, K + Y + Pb + A2, 1, K + j + B + A2, 1, K + R + " +towgs84=-86,-98,-119,0,0,0,0" + A2, 1, K + C + B + A2, 1, K + j + B + A2, 1, K + AU + BN + A2, 1, K + R + TT + A2, 1, K + R + Np + A2, 1, K + C + B + A2, 1, K + i + " +towgs84=-100,-248,259,0,0,0,0" + A2, 1, K + M + A2, 1, K + M + A2, 1, K + M + " +towgs84=44.585,-131.212,-39.544,0,0,0,0" + A2, 1, K + c + " +towgs84=-80.01,253.26,291.19,0,0,0,0" + A2, 1, K + c + " +towgs84=124.5,-63.5,-281,0,0,0,0" + A2, 2, K + By + Ay + RF + A2, 1, K + i + BX + A2, 1, K + R + " +towgs84=-133,-321,50,0,0,0,0" + A2, 2, K + C + B + A2, 1, K + C + Bm + A2, 1, K + R + Kc + A2, 1, K + R + Lq + A2, 1, K + R + Kg + A2, 1, K + R + Kh + A2, 1, K + R + QN + A2, 1, K + j + TD + A2, 1, K + j + B + A2, 1, K + i + CW + A2, 1, K + c + A2, 1, K + c + A2, 1, K + R + TE + A2, 1, K + c + Qf + A2, 1, K + c + A2, 1, K + c + GN + A2, 1, K + C + B + A2, 1, K + c + A2, 1, K + R + A2, 1, K + R + A2, 1, K + Gn + Qg + A2, 1, K + R + " +towgs84=114,-116,-333,0,0,0,0" + A2, 1, K + x + " +towgs84=-491,-22,435,0,0,0,0" + A2, 1, K + R + " +towgs84=145,75,-272,0,0,0,0" + A2, 1, K + R + " +towgs84=-320,550,-494,0,0,0,0" + A2, 1, K + R + " +towgs84=124,-234,-25,0,0,0,0" + A2, 1, K + R + " +towgs84=-205,107,53,0,0,0,0" + A2, 1, K + c + " +towgs84=-79,-129,145,0,0,0,0" + A2, 1, K + R + " +towgs84=-127,-769,472,0,0,0,0" + A2, 1, K + R + " +towgs84=-104,-129,239,0,0,0,0" + A2, 1, K + R + " +towgs84=298,-304,-375,0,0,0,0" + A2, 1, K + i + " +towgs84=-2,151,181,0,0,0,0" + A2, 1, K + R + " +towgs84=230,-199,-752,0,0,0,0" + A2, 1, K + R + " +towgs84=211,147,111,0,0,0,0" + A2, 1, K + T + P + A2, 1, K + R + JD + A2, 1, K + R + " +towgs84=-794,119,-298,0,0,0,0" + A2, 1, K + i + Lg + A2, 1, K + R + " +towgs84=208,-435,-229,0,0,0,0" + A2, 1, K + R + " +towgs84=189,-79,-202,0,0,0,0" + A2, 1, K + i + Ly + A2, 1, K + R + " +towgs84=403,-81,277,0,0,0,0" + A2, 1, K + R + " +towgs84=-307,-92,127,0,0,0,0" + A2, 1, K + R + Ta + A2, 1, K + R + " +towgs84=170,42,84,0,0,0,0" + A2, 2, K + " +a=6378270 +b=6356794.343434343 +towgs84=102,52,-38,0,0,0,0" + A2, 1, K + R + " +towgs84=276,-57,149,0,0,0,0" + A2, 1, K + R + " +towgs84=-632,438,-609,0,0,0,0" + A2, 1, K + R + " +towgs84=647,1777,-1124,0,0,0,0" + A2, 1, K + c + " +towgs84=260,12,-147,0,0,0,0" + A2, 1, K + C + B + A2, 1, K + Ee + Ef + A2, 1, K + R + " +towgs84=-156,-271,-189,0,0,0,0" + A2, 1, K + " +a=6378136 +b=6356751.361745712 +towgs84=0,0,1.5,-0,-0,0.076,0" + A2, 1, K + R + A2, 1, K + C + A2, 1, K + c + EU + A2, 1, K + c + A2, 1, K + Y + A2, 1, K + Y + A2, 1, K + C + B + A2, 1, K + UW + Ym + Nl + A2, 1, K + C + B + A2, 1, K + j + QB + A2, 1, K + Yn + Qz + A2, 1, K + UW + Ym + Nl + A2, 1, K + R + A2, 1, K + R + w + A2, 1, K + j + B + A2, 1, K + j + Fu + A2, 1, K + j + A2, 1, K + j + B + A2, 1, K + C + B + A2, 1, K + aJ + A2, 1, K + C + B + A2, 1, K + j + B + A2, 1, K + j + B + A2, 1, K + C + B + A2, 1, K + C + B + A2, 1, D + L3 + Hq + " +k=1" + IT + N + M + E + A2, 1, D + L3 + HR + " +k=1" + Gc + N + M + E + A2, 1, D + L3 + Mj + " +k=1" + IU + N + M + E + A2, 1, D + L3 + HS + " +k=1" + Iu + N + M + E + A2, 1, D + L3 + Jj + " +k=1" + Mu + N + M + E + A2, 1, D + L3 + EN + " +k=1" + Mv + N + M + E + A2, 1, D + L3 + Le + " +k=1" + Mw + N + M + E + A2, 1, D + L3 + Fy + " +k=1" + Mx + N + M + E + A2, 1, D + L3 + Im + " +k=1" + My + N + M + E + A2, 1, D + L3 + Fm + " +k=1" + Mz + N + M + E + A2, 1, D + L3 + KF + " +k=1" + NA + N + M + E + A2, 1, D + L3 + Fr + " +k=1" + NB + N + M + E + A2, 1, D + L3 + Jk + " +k=1" + Oh + N + M + E + A2, 1, D + L3 + Ed + " +k=1" + NC + N + M + E + A2, 1, D + L3 + Il + " +k=1" + Oi + N + M + E + A2, 1, D + L3 + Fn + " +k=1" + ND + N + M + E + A2, 1, D + L3 + HP + " +k=1" + O2 + N + M + E + A2, 1, D + L3 + Lt + " +k=1" + O2 + N + M + E + A2, 1, D + L3 + HQ + " +k=1" + O2 + N + M + E + A2, 1, D + L3 + Ni + " +k=1" + O2 + N + M + E + A2, 1, D + L3 + Hd + " +k=1" + O2 + N + M + E + A2, 1, D + L3 + Hq + " +k=1" + O2 + N + M + E + A2, 1, D + L3 + HR + " +k=1" + O2 + N + M + E + A2, 1, D + L3 + Mj + " +k=1" + O2 + N + M + E + A2, 1, D + L3 + HS + " +k=1" + O2 + N + M + E + A2, 1, D + L3 + Jj + " +k=1" + O2 + N + M + E + A2, 1, D + L3 + EN + " +k=1" + O2 + N + M + E + A2, 1, D + L3 + Le + " +k=1" + O2 + N + M + E + A2, 1, D + L3 + Fy + " +k=1" + O2 + N + M + E + A2, 1, D + L3 + Im + " +k=1" + O2 + N + M + E + A2, 1, D + L3 + Fm + " +k=1" + O2 + N + M + E + A2, 1, D + L3 + KF + " +k=1" + O2 + N + M + E + A2, 1, D + L3 + Fr + " +k=1" + O2 + N + M + E + A2, 1, D + L3 + Jk + " +k=1" + O2 + N + M + E + A2, 1, D + L3 + Ed + " +k=1" + O2 + N + M + E + A2, 1, K + Y + Gf + " +pm=bern" + A2, 1, K + R + ES + " +pm=bogota" + A2, 1, K + R + EV + Zb + A2, 1, K + Y + HZ + PW + A2, 1, K + Y + Aw + Ls + A2, 1, K + R + CK + " +pm=rome" + A2, 1, K + AU + BN + Bk + Lv + A2, 1, K + Y + PW + A2, 1, K + R + " +pm=brussels" + A2, 1, K + R + HD + Lv + A2, 1, K + AU + BN + JC + Lv + A2, 1, D + L3 + Il + " +k=1" + O2 + N + M + E + A2, 0, D + L3 + Il + " +k=1" + O2 + N + M + E + A2, 1, K + Y + Cj + PW + A2, 1, K + Y + " +pm=stockholm" + A2, 1, K + Y + " +pm=athens" + A2, 1, K + AU + BN + Gi + Lv + A2, 1, K + Hn + EL + Aa + SN + A2, 1, K + Y + Gh + Ls + A2, 2, K + Y + Hf + PW + A2, 1, K + AU + BN + Lv + A2, 1, D + L3 + Fn + " +k=1" + O2 + N + M + E + A2, 1, K + R + A2, 1, K + R + A2, 2, H + " +lat_1=15 +lat_2=16.66666666666667 +lat_0=15.83333333333333 +lon_0=-24 +x_0=161587.83 +y_0=128511.202" + S + E + A2, 13, H + WK + WL + UK + YH + s + N + C + B + E + A2, 62, K + " +a=6376523" + RA + ZM + A2, 2, K + Zx + Qy + " +pm=madrid" + A2, 1, K + Y + Pb + Zb + A2, 109, K + C + B + A2, 1, I2 + Nr + C + B + E + A2, 1, I2 + Os + C + B + E + A2, 1, I2 + Ja + C + B + E + A2, 2, D + BY + UZ + " +k=1" + s + N + R + EV + E + A2, 23, BP + Hr + Qm + HN + Rd + Bd + Cl + S + E + A2, 1, BP + m + " +lat_ts=-90" + HN + Rd + Bd + Cl + S + E + A2, 6, I2 + Ki + C + B + E + A2, 21, DT + Sa + Hl + ZB + OZ + s + N + X + E + A2, 1, DT + Sa + Hl + ZB + OZ + s + N + C + B + E + A2, 1, DT + Sa + Hl + ZB + OZ + s + N + C + B + E + A2, 1, DT + Sa + Hl + ZB + OZ + s + N + C + B + E + A2, 33, D + Fk + " +lon_0=5.5 +k=1" + BU + AH + C + B + E + A2, 1, D + Fk + " +lon_0=6.5 +k=1" + BU + AH + C + B + E + A2, 1, D + Fk + " +lon_0=7.5 +k=1" + BU + AH + C + B + E + A2, 1, D + Fk + " +lon_0=8.5 +k=1" + BU + AH + C + B + E + A2, 1, D + Fk + " +lon_0=9.5 +k=1" + BU + AH + C + B + E + A2, 1, D + Fk + YH + " +k=1" + BU + AH + C + B + E + A2, 1, D + Fk + " +lon_0=11.5 +k=1" + BU + AH + C + B + E + A2, 1, D + Fk + " +lon_0=12.5 +k=1" + BU + AH + C + B + E + A2, 1, D + Fk + " +lon_0=13.5 +k=1" + BU + AH + C + B + E + A2, 1, D + Fk + " +lon_0=14.5 +k=1" + BU + AH + C + B + E + A2, 1, D + Fk + " +lon_0=15.5 +k=1" + BU + AH + C + B + E + A2, 1, D + Fk + YE + " +k=1" + BU + AH + C + B + E + A2, 1, D + Fk + " +lon_0=17.5 +k=1" + BU + AH + C + B + E + A2, 1, D + Fk + " +lon_0=18.5 +k=1" + BU + AH + C + B + E + A2, 1, D + Fk + " +lon_0=19.5 +k=1" + BU + AH + C + B + E + A2, 1, D + Fk + " +lon_0=20.5 +k=1" + BU + AH + C + B + E + A2, 1, D + Fk + " +lon_0=21.5 +k=1" + BU + AH + C + B + E + A2, 1, D + Fk + " +lon_0=22.5 +k=1" + BU + AH + C + B + E + A2, 1, D + Fk + " +lon_0=23.5 +k=1" + BU + AH + C + B + E + A2, 1, D + Fk + " +lon_0=24.5 +k=1" + BU + AH + C + B + E + A2, 1, D + Fk + " +lon_0=25.5 +k=1" + BU + AH + C + B + E + A2, 1, D + Fk + " +lon_0=26.5 +k=1" + BU + AH + C + B + E + A2, 1, D + Fk + " +lon_0=27.5 +k=1" + BU + AH + C + B + E + A2, 1, D + Fk + " +lon_0=28.5 +k=1" + BU + AH + C + B + E + A2, 1, D + Fk + " +lon_0=29.5 +k=1" + BU + AH + C + B + E + A2, 1, D + Fk + " +lon_0=30.5 +k=1" + BU + AH + C + B + E + A2, 2, K + Y + A2, 35, D + Ch + NX + " +k=1" + h + Ae + Y + E + A2, 1, D + Ch + Rt + " +k=1" + h + " +y_0=550000" + Y + E + A2, 1, D + Ch + Ru + " +k=1" + h + Ae + Y + E + A2, 1, D + Ch + Rt + " +k=1" + h + Ae + Y + E + A2, 1, D + Ch + Ed + " +k=1" + h + Ae + Y + E + A2, 1, D + Ch + NX + " +k=1" + h + Ae + Y + E + A2, 1, D + Ch + " +lon_0=125.0028902777778 +k=1" + h + Ae + Y + E + A2, 1, D + Ch + WM + " +k=1" + h + Ae + Y + E + A2, 1, D + Ch + WM + " +k=1" + h + " +y_0=550000" + Y + E + A2, 1, D + Ch + " +lon_0=129.0028902777778 +k=1" + h + Ae + Y + E + A2, 1, D + Ch + " +lon_0=131.0028902777778 +k=1" + h + Ae + Y + E + A2, 1, D + Ch + Pj + AP + BZ + Cl + Y + E + A2, 1, D + Ch + Pj + AP + BZ + Cl + C + B + E + A2, 1, D + Ch + Ru + " +k=1" + h + Ae + C + B + E + A2, 1, D + Ch + Rt + " +k=1" + h + Ae + C + B + E + A2, 1, D + Ch + Rt + " +k=1" + h + " +y_0=550000" + C + B + E + A2, 1, D + Ch + Ed + " +k=1" + h + Ae + C + B + E + A2, 1, D + Ch + NX + " +k=1" + h + Ae + C + B + E + A2, 1, D + Ch + Ru + " +k=1" + h + Qn + C + B + E + A2, 1, D + Ch + Rt + " +k=1" + h + Qn + C + B + E + A2, 1, D + Ch + Ed + " +k=1" + h + Qn + C + B + E + A2, 1, D + Ch + NX + " +k=1" + h + Qn + C + B + E + A2, 33, Rp + SS + " +lon_0=42.5" + Kk + V2 + s + N + Y + Gh + Ls + E + A2, 2, D + L3 + IH + AP + O2 + Ae + S + E + A2, 5, K + Y + Lz + A2, 1, K + Y + Lz + Ls + A2, 4, K + By + Ay + Kf + A2, 1, D + " +lat_0=7.000480277777778 +lon_0=80.77171111111112 +k=0.9999238418" + h + IK + By + Ay + Tb + E + A2, 1, D + " +lat_0=7.000471527777778 +lon_0=80.77171308333334 +k=0.9999238418" + O2 + Ae + By + Ay + Kf + E + A2, 8, H + WK + WL + UK + YH + s + N + C + B + E + A2, 3, K + C + A2, 1, CU + Qi + Yz + aU + Ph + s + N + KE + If + C + E + A2, 5, K + C + B + A2, 1, D + L3 + HO + " +k=1" + O2 + N + C + B + E + A2, 1, D + L3 + Ia + " +k=1" + O2 + N + C + B + E + A2, 1, D + L3 + IG + " +k=1" + O2 + N + C + B + E + A2, 1, D + L3 + PN + " +k=1" + O2 + N + C + B + E + A2, 1, D + L3 + LN + " +k=1" + O2 + N + C + B + E + A2, 1, D + L3 + PO + " +k=1" + O2 + N + C + B + E + A2, 1, D + L3 + JS + " +k=1" + O2 + N + C + B + E + A2, 5, K + C + B + A2, 2, D + L3 + Hq + " +k=1" + Bv + N + C + B + E + A2, 3, D + L3 + HO + " +k=1" + MT + N + C + B + E + A2, 1, D + L3 + Ia + " +k=1" + LY + N + C + B + E + A2, 1, D + L3 + IG + " +k=1" + Jp + N + C + B + E + A2, 1, D + L3 + PN + " +k=1" + LZ + N + C + B + E + A2, 1, D + L3 + LN + " +k=1" + HU + N + C + B + E + A2, 1, D + L3 + PO + " +k=1" + Gw + N + C + B + E + A2, 1, D + L3 + JS + " +k=1" + Hu + N + C + B + E + A2, 17, D + L3 + " +lon_0=90.73333333333333 +k=1" + Bv + DU + C + B + E + A2, 1, D + L3 + " +lon_0=89.55 +k=1" + Bv + DU + C + B + E + A2, 1, D + L3 + WN + " +k=1" + Bv + DU + C + B + E + A2, 1, D + L3 + " +lon_0=90.03333333333333 +k=1" + Bv + DU + C + B + E + A2, 1, D + L3 + " +lon_0=90.15000000000001 +k=1" + Bv + DU + C + B + E + A2, 1, D + L3 + " +lon_0=91.13333333333334 +k=1" + Bv + DU + C + B + E + A2, 1, D + L3 + " +lon_0=91.23333333333333 +k=1" + Bv + DU + C + B + E + A2, 1, D + L3 + " +lon_0=89.34999999999999 +k=1" + Bv + DU + C + B + E + A2, 1, D + L3 + " +lon_0=91.34999999999999 +k=1" + Bv + DU + C + B + E + A2, 1, D + L3 + WN + " +k=1" + Bv + DU + C + B + E + A2, 1, D + L3 + WO + " +k=1" + Bv + DU + C + B + E + A2, 1, D + L3 + " +lon_0=89.06666666666666 +k=1" + Bv + DU + C + B + E + A2, 1, D + L3 + " +lon_0=90.26666666666667 +k=1" + Bv + DU + C + B + E + A2, 1, D + L3 + " +lon_0=89.55 +k=1" + Bv + DU + C + B + E + A2, 1, D + L3 + " +lon_0=91.75 +k=1" + Bv + DU + C + B + E + A2, 1, D + L3 + " +lon_0=90.5 +k=1" + Bv + DU + C + B + E + A2, 1, D + L3 + " +lon_0=90.16666666666667 +k=1" + Bv + DU + C + B + E + A2, 1, D + L3 + " +lon_0=90.11666666666666 +k=1" + Bv + DU + C + B + E + A2, 1, D + L3 + WO + " +k=1" + Bv + DU + C + B + E + A2, 1, D + L3 + " +lon_0=90.86666666666666 +k=1" + Bv + DU + C + B + E + A2, 5, D + L3 + " +lon_0=-7 +k=0.999997" + h + " +y_0=-6000000" + C + B + E + A2, 4, H + YI + " +lat_2=54.5" + L3 + NV + BZ + N + C + B + E + A2, 1, H + YI + " +lat_2=54.5" + L3 + NV + BZ + N + C + B + E + A2, 3, K + C + B + A2, 1, H + " +lat_1=64.25 +lat_2=65.75 +lat_0=65 +lon_0=-19" + Jv + Hk + C + B + E + A2, 4, JU + PC + ZP + Pl + Qp + Y + Hf + PW + E + A2, 1, JU + PC + ZP + Pl + Qp + Y + Cj + PW + E + A2, 1, JU + PC + ZP + Pl + Qp + Y + HZ + PW + E + A2, 6, I2 + Nr + o + R + Ec + E + A2, 3, K + C + B + A2, 3, D + m + UQ + " +k=1" + AV + N + C + B + E + A2, 1, D + m + MP + " +k=1" + Ci + N + C + B + E + A2, 1, D + m + Pe + " +k=1" + Bo + N + C + B + E + A2, 1, D + m + Qk + " +k=1" + DP + N + C + B + E + A2, 1, D + m + US + " +k=1" + Eg + N + C + B + E + A2, 1, D + m + Zc + " +k=1" + Jt + N + C + B + E + A2, 1, D + m + Nb + " +k=1" + IM + N + C + B + E + A2, 5, K + C + B + A2, 1, I2 + Gz + o + C + B + E + A2, 1, I2 + Hi + o + C + B + E + A2, 1, I2 + ID + o + C + B + E + A2, 3, K + C + B + A2, 1, I2 + Hi + o + C + B + E + A2, 1, I2 + IC + o + C + B + E + A2, 3, K + j + B + A2, 2, D + L3 + NV + V2 + O2 + N + j + B + E + A2, 4, K + C + B + A2, 2, K + C + B + A2, 8, K + j + B + A2, 1, I2 + ID + o + j + B + E + A2, 1, I2 + Io + o + j + B + E + A2, 4, I2 + IC + o + C + B + E + A2, 2, I2 + Hi + o + C + B + E + A2, 4, K + C + B + A2, 3, I2 + Os + o + C + B + E + A2, 55, K + i + Bp + A2, 5, H + " +lat_1=10.46666666666667 +lat_0=10.46666666666667 +lon_0=-84.33333333333333 +k_0=0.99995696" + O2 + " +y_0=271820.522" + i + Bp + E + A2, 1, H + " +lat_1=9 +lat_0=9" + Ua + " +k_0=0.99995696" + O2 + " +y_0=327987.436" + i + Bp + E + A2, 2, H + " +lat_1=14.9 +lat_0=14.9" + Bx + " +k_0=0.99989906" + O2 + " +y_0=325992.681" + i + Bp + E + A2, 1, H + " +lat_1=13.78333333333333 +lat_0=13.78333333333333 +lon_0=-89 +k_0=0.99996704" + O2 + " +y_0=295809.184" + i + Bp + E + A2, 1, H + " +lat_1=13.86666666666667 +lat_0=13.86666666666667" + To + " +k_0=0.99990314" + O2 + " +y_0=359891.816" + i + Bp + E + A2, 1, H + " +lat_1=11.73333333333333 +lat_0=11.73333333333333" + To + " +k_0=0.9999222800000001" + O2 + " +y_0=288876.327" + i + Bp + E + A2, 1, I2 + Ik + x + Al + E + A2, 1, K + Ee + Ef + A2, 3, K + i + A2, 2, H + " +lat_1=8.416666666666666 +lat_0=8.416666666666666 +lon_0=-80 +k_0=0.99989909" + O2 + " +y_0=294865.303" + i + E + A2, 3, UU + " +lat_0=8.25" + CR + " +x_0=914391.7962 +y_0=999404.7217154861" + i + " +to_meter=0.9143917962" + A2, 7, H + Ai + Aj + " +lat_0=-78 +lon_0=163" + Tp + Ju + C + B + E + A2, 1, H + " +lat_1=-73.66666666666667" + AZ + " +lat_0=-74.5" + NZ + LX + Fq + C + B + E + A2, 1, H + " +lat_1=-70.66666666666667 +lat_2=-72.33333333333333 +lat_0=-71.5" + ZW + aH + AH + C + B + E + A2, 1, BP + m + " +lat_ts=-90" + Ry + Rd + LX + AH + C + B + E + A2, 7, K + C + B + A2, 1, I2 + Gz + C + B + E + A2, 23, Rp + SS + WP + Kk + V2 + s + N + Y + Gh + E + A2, 1, Rp + SS + WP + Kk + V2 + s + N + Y + Gh + E + A2, 4, D + Za + Si + " +k=1" + Qo + " +y_0=650000" + R + TT + E + A2, 1, D + Za + Si + " +k=1" + Qo + " +y_0=650000" + R + Np + E + A2, 1, D + L3 + Or + " +k=1" + AV + N + Y + AC + E + A2, 3, D + L3 + " +lon_0=11.5" + AP + AV + EM + S + E + A2, 1, K + R + A2, 3, K + x + BK + A2, 3, UU + L3 + Nb + LX + Ak + x + BK + E + A2, 1, I2 + ID + o + x + BK + E + A2, 2, I2 + MB + o + x + BK + E + A2, 1, I2 + Nx + o + x + BK + E + A2, 1, I2 + Nr + o + x + BK + E + A2, 1, I2 + ID + o + R + E + A2, 1, I2 + Io + o + R + E + A2, 1, I2 + MB + o + R + E + A2, 1, I2 + Nx + o + R + E + A2, 7, K + C + B + A2, 4, I2 + Nv + o + C + B + E + A2, 1, I2 + PM + o + C + B + E + A2, 1, I2 + Re + o + C + B + E + A2, 7, H + " +lat_1=16.81666666666667 +lat_0=16.81666666666667" + Bx + " +k_0=0.99992226" + O2 + " +y_0=292209.579" + i + Bp + E + A2, 2, K + M + BO + A2, 1, D + L3 + Gl + " +k=1" + DP + N + M + BO + E + A2, 1, D + L3 + HO + " +k=1" + Eg + N + M + BO + E + A2, 1, D + L3 + IG + " +k=1" + Jt + N + M + BO + E + A2, 1, D + L3 + LN + " +k=1" + IM + N + M + BO + E + A2, 1, D + L3 + Gl + " +k=1" + O2 + N + M + BO + E + A2, 1, D + L3 + HO + " +k=1" + O2 + N + M + BO + E + A2, 1, D + L3 + IG + " +k=1" + O2 + N + M + BO + E + A2, 1, D + L3 + LN + " +k=1" + O2 + N + M + BO + E + A2, 19, GU + Iq + Zy + ST + Ab + " +y_0=304800" + X + t + A2, 1, D + " +lat_0=17.06124194444444 +lon_0=-88.6318575 +k=1 +x_0=66220.02833082761 +y_0=135779.5099885299" + Ee + Ef + ML + A2, 4, K + C + B + A2, 3, D + L3 + " +lon_0=11.33333333333333 +k=1" + BZ + N + C + B + E + A2, 27, D + Fo + Ua + " +k=0.999942857" + e + N + X + J + A2, 1, D + Fo + EY + Hm + e + N + X + J + A2, 1, D + Fo + " +lon_0=-88.75" + Hm + e + N + X + J + A2, 2, D + L3 + ZO + AP + O2 + N + R + n + E + A2, 2, I2 + JZ + o + j + KR + E + A2, 2, D + L3 + KB + " +k=1" + Ci + N + M + b + E + A2, 1, H + Yw + QY + PU + Lu + LU + RU + C + B + E + A2, 1, He + PU + Lu + RV + RW + C + B + E + A2, 1, H + Yw + QY + PU + Lu + LU + RU + C + B + E + A2, 1, He + PU + Lu + RV + RW + C + B + E + A2, 1, He + PU + Lu + RV + RW + C + B + E + A2, 1, H + Yw + QY + PU + Lu + LU + RU + C + B + E + A2, 1, He + PU + Lu + RV + RW + C + B + E + A2, 1, H + Yw + QY + PU + Lu + LU + RU + C + B + E + A2, 2, JU + " +lon_0=-43 +lat_ts=-2" + LX + Ak + C + B + E + A2, 2, H + " +lat_1=52.66666666666666 +lat_2=54.33333333333334 +lat_0=48" + Lu + " +x_0=815000" + N + R + n + E + A2, 1, I2 + JM + o + C + B + E + A2, 2, D + Fp + LW + JA + AG + N + C + B + J + A2, 3, D + L3 + Or + AP + Gc + N + C + B + E + A2, 1, D + L3 + Gj + AP + Iu + N + C + B + E + A2, 1, D + L3 + Or + AP + Gc + N + C + B + E + A2, 1, D + L3 + KB + AP + IU + N + C + B + E + A2, 1, D + L3 + Gj + AP + Iu + N + C + B + E + A2, 1, D + Fp + LW + JA + AG + N + C + B + J + A2, 1, D + Fp + LW + JA + AG + N + C + B + J + A2, 4, D + L3 + KB + AP + " +x_0=500053 +y_0=-3999820" + R + CK + E + A2, 4, D + L3 + Gj + " +k=1" + Bo + N + M + b + E + A2, 1, D + L3 + KB + " +k=1" + Ci + N + M + Ar + E + A2, 1, D + L3 + Gj + " +k=1" + Bo + N + M + Ar + E + A2, 1, D + L3 + KB + " +k=1" + Bo + N + Y + E + A2, 1, D + L3 + IH + " +k=1" + DP + N + Y + E + A2, 1, D + L3 + IH + " +k=1" + DP + N + Y + E + A2, 1, D + L3 + Gj + " +k=1" + Eg + N + Y + E + A2, 1, D + L3 + KB + " +k=1" + Bo + N + M + b + E + A2, 1, D + L3 + IH + " +k=1" + DP + N + M + b + E + A2, 1, D + L3 + Gj + " +k=1" + Eg + N + M + b + E + A2, 1, D + L3 + KB + " +k=1" + Bo + N + M + Ar + E + A2, 1, D + L3 + IH + " +k=1" + DP + N + M + Ar + E + A2, 1, D + L3 + Gj + " +k=1" + Eg + N + M + Ar + E + A2, 1, D + L3 + ZO + " +k=1" + Ci + N + Y + AC + E + A2, 1, D + L3 + KB + " +k=1" + Bo + N + Y + AC + E + A2, 1, D + L3 + IH + " +k=1" + DP + N + Y + AC + E + A2, 1, D + L3 + Gj + " +k=1" + Eg + N + Y + AC + E + A2, 1, D + L3 + Or + " +k=1" + AV + N + Y + AC + E + A2, 1, K + Y + A2, 1, D + L3 + ZO + " +k=1" + Ci + N + Y + E + A2, 1, D + L3 + KB + " +k=1" + Bo + N + Y + E + A2, 1, D + L3 + IH + " +k=1" + DP + N + Y + E + A2, 1, D + L3 + Gj + " +k=1" + Eg + N + Y + E + A2, 15, I2 + SK + o + C + B + E + A2, 125, D + " +lat_0=-35.31773627777778 +lon_0=149.0092948305555 +k=1.000086" + h + Qn + x + r + E + A2, 11, I2 + KD + j + B + E + A2, 1, I2 + Me + j + B + E + A2, 2, I2 + Ik + o + C + B + E + A2, 3, D + L3 + IH + AP + O2 + Ak + S + E + A2, 2, D + L3 + Ia + V2 + O2 + Ak + C + B + E + A2, 14, I2 + Io + o + x + BK + E + A2, 17, I2 + IC + o + x + BK + E + A2, 1, I2 + Hi + o + x + BK + E + A2, 1, I2 + Gz + o + x + BK + E + A2, 2, I2 + JZ + o + R + PJ + E + A2, 1, UU + L3 + Nb + LX + Ak + C + B + E + A2, 6, K + C + A2, 1, D + L3 + KH + AP + AV + Ju + C + E + A2, 3, BP + Hr + " +lat_ts=70" + Hq + " +k=1" + s + N + ZZ + Ri + E + A2, 31, H + ZC + IJ + Ih + KK + s + N + S + E + A2, 1, H + ZC + IJ + Ih + UT + s + N + S + E + A2, 1, H + ZC + IJ + Ih + IG + s + N + S + E + A2, 1, H + ZC + IJ + Ih + EN + s + N + S + E + A2, 1, H + ZC + IJ + Ih + KG + s + N + S + E + A2, 1, H + Ic + ZD + Ii + KK + s + N + S + E + A2, 1, H + Ic + ZD + Ii + UT + s + N + S + E + A2, 1, H + Ic + ZD + Ii + IG + s + N + S + E + A2, 1, H + Ic + ZD + Ii + EN + s + N + S + E + A2, 1, H + Ic + ZD + Ii + KG + s + N + S + E + A2, 1, H + ZE + ZF + Ij + KK + s + N + S + E + A2, 1, H + ZE + ZF + Ij + UT + s + N + S + E + A2, 1, H + ZE + ZF + Ij + IG + s + N + S + E + A2, 1, H + ZE + ZF + Ij + EN + s + N + S + E + A2, 1, H + ZE + ZF + Ij + KG + s + N + S + E + A2, 1, BP + Hr + Qm + ON + Rd + Bd + Cl + S + E + A2, 1, BP + Hr + Qm + CS + Rd + Bd + Cl + S + E + A2, 1, BP + Hr + Qm + " +lon_0=-33" + Rd + Bd + Cl + S + E + A2, 1, BP + Hr + Qm + QR + Rd + Bd + Cl + S + E + A2, 1, BP + Hr + Qm + EN + Rd + Bd + Cl + S + E + A2, 110, H + UL + Ha + Hb + " +lon_0=-30" + Hy + DQ + C + B + E + A2, 1, H + Ce + Cf + Cg + " +lon_0=-52" + Hs + JH + C + B + E + A2, 1, H + Ce + Cf + Cg + " +lon_0=-12" + HV + JH + C + B + E + A2, 1, H + Bf + IJ + Bg + MP + Gx + IN + C + B + E + A2, 1, H + Bf + IJ + Bg + UT + Gc + IN + C + B + E + A2, 1, H + Bf + IJ + Bg + " +lon_0=-10" + Iu + IN + C + B + E + A2, 1, H + Ic + BL + BM + " +lon_0=-64" + HV + Gb + C + B + E + A2, 1, H + Ic + BL + BM + UT + HW + Gb + C + B + E + A2, 1, H + Ic + BL + BM + " +lon_0=-14" + La + Gb + C + B + E + A2, 1, H + AR + AS + AT + NU + NB + EM + C + B + E + A2, 1, H + AR + AS + AT + " +lon_0=-42" + NC + EM + C + B + E + A2, 1, H + AR + AS + AT + " +lon_0=-22" + ND + EM + C + B + E + A2, 1, H + CI + OY + CJ + Zd + Hz + JI + C + B + E + A2, 1, H + CI + OY + CJ + " +lon_0=-38" + IB + JI + C + B + E + A2, 1, H + CI + OY + CJ + " +lon_0=-20" + IT + JI + C + B + E + A2, 1, H + " +lat_1=67" + WQ + WR + " +lon_0=-51" + Jp + aE + C + B + E + A2, 1, H + " +lat_1=67" + WQ + WR + " +lon_0=-34" + HU + aE + C + B + E + A2, 1, H + WS + WT + WU + " +lon_0=-52" + HV + " +y_0=8500000" + C + B + E + A2, 1, H + WS + WT + WU + " +lon_0=-37" + HW + " +y_0=8500000" + C + B + E + A2, 1, H + Ce + Cf + Cg + " +lon_0=16" + HW + JH + C + B + E + A2, 1, H + Bf + IJ + Bg + Gl + Jp + IN + C + B + E + A2, 1, H + Ic + BL + BM + Lu + Hz + Gb + C + B + E + A2, 1, H + Ic + BL + BM + ZG + IB + Gb + C + B + E + A2, 1, H + AR + AS + AT + " +lon_0=14" + Jp + EM + C + B + E + A2, 1, H + AR + AS + AT + ZG + HU + EM + C + B + E + A2, 1, H + Ce + Cf + Cg + " +lon_0=53" + La + JH + S + E + A2, 1, H + Ce + Cf + Cg + HR + Hz + JH + S + E + A2, 1, H + Bf + IJ + Bg + " +lon_0=52" + HU + IN + S + E + A2, 1, H + Bf + IJ + Bg + " +lon_0=83" + Hu + IN + S + E + A2, 1, H + Bf + IJ + Bg + Im + It + IN + S + E + A2, 1, H + Bf + IJ + Bg + " +lon_0=145" + Ht + IN + S + E + A2, 1, H + Ic + BL + BM + " +lon_0=58" + IT + Gb + S + E + A2, 1, H + Ic + BL + BM + " +lon_0=82" + IU + Gb + S + E + A2, 1, H + Ic + BL + BM + ZQ + Mu + Gb + S + E + A2, 1, H + Ic + BL + BM + " +lon_0=130" + Mw + Gb + S + E + A2, 1, H + Ic + BL + BM + ZR + My + Gb + S + E + A2, 1, H + Ic + BL + BM + " +lon_0=179" + NA + Gb + S + E + A2, 1, H + AR + AS + AT + SR + Hu + EM + S + E + A2, 1, H + AR + AS + AT + " +lon_0=74" + It + EM + S + E + A2, 1, H + AR + AS + AT + " +lon_0=95" + Ht + EM + S + E + A2, 1, H + AR + AS + AT + " +lon_0=116" + Hw + EM + S + E + A2, 1, H + AR + AS + AT + " +lon_0=137" + Hx + EM + S + E + A2, 1, H + AR + AS + AT + " +lon_0=158" + Hy + EM + S + E + A2, 1, H + AR + AS + AT + " +lon_0=179" + IA + EM + S + E + A2, 1, H + AR + AS + AT + " +lon_0=-163" + Gx + EM + C + B + E + A2, 1, H + AR + AS + AT + Qr + Gc + EM + C + B + E + A2, 1, H + CI + OY + CJ + SX + Gw + JI + C + B + E + A2, 1, H + CI + OY + CJ + Qr + Hv + JI + C + B + E + A2, 1, H + UL + Ha + Hb + Bu + Hx + DQ + C + B + E + A2, 1, H + Ce + Cf + Cg + SZ + Gw + JH + C + B + E + A2, 1, H + Ce + Cf + Cg + UR + Hv + JH + C + B + E + A2, 1, H + Bf + IJ + Bg + YT + Hy + IN + C + B + E + A2, 1, H + Bf + IJ + Bg + Ji + IA + IN + C + B + E + A2, 1, H + Bf + IJ + Bg + MP + Gx + IN + C + B + E + A2, 1, H + Ic + BL + BM + YT + Gw + Gb + C + B + E + A2, 1, H + Ic + BL + BM + " +lon_0=-104" + Hv + Gb + C + B + E + A2, 1, H + Ic + BL + BM + NW + Hs + Gb + C + B + E + A2, 1, H + AR + AS + AT + " +lon_0=-131" + Iu + EM + C + B + E + A2, 1, H + AR + AS + AT + KK + Mv + EM + C + B + E + A2, 1, H + AR + AS + AT + " +lon_0=-91" + Mx + EM + C + B + E + A2, 1, H + AR + AS + AT + " +lon_0=-71" + Mz + EM + C + B + E + A2, 1, H + CI + OY + CJ + " +lon_0=-132" + Hs + JI + C + B + E + A2, 1, H + CI + OY + CJ + " +lon_0=-113" + HV + JI + C + B + E + A2, 1, H + CI + OY + CJ + Na + HW + JI + C + B + E + A2, 1, H + CI + OY + CJ + UR + La + JI + C + B + E + A2, 1, H + UL + Ha + Hb + Ia + IA + DQ + S + E + A2, 1, H + UL + Ha + Hb + Hq + Gx + DQ + S + E + A2, 1, H + UL + Ha + Hb + Oe + Gc + DQ + S + E + A2, 1, H + UL + Ha + Hb + ON + Hw + DQ + S + E + A2, 1, H + Ce + Cf + Cg + " +lon_0=133" + IB + JH + S + E + A2, 1, H + Ce + Cf + Cg + ZW + LY + JH + S + E + A2, 1, H + Ce + Cf + Cg + Ms + LZ + JH + S + E + A2, 1, H + Bf + IJ + Bg + " +lon_0=176" + Hw + IN + S + E + A2, 1, H + Bf + IJ + Bg + YJ + Hx + IN + S + E + A2, 1, H + Ic + BL + BM + " +lon_0=-155" + LZ + Gb + S + E + A2, 1, H + AR + AS + AT + " +lon_0=-5" + ZK + EM + C + B + E + A2, 3, I2 + Ik + i + Lg + t + A2, 1, I2 + Ik + i + Ly + t + A2, 6, K + C + B + A2, 69, D + L3 + Gl + V2 + O2 + N + Y + Aw + E + A2, 3, K + By + Ay + " +towgs84=293.17,726.18,245.36,0,0,0,0" + A2, 3, I2 + MB + C + B + E + A2, 1, I2 + Nx + C + B + E + A2, 96, H + GW + GX + GY + GA + h + IK + C + E + A2, 4, K + j + Kd + A2, 1, D + L3 + IG + CP + h + " +y_0=-3500000" + j + Kd + E + A2, 4, D + L3 + Gl + V2 + IM + N + Y + Aw + E + A2, 2, K + C + A2, 4, K + C + A2, 3, K + C + A2, 3, I2 + Nq + C + E + A2, 1, I2 + PL + C + E + A2, 1, I2 + SK + C + E + A2, 1, I2 + TV + C + E + A2, 1, I2 + Xz + C + E + A2, 1, I2 + TY + C + E + A2, 1, I2 + RG + C + E + A2, 1, I2 + Ro + C + E + A2, 1, I2 + RH + C + E + A2, 1, I2 + TW + C + E + A2, 1, I2 + TX + C + E + A2, 1, I2 + QE + C + E + A2, 1, I2 + Ns + C + E + A2, 1, I2 + Nt + C + E + A2, 1, I2 + Nu + C + E + A2, 1, I2 + Nw + C + E + A2, 1, I2 + NP + C + E + A2, 1, I2 + NQ + C + E + A2, 1, I2 + Ik + C + E + A2, 1, I2 + IC + C + E + A2, 1, I2 + Hi + C + E + A2, 2, DT + Sa + Hl + ZB + OZ + s + N + C + E + A2, 1, H + AR + AS + AT + " +lon_0=-163" + Gx + EM + C + E + A2, 1, H + AR + AS + AT + Qr + Gc + EM + C + E + A2, 1, H + CI + OY + CJ + SX + Gw + JI + C + E + A2, 1, H + CI + OY + CJ + Qr + Hv + JI + C + E + A2, 1, D + IY + IV + Pc + h + N + C + E + A2, 1, D + Gm + OS + BG + a + N + C + E + A2, 6, H + " +lat_1=17.5 +lat_2=29.5 +lat_0=12 +lon_0=-102" + Ci + N + C + B + E + A2, 3, K + C + B + A2, 1, I2 + Ns + C + B + E + A2, 1, I2 + Nt + C + B + E + A2, 1, I2 + Nu + C + B + E + A2, 1, I2 + Nw + C + B + E + A2, 1, I2 + NP + C + B + E + A2, 1, I2 + NQ + C + B + E + A2, 1, H + " +lat_1=17.5 +lat_2=29.5 +lat_0=12 +lon_0=-102" + Ci + N + C + B + E + A2, 9, D + L3 + Gl + " +k=1" + AI + N + M + CC + E + A2, 1, D + L3 + II + " +k=1" + AI + N + M + CC + E + A2, 1, D + L3 + HO + " +k=1" + AI + N + M + CC + E + A2, 1, D + L3 + Ia + " +k=1" + AI + N + M + CC + E + A2, 1, D + L3 + IG + " +k=1" + AI + N + M + CC + E + A2, 1, D + L3 + PN + " +k=1" + AI + N + M + CC + E + A2, 1, D + L3 + LN + " +k=1" + AI + N + M + CC + E + A2, 4, H + " +lat_1=19.33333333333333 +lat_2=19.7 +lat_0=19.33333333333333 +lon_0=-80.56666666666666 +x_0=899160 +y_0=579120" + C + B + t + A2, 2, DT + " +lat_1=55" + QY + Yu + Ms + s + N + C + E + A2, 1, CU + " +lat_0=57" + Ku + Kv + V2 + LX + EO + KE + GZ + C + E + A2, 1, D + Ft + YN + V2 + O2 + N + C + E + A2, 1, D + Ft + YO + V2 + O2 + N + C + E + A2, 1, D + Ft + ON + V2 + O2 + N + C + E + A2, 1, D + Ft + Ms + V2 + O2 + N + C + E + A2, 1, D + Ft + KI + V2 + O2 + N + C + E + A2, 1, D + Ft + YP + V2 + O2 + N + C + E + A2, 1, D + Ft + YQ + V2 + O2 + N + C + E + A2, 1, D + Ft + SW + V2 + O2 + N + C + E + A2, 1, H + Kw + Kx + UK + YR + BZ + N + C + E + A2, 1, D + Bl + Co + V2 + EX + N + C + E + A2, 1, D + Bl + Co + V2 + EX + N + C + t + A2, 1, D + Bl + Cn + V2 + EX + N + C + E + A2, 1, D + Bl + Cn + V2 + EX + N + C + t + A2, 1, D + Bl + Iv + BG + EX + N + C + E + A2, 1, D + Bl + Iv + BG + EX + N + C + t + A2, 1, H + Dx + Dy + BC + IF + u + N + C + E + A2, 1, H + Dx + Dy + BC + IF + Au + N + C + J + A2, 1, H + Dz + Mq + EA + IF + u + Is + C + E + A2, 1, H + Dz + Mq + EA + IF + Au + Gt + C + J + A2, 1, DT + Yy + SY + L3 + Mt + s + QZ + C + E + A2, 1, H + DW + Jn + y + HA + Bd + Ae + C + E + A2, 1, H + DW + Jn + y + HA + Ac + AD + C + J + A2, 1, H + DX + DY + AA + HA + Bd + Ae + C + E + A2, 1, H + DX + DY + AA + HA + Ac + AD + C + J + A2, 1, H + Ap + DZ + Ml + AJ + Bd + Ae + C + E + A2, 1, H + Ap + DZ + Ml + AJ + Ac + AD + C + J + A2, 1, H + LO + QS + Da + Mm + Bd + Ae + C + E + A2, 1, H + LO + QS + Da + Mm + Ac + AD + C + J + A2, 1, H + Db + Dc + Mn + Ir + Bd + Ae + C + E + A2, 1, H + Db + Dc + Mn + Ir + Ac + AD + C + J + A2, 1, H + Dd + De + Df + Iw + Bd + Ae + C + E + A2, 1, H + Dd + De + Df + Iw + Ac + AD + C + J + A2, 1, H + LP + LQ + CY + Ba + Fw + Fx + C + E + A2, 1, H + LP + LQ + CY + Ba + Bw + CL + C + J + A2, 1, H + Eh + Ei + y + Ba + Fw + Fx + C + E + A2, 1, H + Eh + Ei + y + Ba + Bw + CL + C + J + A2, 1, H + Ap + Dg + f + Ba + Fw + Fx + C + E + A2, 1, H + Ap + Dg + f + Ba + Bw + CL + C + J + A2, 1, H + Dh + Mo + Di + Jq + QG + QH + C + E + A2, 1, H + Dh + Mo + Di + Jq + MC + MD + C + J + A2, 1, D + Ch + Cp + Mp + h + N + C + E + A2, 1, D + Ch + Cp + Mp + AE + N + C + J + A2, 1, D + Aq + CR + Am + h + N + C + E + A2, 1, D + Aq + CR + Am + AE + N + C + J + A2, 1, DT + " +lat_1=24" + YG + " +lat_0=24" + NV + u + N + C + E + A2, 1, H + LR + Dj + QT + LS + a + N + C + E + A2, 1, H + LR + Dj + QT + LS + a + N + C + J + A2, 1, D + Aq + Ob + Am + h + N + C + E + A2, 1, D + Aq + Ob + Am + AE + N + C + J + A2, 1, D + Gm + Cq + V2 + h + N + C + E + A2, 1, D + Gm + Cq + V2 + AE + N + C + J + A2, 1, D + Gm + Cr + V2 + EW + N + C + E + A2, 1, D + Gm + Cr + V2 + CM + N + C + J + A2, 1, D + p + Jb + BJ + O2 + N + C + E + A2, 1, D + p + Jb + BJ + AF + N + C + J + A2, 1, D + p + Cs + BJ + h + N + C + E + A2, 1, D + p + Cs + BJ + AE + N + C + J + A2, 1, D + p + Ix + BG + CX + N + C + E + A2, 1, D + p + Ix + BG + ME + N + C + J + A2, 1, D + f + Cz + EQ + AI + N + C + E + A2, 1, D + f + Cz + EQ + AI + N + C + J + A2, 1, D + f + DA + Am + EW + N + C + E + A2, 1, D + f + DA + Am + MO + N + C + J + A2, 1, D + DM + DB + AO + BU + KJ + C + E + A2, 1, D + DM + DB + AO + MM + GI + C + J + A2, 1, D + DM + DC + AO + HT + KJ + C + E + A2, 1, D + DM + DC + AO + HT + GI + C + J + A2, 1, H + EB + EC + Fo + GG + AV + AH + C + E + A2, 1, H + EB + EC + Fo + GG + AV + GJ + C + J + A2, 1, H + AY + ED + Fs + GG + O2 + N + C + E + A2, 1, H + AY + ED + Fs + GG + AG + N + C + J + A2, 1, H + EE + EF + AQ + Fl + u + N + C + E + A2, 1, H + EE + EF + AQ + Fl + Au + N + C + J + A2, 1, H + EG + EH + f + CV + u + Is + C + E + A2, 1, H + EG + EH + f + CV + Au + Gt + C + J + A2, 1, H + Az + DV + DM + Jo + O2 + N + C + E + A2, 1, H + Az + DV + DM + Jo + AF + N + C + J + A2, 1, H + Fi + Fj + AB + EY + AV + AH + C + E + A2, 1, H + Fi + Fj + AB + EY + AV + CN + C + J + A2, 1, H + Ej + Ek + AB + EY + O2 + Ae + C + E + A2, 1, H + Ej + Ek + AB + EY + AF + AD + C + J + A2, 1, H + FS + FT + IY + Hg + BZ + N + C + E + A2, 1, H + FS + FT + IY + Hg + Eb + N + C + J + A2, 1, H + OH + OI + OJ + Bi + BZ + N + C + E + A2, 1, H + OH + OI + OJ + Bi + Eb + N + C + J + A2, 1, D + YM + Rj + JE + O2 + N + C + E + A2, 1, D + AL + Rf + JE + EW + N + C + E + A2, 1, D + BD + Rg + JE + AI + N + C + E + A2, 1, D + AK + HJ + V2 + AI + N + C + E + A2, 1, D + AK + HJ + V2 + AI + N + C + J + A2, 1, D + BD + DD + AO + HT + N + C + E + A2, 1, D + BD + DD + AO + HT + N + C + J + A2, 1, H + MU + Nz + AA + Ld + u + N + C + E + A2, 1, H + MU + Nz + AA + Ld + MF + N + C + J + A2, 1, H + Em + En + Ip + IL + O2 + N + C + E + A2, 1, H + Em + En + Ip + IL + AF + N + C + J + A2, 1, H + El + Dk + Ip + GE + h + Mk + C + E + A2, 1, H + El + Dk + Ip + GE + AE + Mk + C + J + A2, 1, H + OA + Er + Es + BE + Pk + N + C + E + A2, 1, H + OA + Er + Es + BE + MH + N + C + t + A2, 1, H + Eo + Ep + Eq + Jh + Tl + N + C + E + A2, 1, H + Eo + Ep + Eq + Jh + MG + N + C + t + A2, 1, CU + Kr + " +lonc=-86" + QI + AP + QJ + PY + KE + QK + C + E + A2, 1, H + Bq + OB + Fo + BE + LU + N + C + E + A2, 1, H + Bq + OB + Fo + BE + OT + N + C + t + A2, 1, H + Ma + FW + IP + Js + CX + EK + C + E + A2, 1, H + Ma + FW + IP + Js + An + Ao + C + J + A2, 1, H + FU + FV + Iq + DE + CX + EK + C + E + A2, 1, H + FU + FV + Iq + DE + An + Ao + C + J + A2, 1, H + FX + FY + Nj + Na + CX + EK + C + E + A2, 1, H + FX + FY + Nj + Na + An + Ao + C + J + A2, 1, D + Hj + Ct + CP + AI + N + C + E + A2, 1, D + Hj + Ct + CP + AI + N + C + J + A2, 1, D + Li + Sj + Tn + O2 + Pm + C + E + A2, 1, D + Hj + Bx + CP + EW + N + C + E + A2, 1, D + Hj + Bx + CP + CM + N + C + J + A2, 1, D + Cd + Hg + BG + O2 + N + C + E + A2, 1, D + Cd + RS + BG + Bv + N + C + E + A2, 1, D + Id + RT + Am + YC + N + C + E + A2, 1, H + LM + RK + MV + IS + a + N + C + E + A2, 1, H + LM + RK + MV + IS + DR + N + C + t + A2, 1, H + JT + Jn + FZ + CS + O2 + N + C + E + A2, 2, D + CQ + DG + V2 + O2 + Hh + C + E + A2, 1, D + CQ + DG + V2 + AG + Hh + C + J + A2, 1, D + CQ + DF + V2 + h + Tm + C + E + A2, 1, D + CQ + DF + V2 + Gu + MN + C + J + A2, 1, D + CQ + DH + V2 + CX + LV + C + E + A2, 1, D + CQ + DH + V2 + An + NE + C + J + A2, 1, D + Fp + DI + AO + AI + N + C + E + A2, 1, D + Fp + DI + AO + AI + N + C + J + A2, 1, D + BA + Gp + V2 + Bn + N + C + E + A2, 1, D + BA + Gp + V2 + Bn + N + C + J + A2, 1, D + Bl + Iy + V2 + O2 + N + C + E + A2, 1, D + Bl + Iy + V2 + AF + N + C + J + A2, 1, D + Bl + Cu + Hm + OC + N + C + E + A2, 1, D + Bl + Cu + Hm + OC + N + C + J + A2, 1, D + Bl + Cv + Iz + YD + N + C + E + A2, 1, D + Bl + Cv + Iz + MI + N + C + J + A2, 1, D + Fs + Cw + Ad + Bv + N + C + E + A2, 1, D + Fs + Cw + Ad + MJ + N + C + J + A2, 1, D + BA + Gp + V2 + Bn + N + C + E + A2, 1, D + BA + Gp + V2 + Bn + N + C + J + A2, 1, H + Dl + Dm + BB + Oc + AI + N + C + E + A2, 1, H + Dl + Dm + BB + Oc + AI + N + C + J + A2, 1, D + Fs + Cx + Ad + Qo + N + C + E + A2, 1, D + Fs + Cx + Ad + MK + N + C + J + A2, 1, H + Et + Eu + LT + NW + Rh + N + C + E + A2, 1, H + Et + Eu + LT + NW + Z2 + N + C + J + A2, 1, H + BH + Ev + Ib + EZ + a + N + C + E + A2, 1, H + BH + Ev + Ib + EZ + DR + N + C + t + A2, 1, H + Ew + Ex + Be + EZ + a + N + C + E + A2, 1, H + Ew + Ex + Be + EZ + DR + N + C + t + A2, 1, H + OK + Fa + BY + ET + a + N + C + E + A2, 1, H + OK + Fa + BY + ET + a + N + C + J + A2, 1, H + Fb + Fc + Ch + ET + a + N + C + E + A2, 1, H + Fb + Fc + Ch + ET + a + N + C + J + A2, 1, H + Dn + Ey + QU + Fl + a + N + C + E + A2, 1, H + Dn + Ey + QU + Fl + a + N + C + J + A2, 1, H + Ez + FA + Do + Fl + a + N + C + E + A2, 1, H + Ez + FA + Do + Fl + a + N + C + J + A2, 1, H + JT + Hl + GH + AJ + u + N + C + E + A2, 1, H + JT + Hl + GH + AJ + Lc + N + C + t + A2, 1, H + PP + CZ + AK + AJ + Ci + N + C + E + A2, 1, H + PP + CZ + AK + AJ + KL + N + C + t + A2, 1, H + PQ + Ca + p + AJ + AV + N + C + E + A2, 1, H + PQ + Ca + p + AJ + KM + N + C + t + A2, 1, H + MW + FB + BB + Ea + a + N + C + E + A2, 1, H + MW + FB + BB + Ea + a + N + C + J + A2, 1, H + Dp + Dq + y + Ea + a + N + C + E + A2, 1, H + Dp + Dq + y + Ea + a + N + C + J + A2, 1, H + GW + GX + GY + GA + h + IK + C + E + A2, 1, D + EI + GE + Lb + BU + N + C + E + A2, 1, D + EI + GE + Lb + JV + N + C + J + A2, 1, H + FC + OD + Dr + CR + OE + N + C + E + A2, 1, H + FC + OD + Dr + CR + OE + N + C + t + A2, 1, H + Fd + Fe + AL + CS + a + N + C + E + A2, 1, H + Fd + Fe + AL + CS + a + N + C + J + A2, 1, H + OL + Ff + EJ + Ag + a + N + C + E + A2, 1, H + OL + Ff + EJ + Ag + a + N + C + J + A2, 1, H + FD + MX + BC + MQ + a + N + C + E + A2, 1, H + FD + MX + BC + MQ + a + N + C + J + A2, 1, H + FH + FI + Cb + Ag + EW + Fq + C + E + A2, 1, H + FH + FI + Cb + Ag + CM + Fq + C + J + A2, 1, DT + OM + RO + OX + CS + AV + Hh + C + E + A2, 1, H + OM + RO + OX + CS + AV + Ju + C + E + A2, 1, H + FE + MY + QV + Jr + h + AH + C + E + A2, 1, H + FE + MY + QV + Jr + AE + CN + C + J + A2, 1, H + FF + FG + Ds + CV + a + Cl + C + E + A2, 1, H + FF + FG + Ds + CV + a + Gr + C + J + A2, 1, H + CD + CE + Cc + CV + AI + Ju + C + E + A2, 1, H + CD + CE + Cc + CV + AI + Nf + C + J + A2, 1, H + FJ + FK + Dt + Ji + a + LV + C + E + A2, 1, H + FJ + FK + Dt + Ji + a + Ne + C + J + A2, 1, D + Fp + LW + JA + O2 + N + C + E + A2, 1, D + Fp + LW + JA + AG + N + C + J + A2, 1, H + " +lat_1=37" + YS + GM + Ga + s + N + C + E + A2, 1, H + OF + FL + AA + GF + Bo + Cl + C + E + A2, 1, H + OF + FL + AA + GF + Gs + Gr + C + J + A2, 1, H + Az + Du + AB + GF + Bo + AH + C + E + A2, 1, H + Az + Du + AB + GF + Gs + CN + C + J + A2, 1, H + BH + OG + Ib + Cy + O2 + N + C + E + A2, 1, H + BH + OG + Ib + Cy + AF + N + C + J + A2, 1, H + FM + FN + Dv + AJ + O2 + N + C + E + A2, 1, H + FM + FN + Dv + AJ + AF + N + C + J + A2, 1, H + Mb + RN + Mr + Ga + a + N + C + E + A2, 1, H + Mb + RN + Mr + Ga + a + N + C + J + A2, 1, H + Fg + Fh + QX + CR + a + N + C + E + A2, 1, H + Fg + Fh + QX + CR + a + N + C + J + A2, 2, H + Jc + MZ + AL + Bu + a + N + C + J + A2, 1, H + FO + FP + Dw + Bu + a + N + C + E + A2, 1, H + FO + FP + Dw + Bu + a + N + C + J + A2, 1, H + FQ + FR + PR + Bu + a + N + C + E + A2, 1, H + FQ + FR + PR + Bu + a + N + C + J + A2, 1, D + L3 + Bu + AP + YF + Sh + C + E + A2, 1, D + CA + DJ + Ad + h + N + C + E + A2, 1, D + CA + DJ + Ad + Gu + N + C + J + A2, 1, D + CA + DK + Ad + u + EK + C + E + A2, 1, D + CA + DK + Ad + Au + Ao + C + J + A2, 1, D + CA + DL + Ad + CX + EK + C + E + A2, 1, D + CA + DL + Ad + An + Ao + C + J + A2, 1, D + CA + JB + Ad + a + N + C + E + A2, 1, D + CA + JB + Ad + a + N + C + J + A2, 1, H + JF + CG + AQ + BI + O2 + Cl + C + E + A2, 1, H + AY + CF + Br + BI + O2 + AH + C + E + A2, 1, H + JG + CH + f + BI + O2 + Fq + C + E + A2, 1, H + UF + Nh + IZ + HJ + s + N + C + B + E + A2, 1, DT + UF + Nh + IZ + HJ + s + N + C + B + E + A2, 1, DT + UF + Nh + IZ + HJ + s + N + C + B + E + A2, 1, H + JF + CG + AQ + BI + AG + NF + C + J + A2, 1, H + AY + CF + Br + BI + AG + GJ + C + J + A2, 1, H + JG + CH + f + BI + AG + Fq + C + J + A2, 1, D + Kn + Sf + AO + O2 + N + C + E + A2, 1, D + Ko + KO + AO + O2 + N + C + E + A2, 1, D + GV + KI + Jl + O2 + N + C + E + A2, 1, D + Kp + Sg + Jl + O2 + N + C + E + A2, 1, D + Kq + KP + " +k=1" + O2 + N + C + E + A2, 1, D + GV + KI + Jl + AG + N + C + J + A2, 1, I2 + TY + C + E + A2, 1, I2 + RG + C + E + A2, 1, I2 + TV + o + C + E + A2, 1, D + " +lat_0=13.5 +lon_0=144.75 +k=1" + BU + IK + C + E + A2, 9, D + WJ + " +lon_0=46.5 +k=0.9994" + CX + N + Bc + Ge + EU + E + A2, 22, K + C + A2, 1, D + PT + Zz + V2 + s + N + C + E + A2, 1, D + PT + NX + V2 + s + N + C + E + A2, 1, D + GM + Ox + V2 + s + N + C + E + A2, 1, D + PT + Tk + V2 + s + N + C + E + A2, 1, D + GM + Oy + V2 + s + N + C + E + A2, 1, D + GM + Rw + V2 + s + N + C + E + A2, 1, D + GM + Oz + V2 + s + N + C + E + A2, 1, D + GM + aA + V2 + s + N + C + E + A2, 1, D + GM + PA + V2 + s + N + C + E + A2, 1, D + Fs + PB + V2 + s + N + C + E + A2, 1, D + IZ + ZH + V2 + s + N + C + E + A2, 1, D + IZ + ZI + V2 + s + N + C + E + A2, 1, D + IZ + ZJ + V2 + s + N + C + E + A2, 1, D + IQ + " +lon_0=142" + V2 + s + N + C + E + A2, 1, D + IQ + Pj + V2 + s + N + C + E + A2, 1, D + IQ + " +lon_0=124" + V2 + s + N + C + E + A2, 1, D + IQ + NX + V2 + s + N + C + E + A2, 1, D + " +lat_0=20" + Rw + V2 + s + N + C + E + A2, 1, D + IQ + ZR + V2 + s + N + C + E + A2, 1, I2 + Mg + C + E + A2, 1, I2 + NT + C + E + A2, 1, I2 + Ot + C + E + A2, 1, I2 + Nv + C + E + A2, 1, I2 + PM + C + E + A2, 11, D + L3 + US + AP + O2 + Ak + j + B + E + A2, 3, K + C + B + A2, 1, I2 + JN + C + B + E + A2, 1, I2 + KC + C + B + E + A2, 1, I2 + NR + C + B + E + A2, 11, D + L3 + " +lon_0=105.625 +k=1.000024" + Jm + Pm + j + B + E + A2, 1, D + L3 + " +lon_0=105.625 +k=1.00002514" + Jm + Pm + C + B + E + A2, 1, D + L3 + " +lon_0=96.875 +k=1" + Jm + " +y_0=1400000" + j + B + E + A2, 1, D + L3 + " +lon_0=96.875 +k=0.99999387" + Jm + DQ + C + B + E + A2, 13, I2 + QF + o + C + B + E + A2, 1, I2 + Ny + o + C + B + E + A2, 1, I2 + Nq + o + C + B + E + A2, 45, K + C + A2, 1, D + OO + KS + SB + Of + N + C + E + A2, 1, D + OO + KS + SB + JJ + N + C + t + A2, 1, D + OO + KS + SB + Of + N + C + E + A2, 1, D + OO + KS + SB + JJ + N + C + t + A2, 1, D + GH + Rk + " +k=1.0002" + Oa + N + C + E + A2, 1, D + GH + Rk + " +k=1.0002" + HL + N + C + t + A2, 1, D + GH + Rk + " +k=1.0002" + Oa + N + C + E + A2, 1, D + GH + Rk + " +k=1.0002" + HL + N + C + t + A2, 1, H + Ky + Kz + Rl + Mc + Oa + " +y_0=130000" + C + E + A2, 1, H + Ky + Kz + Rl + Mc + HL + Zo + C + t + A2, 1, H + Ky + Kz + Rl + Mc + Oa + " +y_0=130000" + C + E + A2, 1, H + Ky + Kz + Rl + Mc + HL + Zo + C + t + A2, 1, H + Bq + AK + Rm + YU + " +x_0=120000 +y_0=60000" + C + E + A2, 1, H + Bq + AK + Rm + YU + Zp + aM + C + t + A2, 1, H + Bq + AK + Rm + YU + " +x_0=120000 +y_0=60000" + C + E + A2, 1, H + Bq + AK + Rm + YU + Zp + aM + C + t + A2, 1, D + Fp + Bj + Ze + Of + N + C + E + A2, 1, D + Fp + Bj + Ze + JJ + N + C + t + A2, 1, D + Fp + Bj + Ze + Of + N + C + E + A2, 1, D + Fp + Bj + Ze + JJ + N + C + t + A2, 1, H + LA + Be + AJ + Sk + Bn + " +y_0=30000" + C + E + A2, 1, H + LA + Be + AJ + Sk + Ng + aN + C + t + A2, 1, H + LA + Be + AJ + Sk + Bn + " +y_0=30000" + C + E + A2, 1, H + LA + Be + AJ + Sk + Ng + aN + C + t + A2, 1, CU + LB + Zf + Zg + " +k=1" + Tp + ZL + KE + Zh + C + E + A2, 1, CU + LB + Zf + Zg + " +k=1" + ZN + Zq + KE + Zh + C + t + A2, 1, CU + LB + Zf + Zg + " +k=1" + Tp + ZL + KE + Zh + C + E + A2, 1, CU + LB + Zf + Zg + " +k=1" + ZN + Zq + KE + Zh + C + t + A2, 1, D + BD + Bj + YV + Jm + N + C + E + A2, 1, D + BD + Bj + YV + HM + N + C + t + A2, 1, D + BD + Bj + YV + Jm + N + C + E + A2, 1, D + BD + Bj + YV + HM + N + C + t + A2, 1, D + OO + YW + Zi + Oa + N + C + E + A2, 1, D + OO + YW + Zi + HL + N + C + t + A2, 1, D + OO + YW + Zi + Oa + N + C + E + A2, 1, D + OO + YW + Zi + HL + N + C + t + A2, 1, D + Tq + KT + Lk + Jm + N + C + E + A2, 1, D + Tq + KT + Lk + HM + N + C + t + A2, 1, D + Tq + KT + Lk + Jm + N + C + E + A2, 1, D + Tq + KT + Lk + HM + N + C + t + A2, 1, D + GH + Bj + Qs + Jm + N + C + E + A2, 1, D + GH + Bj + Qs + HM + N + C + t + A2, 1, D + GH + Bj + Qs + Jm + N + C + E + A2, 1, D + GH + Bj + Qs + HM + N + C + t + A2, 1, D + IP + KU + Zj + " +x_0=10000" + N + C + E + A2, 1, D + IP + KU + Zj + aV + N + C + t + A2, 1, D + IP + KU + Zj + " +x_0=10000" + N + C + E + A2, 1, D + IP + KU + Zj + aV + N + C + t + A2, 1, D + IP + Ir + Zk + Of + N + C + E + A2, 1, D + IP + Ir + Zk + JJ + N + C + t + A2, 1, D + IP + Ir + Zk + Of + N + C + E + A2, 1, D + IP + Ir + Zk + JJ + N + C + t + A2, 1, D + Tr + Lj + " +k=1.0001" + Oa + N + C + E + A2, 1, D + Tr + Lj + " +k=1.0001" + HL + N + C + t + A2, 1, D + Tr + Lj + " +k=1.0001" + Oa + N + C + E + A2, 1, D + Tr + Lj + " +k=1.0001" + HL + N + C + t + A2, 1, CU + Pn + Sl + " +alpha=5 +k=1 +x_0=-300000 +y_0=-4600000" + KE + " +gamma=5" + C + E + A2, 1, CU + Pn + Sl + " +alpha=5 +k=1" + Zr + Yp + KE + " +gamma=5" + C + t + A2, 1, CU + Pn + Sl + " +alpha=5 +k=1 +x_0=-300000 +y_0=-4600000" + KE + " +gamma=5" + C + E + A2, 1, CU + Pn + Sl + " +alpha=5 +k=1" + Zr + Yp + KE + " +gamma=5" + C + t + A2, 1, D + Ts + KV + Sb + " +x_0=60000" + N + C + E + A2, 1, D + Ts + KV + Sb + aO + N + C + t + A2, 1, D + Ts + KV + Sb + " +x_0=60000" + N + C + E + A2, 1, D + Ts + KV + Sb + aO + N + C + t + A2, 1, D + LC + IW + YX + Zl + N + C + E + A2, 1, D + LC + IW + YX + aP + N + C + t + A2, 1, D + LC + IW + YX + Zl + N + C + E + A2, 1, D + LC + IW + YX + aP + N + C + t + A2, 1, H + Jc + YY + Rn + Sm + BU + Rz + C + E + A2, 1, H + Jc + YY + Rn + Sm + JW + Ra + C + t + A2, 1, H + Jc + YY + Rn + Sm + BU + Rz + C + E + A2, 1, H + Jc + YY + Rn + Sm + JW + Ra + C + t + A2, 1, D + LD + KW + Zm + Jm + N + C + E + A2, 1, D + LD + KW + Zm + HM + N + C + t + A2, 1, D + LD + KW + Zm + Jm + N + C + E + A2, 1, D + LD + KW + Zm + HM + N + C + t + A2, 1, D + LE + Sn + YZ + s + N + C + E + A2, 1, D + LE + Sn + YZ + s + N + C + t + A2, 1, D + LE + Sn + YZ + s + N + C + E + A2, 1, D + LE + Sn + YZ + s + N + C + t + A2, 4, H + JT + Hl + GH + AJ + u + N + C + E + A2, 1, H + JT + Hl + GH + AJ + Lc + N + C + t + A2, 2, D + L3 + UI + " +k=1" + O2 + N + C + B + E + A2, 5, D + L3 + IH + " +k=0.9985000000000001" + Tp + N + C + B + E + A2, 1, D + L3 + IH + " +k=1" + aH + N + C + B + E + A2, 3, H + Jc + MZ + AL + Bu + a + N + C + E + A2, 1, H + JT + Jn + FZ + CS + AG + N + C + J + A2, 1, K + Bc + Ge + " +towgs84=-24,-203,268,0,0,0,0" + A2, 1, K + Bc + Ge + " +towgs84=-183,-15,273,0,0,0,0" + A2, 1, K + R + " +towgs84=-235,-110,393,0,0,0,0" + A2, 1, H + PP + CZ + AK + AJ + Ci + N + C + E + A2, 1, H + PP + CZ + AK + AJ + KL + N + C + t + A2, 1, H + PQ + Ca + p + AJ + AV + N + C + E + A2, 1, H + PQ + Ca + p + AJ + KM + N + C + t + A2, 5, K + Bc + Ge + PK + A2, 2, K + Bc + Ge + " +towgs84=-63,176,185,0,0,0,0" + A2, 21, I2 + Me + Bc + Ge + PK + E + A2, 7, H + Sc + Ya + GM + So + u + N + C + B + E + A2, 1, H + Sc + Ya + GM + So + Au + N + C + B + J + A2, 1, H + Sc + Ya + GM + So + u + N + C + E + A2, 1, H + Sc + Ya + GM + So + Au + N + C + J + A2, 6, He + Hr + HN + s + N + j + B + E + A2, 1, He + m + HN + s + N + j + B + E + A2, 1, "+proj=cea" + HN + " +lat_ts=30" + s + N + j + B + E + A2, 29, H + " +lat_1=39 +lat_2=43" + Ip + UI + s + N + C + B + E + A2, 21, K + C + A2, 1, D + Ou + Ov + Zw + UV + Yl + C + E + A2, 6, K + C + A2, 1, D + Ou + Ov + Zw + UV + Yl + C + E + A2, 14, I2 + KD + Bc + Ge + DO + E + A2, 1, I2 + JZ + Bc + Ge + DO + E + A2, 1, I2 + JM + Bc + Ge + DO + E + A2, 28, K + C + A2, 2, K + C + A2, 2, K + C + A2, 2, K + C + A2, 16, H + " +lat_1=43.2 +lat_0=43.2 +lon_0=-95.25 +k_0=1.000052 +x_0=3505207.010414021 +y_0=2926085.852171705" + C + J + A2, 1, H + " +lat_1=43.16666666666666 +lat_0=43.16666666666666 +lon_0=-92.75 +k_0=1.000043 +x_0=3810007.62001524 +y_0=2987045.974091948" + C + J + A2, 1, D + Md + " +lon_0=-91.2 +k=1.000035 +x_0=4114808.229616459 +y_0=2529845.05969012" + C + J + A2, 1, H + " +lat_1=42.53333333333333 +lat_0=42.53333333333333 +lon_0=-94.83333333333333 +k_0=1.000045 +x_0=4419608.839217679 +y_0=2621285.242570485" + C + J + A2, 1, H + " +lat_1=42.65 +lat_0=42.65 +lon_0=-92.25 +k_0=1.000032 +x_0=4724409.448818898 +y_0=2712725.425450851" + C + J + A2, 1, D + Md + " +lon_0=-95.73333333333333 +k=1.000039 +x_0=5029210.058420117 +y_0=2011684.023368047" + C + J + A2, 1, D + Md + " +lon_0=-94.63333333333334" + Sb + " +x_0=5334010.668021336 +y_0=2072644.145288291" + C + J + A2, 1, D + Md + " +lon_0=-93.71666666666667 +k=1.000033 +x_0=5638811.277622555 +y_0=2133604.267208535" + C + J + A2, 1, D + Md + " +lon_0=-92.81666666666666" + OP + " +x_0=5943611.887223775 +y_0=2194564.389128779" + C + J + A2, 1, H + " +lat_1=41.83333333333334 +lat_0=41.83333333333334 +lon_0=-91.66666666666667 +k_0=1.00002 +x_0=6248412.496824994 +y_0=2438404.876809754" + C + J + A2, 1, D + Md + " +lon_0=-90.53333333333333" + OP + " +x_0=6553213.106426213 +y_0=2316484.632969266" + C + J + A2, 1, H + " +lat_1=40.91666666666666 +lat_0=40.91666666666666 +lon_0=-93.75 +k_0=1.000037 +x_0=6858013.716027432" + Yq + C + J + A2, 1, D + Md + Oo + Og + " +x_0=7162814.325628651 +y_0=1950723.901447803" + C + J + A2, 1, D + Md + " +lon_0=-91.25 +k=1.000018 +x_0=7467614.93522987" + Yq + C + J + A2, 3, K + C + A2, 1, I2 + KD + o + C + E + A2, 1, I2 + JZ + o + C + E + A2, 1, I2 + JM + o + C + E + A2, 1, I2 + Me + o + C + E + A2, 1, I2 + Rb + o + C + E + A2, 1, I2 + Rc + o + C + E + A2, 1, I2 + SO + o + C + E + A2, 1, I2 + Td + o + C + E + A2, 3, K + C + A2, 2, K + C + A2, 23, D + Qt + Sp + SB + Bn + N + C + E + A2, 1, D + " +lat_0=48" + Sp + " +k=1.00019" + BU + N + C + E + A2, 1, H + Yb + Qt + KK + " +k_0=1.000145" + Bn + IK + C + E + A2, 1, H + Yb + Qt + " +lon_0=-108.5" + Mc + h + " +y_0=150000" + C + E + A2, 1, H + LF + LG + Ba + Mc + h + EK + C + E + A2, 1, H + LF + LG + Ba + " +k_0=1.00009" + BU + Rz + C + E + A2, 1, D + Pn + " +lon_0=-107.75 +k=1.000148" + h + N + C + E + A2, 1, H + aI + " +lat_0=46.25 +lon_0=-111.25 +k_0=1.000185" + BU + EK + C + E + A2, 1, H + WV + WW + Ub + " +k_0=1.0001515" + h + Rz + C + E + A2, 1, D + WX + Uc + " +k=1.00024" + BU + N + C + E + A2, 1, D + Qt + Sp + SB + Ng + N + C + t + A2, 1, D + " +lat_0=48" + Sp + " +k=1.00019" + JW + N + C + t + A2, 1, H + Yb + Qt + KK + " +k_0=1.000145" + Ng + " +y_0=199999.9999992" + C + t + A2, 1, H + Yb + Qt + " +lon_0=-108.5" + Mc + OU + " +y_0=150000.00001464" + C + t + A2, 1, H + LF + LG + Ba + Mc + OU + Yr + C + t + A2, 1, H + LF + LG + Ba + " +k_0=1.00009" + JW + " +y_0=49999.99971024" + C + t + A2, 1, D + Pn + " +lon_0=-107.75 +k=1.000148" + OU + N + C + t + A2, 1, H + aI + " +lat_0=46.25 +lon_0=-111.25 +k_0=1.000185" + JW + Yr + C + t + A2, 1, H + WV + WW + Ub + " +k_0=1.0001515" + OU + Ra + C + t + A2, 1, D + WX + Uc + " +k=1.00024" + JV + N + C + J + A2, 3, D + Po + " +lon_0=-122.45 +k=1.000007 +x_0=48000 +y_0=24000" + C + E + A2, 1, D + Po + " +lon_0=-122.45 +k=1.000007 +x_0=48000 +y_0=24000" + C + J + A2, 1, K + C + A2, 3, K + j + A2, 3, K + j + A2, 3, D + LH + LI + " +k=1" + Qx + " +y_0=126867.909" + Nc + Nd + " +towgs84=-275.7224,94.7824,340.8944,-8.001,-4.42,-11.821,1" + E + A2, 115, D + Pp + Sq + Ll + l + q + C + E + A2, 1, D + Pp + Sq + Ll + l + q + C + J + A2, 1, D + Qu + Oj + Lm + l + q + C + E + A2, 1, D + Qu + Oj + Lm + l + q + C + J + A2, 1, D + " +lat_0=39" + KX + Ln + l + q + C + E + A2, 1, D + " +lat_0=39" + KX + Ln + l + q + C + J + A2, 1, D + " +lat_0=40.45" + Pq + Yc + l + q + C + E + A2, 1, D + " +lat_0=40.45" + Pq + Yc + l + q + C + J + A2, 1, D + " +lat_0=40.05" + Ud + OQ + l + q + C + E + A2, 1, D + " +lat_0=40.05" + Ud + OQ + l + q + C + J + A2, 1, D + Yd + Pr + OR + l + q + C + E + A2, 1, D + Yd + Pr + OR + l + q + C + J + A2, 1, D + " +lat_0=39" + Tt + Zn + l + q + C + E + A2, 1, D + " +lat_0=39" + Tt + Zn + l + q + C + J + A2, 1, D + " +lat_0=40.4" + Ue + Ln + l + q + C + E + A2, 1, D + " +lat_0=40.4" + Ue + Ln + l + q + C + J + A2, 1, D + Pp + Uf + Qv + l + q + C + E + A2, 1, D + Pp + Uf + Qv + l + q + C + J + A2, 1, D + Tu + Ug + " +k=1.000021" + l + q + C + E + A2, 1, D + Tu + Ug + " +k=1.000021" + l + q + C + J + A2, 1, D + Tv + Uh + " +k=1.000024" + l + q + C + E + A2, 1, D + Tv + Uh + " +k=1.000024" + l + q + C + J + A2, 1, D + " +lat_0=40.15" + Ui + " +k=1.000032" + l + q + C + E + A2, 1, D + " +lat_0=40.15" + Ui + " +k=1.000032" + l + q + C + J + A2, 1, D + " +lat_0=38.1" + Pr + Qw + l + q + C + E + A2, 1, D + " +lat_0=38.1" + Pr + Qw + l + q + C + J + A2, 1, D + " +lat_0=38.45" + KY + " +k=1.000018" + l + q + C + E + A2, 1, D + " +lat_0=38.45" + KY + " +k=1.000018" + l + q + C + J + A2, 1, D + " +lat_0=38.65" + Uj + Yc + l + q + C + E + A2, 1, D + " +lat_0=38.65" + Uj + Yc + l + q + C + J + A2, 1, D + " +lat_0=39.1" + Uk + OR + l + q + C + E + A2, 1, D + " +lat_0=39.1" + Uk + OR + l + q + C + J + A2, 1, D + Tw + Sq + OR + l + q + C + E + A2, 1, D + Tw + Sq + OR + l + q + C + J + A2, 1, D + " +lat_0=38.2" + Sr + Og + l + q + C + E + A2, 1, D + " +lat_0=38.2" + Sr + Og + l + q + C + J + A2, 1, D + Tx + KX + " +k=1.000033" + l + q + C + E + A2, 1, D + Tx + KX + " +k=1.000033" + l + q + C + J + A2, 1, D + Ty + Oj + OQ + l + q + C + E + A2, 1, D + Ty + Oj + OQ + l + q + C + J + A2, 1, D + " +lat_0=39.95" + Pq + Qw + l + q + C + E + A2, 1, D + " +lat_0=39.95" + Pq + Qw + l + q + C + J + A2, 1, D + Qu + Tt + Lm + l + q + C + E + A2, 1, D + Qu + Tt + Lm + l + q + C + J + A2, 1, D + Tu + Ul + Ye + l + q + C + E + A2, 1, D + Tu + Ul + Ye + l + q + C + J + A2, 1, D + Tz + " +lon_0=-85.7" + Ll + l + q + C + E + A2, 1, D + Tz + " +lon_0=-85.7" + Ll + l + q + C + J + A2, 1, D + " +lat_0=39.9" + MQ + Ll + l + q + C + E + A2, 1, D + " +lat_0=39.9" + MQ + Ll + l + q + C + J + A2, 1, D + " +lat_0=39.65" + UA + OR + l + q + C + E + A2, 1, D + " +lat_0=39.65" + UA + OR + l + q + C + J + A2, 1, D + " +lat_0=37.95" + HC + OP + l + q + C + E + A2, 1, D + " +lat_0=37.95" + HC + OP + l + q + C + J + A2, 1, D + " +lat_0=39.75" + Ss + Qs + l + q + C + E + A2, 1, D + " +lat_0=39.75" + Ss + Qs + l + q + C + J + A2, 1, D + Tz + HC + Lm + l + q + C + E + A2, 1, D + Tz + HC + Lm + l + q + C + J + A2, 1, D + Tx + To + Ll + l + q + C + E + A2, 1, D + Tx + To + Ll + l + q + C + J + A2, 1, D + " +lat_0=38.7 +lon_0=-85.95" + Yf + l + q + C + E + A2, 1, D + " +lat_0=38.7 +lon_0=-85.95" + Yf + l + q + C + J + A2, 1, D + Yg + KY + OP + l + q + C + E + A2, 1, D + Yg + KY + OP + l + q + C + J + A2, 1, D + " +lat_0=40.3" + SA + OQ + l + q + C + E + A2, 1, D + " +lat_0=40.3" + SA + OQ + l + q + C + J + A2, 1, D + " +lat_0=38.55" + Um + Qv + l + q + C + E + A2, 1, D + " +lat_0=38.55" + Um + Qv + l + q + C + J + A2, 1, D + " +lat_0=38.8" + UA + Qw + l + q + C + E + A2, 1, D + " +lat_0=38.8" + UA + Qw + l + q + C + J + A2, 1, D + Yh + HC + Lm + l + q + C + E + A2, 1, D + Yh + HC + Lm + l + q + C + J + A2, 1, D + " +lat_0=38.4" + St + Lk + l + q + C + E + A2, 1, D + " +lat_0=38.4" + St + Lk + l + q + C + J + A2, 1, D + Tw + Ss + " +k=1.000037" + l + q + C + E + A2, 1, D + Tw + Ss + " +k=1.000037" + l + q + C + J + A2, 1, D + Yg + Un + Ln + l + q + C + E + A2, 1, D + Yg + Un + Ln + l + q + C + J + A2, 1, D + Qu + " +lon_0=-86.75" + OP + l + q + C + E + A2, 1, D + Qu + " +lon_0=-86.75" + OP + l + q + C + J + A2, 1, D + " +lat_0=38.95" + Pr + Qv + l + q + C + E + A2, 1, D + " +lat_0=38.95" + Pr + Qv + l + q + C + J + A2, 1, D + " +lat_0=39.45" + Sr + Lm + l + q + C + E + A2, 1, D + " +lat_0=39.45" + Sr + Lm + l + q + C + J + A2, 1, D + Tv + KZ + Ln + l + q + C + E + A2, 1, D + Tv + KZ + Ln + l + q + C + J + A2, 1, D + Yd + Uo + Yf + l + q + C + E + A2, 1, D + Yd + Uo + Yf + l + q + C + J + A2, 1, D + Yi + " +lon_0=-86.7" + Og + l + q + C + E + A2, 1, D + Yi + " +lon_0=-86.7" + Og + l + q + C + J + A2, 1, D + " +lat_0=37.85" + Pq + Lk + l + q + C + E + A2, 1, D + " +lat_0=37.85" + Pq + Lk + l + q + C + J + A2, 1, D + Po + " +lon_0=-87.95" + Ye + l + q + C + E + A2, 1, D + Po + " +lon_0=-87.95" + Ye + l + q + C + J + A2, 1, D + " +lat_0=39.7" + Oj + " +k=1.000044" + l + q + C + E + A2, 1, D + " +lat_0=39.7" + Oj + " +k=1.000044" + l + q + C + J + A2, 1, D + Yj + " +lon_0=-85.3" + OQ + l + q + C + E + A2, 1, D + Yj + " +lon_0=-85.3" + OQ + l + q + C + J + A2, 1, D + Yh + Up + Zn + l + q + C + E + A2, 1, D + Yh + Up + Zn + l + q + C + J + A2, 1, D + Po + " +lon_0=-87.05 +k=1.000014" + l + q + C + E + A2, 1, D + Po + " +lon_0=-87.05 +k=1.000014" + l + q + C + J + A2, 1, D + Fo + SA + " +k=1.000041" + l + q + C + E + A2, 1, D + Fo + SA + " +k=1.000041" + l + q + C + J + A2, 1, D + Yj + OS + " +k=1.000017" + l + q + C + E + A2, 1, D + Yj + OS + " +k=1.000017" + l + q + C + J + A2, 1, D + " +lat_0=40.2" + KZ + Ln + l + q + C + E + A2, 1, D + " +lat_0=40.2" + KZ + Ln + l + q + C + J + A2, 1, D + Yi + Su + Lk + l + q + C + E + A2, 1, D + Yi + Su + Lk + l + q + C + J + A2, 1, D + Ty + St + Og + l + q + C + E + A2, 1, D + Ty + St + Og + l + q + C + J + A2, 1, D + Pp + " +lon_0=-85.25" + Ll + l + q + C + E + A2, 1, D + Pp + " +lon_0=-85.25" + Ll + l + q + C + J + A2, 3, K + C + B + A2, 1, I2 + JM + C + B + E + A2, 1, I2 + Me + C + B + E + A2, 1, I2 + Rb + C + B + E + A2, 152, D + WY + Bu + " +k=1.0000365285 +x_0=147218.6942 +y_0=0.0037" + C + E + A2, 1, D + WZ + Uq + " +k=1.0000495683 +x_0=172821.9461 +y_0=0.0017" + C + E + A2, 1, D + Wa + Ur + " +k=1.0000486665 +x_0=93150 +y_0=0.0029" + C + E + A2, 1, H + Wb + Wc + Us + " +k_0=1.0000331195 +x_0=228600.4575 +y_0=148551.4837" + C + E + A2, 1, D + Nj + " +lon_0=-88" + Og + " +x_0=31600 +y_0=4600" + C + E + A2, 1, D + Wd + Ut + " +k=1.0000382778 +x_0=175260.3502 +y_0=0.0048" + C + E + A2, 1, H + We + Wf + Uu + " +k_0=1.0000383841 +x_0=64008.1276 +y_0=59445.9043" + C + E + A2, 1, D + Wg + " +lon_0=-88.5 +k=1.0000286569 +x_0=244754.8893 +y_0=0.0049" + C + E + A2, 1, H + Wh + Wi + Uv + " +k_0=1.0000391127 +x_0=60045.72 +y_0=44091.4346" + C + E + A2, 1, D + " +lat_0=43.6" + Uw + " +k=1.0000463003 +x_0=199949.1989 +y_0=0.0086" + C + E + A2, 1, H + Wj + Wk + Ux + " +k_0=1.00003498 +x_0=169164.3381 +y_0=111569.6134" + C + E + A2, 1, H + aQ + aR + Wl + " +k_0=1.0000349151 +x_0=113690.6274 +y_0=53703.1201" + C + E + A2, 1, H + Zs + Zt + Uy + " +k_0=1.0000384786 +x_0=247193.2944 +y_0=146591.9896" + C + E + A2, 1, D + Wm + Uz + " +k=1.0000346418 +x_0=263347.7263 +y_0=0.0076" + C + E + A2, 1, D + " +lat_0=44.4" + VA + " +k=1.0000187521 +x_0=158801.1176 +y_0=0.0023" + C + E + A2, 1, D + Wn + Oo + " +k=1.0000385418 +x_0=59131.3183 +y_0=0.0041" + C + E + A2, 1, D + Wo + VB + " +k=1.0000410324 +x_0=51816.104 +y_0=0.003" + C + E + A2, 1, H + Wp + Wq + VC + " +k_0=1.000035079 +x_0=120091.4402 +y_0=91687.92389999999" + C + E + A2, 1, D + Wr + VD + " +k=1.0000552095 +x_0=133502.6683 +y_0=0.0063" + C + E + A2, 1, D + Ws + VE + " +k=1.0000673004 +x_0=275844.5533 +y_0=0.0157" + C + E + A2, 1, D + Wt + " +lon_0=-90.8 +k=1.0000349452 +x_0=242316.4841 +y_0=0.01" + C + E + A2, 1, H + Wu + Wv + VF + " +k_0=1.0000390487 +x_0=170078.7403 +y_0=45830.2947" + C + E + A2, 1, H + Ww + Wx + Ka + " +k_0=1.0000344057 +x_0=150876.3018 +y_0=79170.7795" + C + E + A2, 1, D + Wy + VG + " +k=1.0000394961 +x_0=113081.0261 +y_0=0.0045" + C + E + A2, 1, D + Wz + VH + " +k=1.0000677153 +x_0=220980.4419 +y_0=0.008500000000000001" + C + E + A2, 1, D + XA + VI + " +k=1.0000353 +x_0=27000 +y_0=25000" + C + E + A2, 1, D + XB + VJ + " +k=1.0000260649 +x_0=185928.3728 +y_0=0.0009" + C + E + A2, 1, D + XC + Su + " +k=1.0000233704 +x_0=79857.7614 +y_0=0.0012" + C + E + A2, 1, D + XD + VK + " +k=1.0000319985 +x_0=130454.6598 +y_0=0.0033" + C + E + A2, 1, H + XE + XF + VL + " +k_0=1.0000627024 +x_0=198425.197 +y_0=105279.7829" + C + E + A2, 1, D + XG + VM + " +k=1.0000599003 +x_0=116129.0323 +y_0=0.0058" + C + E + A2, 1, H + XH + XI + " +lon_0=-89.77 +k_0=1.000053289 +x_0=74676.1493 +y_0=55049.2669" + C + E + A2, 1, D + XJ + VN + " +k=1.0000234982 +x_0=238658.8794 +y_0=0.0032" + C + E + A2, 1, D + XK + VO + " +k=1.0000362499 +x_0=105461.0121 +y_0=0.0029" + C + E + A2, 1, H + XL + XM + VP + " +k_0=1.0000434122 +x_0=204521.209 +y_0=121923.9861" + C + E + A2, 1, D + XN + VQ + " +k=1.0000236869 +x_0=182880.3676 +y_0=0.0033" + C + E + A2, 1, H + XO + XP + VR + " +k_0=1.0000686968 +x_0=70104.1401 +y_0=57588.0346" + C + E + A2, 1, H + XQ + XR + VS + " +k_0=1.0000362977 +x_0=167640.3354 +y_0=86033.0876" + C + E + A2, 1, D + XS + Kb + " +k=1.0000433849 +x_0=141732.2823 +y_0=0.0059" + C + E + A2, 1, H + XT + XU + " +lon_0=-89.5 +k_0=1.000039936 +x_0=56388.1128 +y_0=50022.1874" + C + E + A2, 1, D + XV + VT + " +k=1.0000649554 +x_0=227990.8546 +y_0=0.0109" + C + E + A2, 1, H + Zu + Zv + VU + " +k_0=1.0000375653 +x_0=202387.6048 +y_0=134255.4253" + C + E + A2, 1, D + XW + VV + " +k=1.0000337311 +x_0=146304.2926 +y_0=0.0068" + C + E + A2, 1, D + XX + VW + " +k=1.0000495976 +x_0=250546.1013 +y_0=0.0234" + C + E + A2, 1, D + XY + VX + " +k=1.0000373868 +x_0=185623.5716 +y_0=0.0051" + C + E + A2, 1, H + XZ + Xa + VY + " +k_0=1.0000573461 +x_0=216713.2336 +y_0=120734.1631" + C + E + A2, 1, D + LJ + VZ + " +k=1.000032144 +x_0=262433.3253 +y_0=0.009599999999999999" + C + E + A2, 1, D + LJ + Kb + " +k=1.0000381803 +x_0=165506.7302 +y_0=0.0103" + C + E + A2, 1, H + Xb + Xc + Va + " +k_0=1.0000597566 +x_0=187147.5744 +y_0=107746.7522" + C + E + A2, 1, D + Xd + Vb + " +k=1.0000361538 +x_0=256946.9138 +y_0=0.0041" + C + E + A2, 1, H + Xe + Xf + Vc + " +k_0=1.0000408158 +x_0=222504.4451 +y_0=47532.0602" + C + E + A2, 1, H + Xg + Xh + Vd + " +k_0=1.0000730142 +x_0=134417.0689 +y_0=50337.1092" + C + E + A2, 1, H + Xi + Xj + Ve + " +k_0=1.0000367192 +x_0=232562.8651 +y_0=111088.2224" + C + E + A2, 1, H + Xk + Xl + Vf + " +k_0=1.0000475376 +x_0=234086.8682 +y_0=188358.6058" + C + E + A2, 1, D + Xm + Vg + " +k=1.00003738 +x_0=120091.4415 +y_0=0.003" + C + E + A2, 1, D + Xn + Vh + " +k=1.0000346179 +x_0=208788.418 +y_0=0.0034" + C + E + A2, 1, D + Xo + Vi + " +k=1.0000333645 +x_0=185013.9709 +y_0=0.007" + C + E + A2, 1, H + Xp + Xq + Ka + " +k_0=1.0000392096 +x_0=120091.4402 +y_0=45069.7587" + C + E + A2, 1, H + Xr + Xs + Bu + " +k_0=1.0000421209 +x_0=208483.6173 +y_0=134589.754" + C + E + A2, 1, D + WY + Bu + " +k=1.0000365285 +x_0=147218.6941325883 +y_0=0.00365760731521463" + C + J + A2, 1, D + WZ + Uq + " +k=1.0000495683 +x_0=172821.945948692 +y_0=0.001828803657607315" + C + J + A2, 1, D + Wa + Ur + " +k=1.0000486665 +x_0=93150" + IX + C + J + A2, 1, H + Wb + Wc + Us + " +k_0=1.0000331195 +x_0=228600.4575057151 +y_0=148551.4835661671" + C + J + A2, 1, D + Nj + " +lon_0=-88" + Og + " +x_0=31599.99989839979 +y_0=4599.999898399797" + C + J + A2, 1, D + Wd + Ut + " +k=1.0000382778 +x_0=175260.3502159004" + Vj + C + J + A2, 1, H + We + Wf + Uu + " +k_0=1.0000383841 +x_0=64008.12771145543 +y_0=59445.90419100838" + C + J + A2, 1, D + Wg + " +lon_0=-88.5 +k=1.0000286569 +x_0=244754.8892049784" + Vj + C + J + A2, 1, H + Wh + Wi + Uv + " +k_0=1.0000391127 +x_0=60045.72009144018 +y_0=44091.43449326898" + C + J + A2, 1, D + " +lat_0=43.6" + Uw + " +k=1.0000463003 +x_0=199949.198983998" + Vk + C + J + A2, 1, H + Wj + Wk + Ux + " +k_0=1.00003498 +x_0=169164.338023876 +y_0=111569.613512827" + C + J + A2, 1, H + aQ + aR + Wl + " +k_0=1.0000349151 +x_0=113690.6273812548 +y_0=53703.12024384048" + C + J + A2, 1, H + Zs + Zt + Uy + " +k_0=1.0000384786 +x_0=247193.2943865888 +y_0=146591.9896367793" + C + J + A2, 1, D + Wm + Uz + " +k=1.0000346418 +x_0=263347.7263906528 +y_0=0.00762001524003048" + C + J + A2, 1, D + " +lat_0=44.4" + VA + " +k=1.0000187521 +x_0=158801.1176022352 +y_0=0.002438404876809754" + C + J + A2, 1, D + Wn + Oo + " +k=1.0000385418 +x_0=59131.31826263652" + Vl + C + J + A2, 1, D + Wo + VB + " +k=1.0000410324 +x_0=51816.10393700787" + IX + C + J + A2, 1, H + Wp + Wq + VC + " +k_0=1.000035079" + Ys + " +y_0=91687.92390144781" + C + J + A2, 1, D + Wr + VD + " +k=1.0000552095 +x_0=133502.6682245364 +y_0=0.006400812801625603" + C + J + A2, 1, D + Ws + VE + " +k=1.0000673004 +x_0=275844.5532131065 +y_0=0.0158496316992634" + C + J + A2, 1, D + Wt + " +lon_0=-90.8 +k=1.0000349452 +x_0=242316.484023368 +y_0=0.01005842011684023" + C + J + A2, 1, H + Wu + Wv + VF + " +k_0=1.0000390487 +x_0=170078.7401574803 +y_0=45830.29484378968" + C + J + A2, 1, H + Ww + Wx + Ka + " +k_0=1.0000344057 +x_0=150876.3017526035 +y_0=79170.77937515875" + C + J + A2, 1, D + Wy + VG + " +k=1.0000394961 +x_0=113081.0261620523 +y_0=0.004572009144018288" + C + J + A2, 1, D + Wz + VH + " +k=1.0000677153 +x_0=220980.4419608839" + Vk + C + J + A2, 1, D + XA + VI + " +k=1.0000353 +x_0=27000 +y_0=24999.99989839979" + C + J + A2, 1, D + XB + VJ + " +k=1.0000260649 +x_0=185928.3727711455 +y_0=0.0009144018288036576" + C + J + A2, 1, D + XC + Su + " +k=1.0000233704 +x_0=79857.76154432308 +y_0=0.001219202438404877" + C + J + A2, 1, D + XD + VK + " +k=1.0000319985 +x_0=130454.6596901194" + Op + C + J + A2, 1, H + XE + XF + VL + " +k_0=1.0000627024 +x_0=198425.1968503937 +y_0=105279.7828803657" + C + J + A2, 1, D + XG + VM + " +k=1.0000599003 +x_0=116129.0322580645" + Vm + C + J + A2, 1, H + XH + XI + " +lon_0=-89.77 +k_0=1.000053289 +x_0=74676.1493522987 +y_0=55049.26695453391" + C + J + A2, 1, D + XJ + VN + " +k=1.0000234982 +x_0=238658.8794513589" + IX + C + J + A2, 1, D + XK + VO + " +k=1.0000362499 +x_0=105461.0121412243" + IX + C + J + A2, 1, H + XL + XM + VP + " +k_0=1.0000434122 +x_0=204521.2090424181 +y_0=121923.9861823724" + C + J + A2, 1, D + XN + VQ + " +k=1.0000236869 +x_0=182880.3675895352" + Op + C + J + A2, 1, H + XO + XP + VR + " +k_0=1.0000686968 +x_0=70104.14020828041 +y_0=57588.03474726949" + C + J + A2, 1, H + XQ + XR + VS + " +k_0=1.0000362977 +x_0=167640.3352806706 +y_0=86033.08773177546" + C + J + A2, 1, D + XS + Kb + " +k=1.0000433849 +x_0=141732.2822453645" + Vm + C + J + A2, 1, H + XT + XU + " +lon_0=-89.5 +k_0=1.000039936 +x_0=56388.11277622555 +y_0=50022.1874523749" + C + J + A2, 1, D + XV + VT + " +k=1.0000649554 +x_0=227990.8544577089 +y_0=0.01097282194564389" + C + J + A2, 1, H + Zu + Zv + VU + " +k_0=1.0000375653 +x_0=202387.6047752095 +y_0=134255.4254508509" + C + J + A2, 1, D + XW + VV + " +k=1.0000337311 +x_0=146304.2926085852 +y_0=0.006705613411226822" + C + J + A2, 1, D + XX + VW + " +k=1.0000495976 +x_0=250546.1013970028 +y_0=0.02346964693929388" + C + J + A2, 1, D + XY + VX + " +k=1.0000373868 +x_0=185623.5715519431 +y_0=0.005181610363220727" + C + J + A2, 1, H + XZ + Xa + VY + " +k_0=1.0000573461 +x_0=216713.2337312675 +y_0=120734.1631699263" + C + J + A2, 1, D + LJ + VZ + " +k=1.000032144 +x_0=262433.3251714504 +y_0=0.009448818897637795" + C + J + A2, 1, D + LJ + Kb + " +k=1.0000381803 +x_0=165506.7300990602 +y_0=0.01036322072644145" + C + J + A2, 1, H + Xb + Xc + Va + " +k_0=1.0000597566 +x_0=187147.5742951486 +y_0=107746.7521463043" + C + J + A2, 1, D + Xd + Vb + " +k=1.0000361538 +x_0=256946.9138938278" + Vl + C + J + A2, 1, H + Xe + Xf + Vc + " +k_0=1.0000408158 +x_0=222504.44500889 +y_0=47532.0603505207" + C + J + A2, 1, H + Xg + Xh + Vd + " +k_0=1.0000730142 +x_0=134417.0688341377 +y_0=50337.10927101854" + C + J + A2, 1, H + Xi + Xj + Ve + " +k_0=1.0000367192 +x_0=232562.8651257302 +y_0=111088.2224028448" + C + J + A2, 1, H + Xk + Xl + Vf + " +k_0=1.0000475376 +x_0=234086.8681737363 +y_0=188358.6059436119" + C + J + A2, 1, D + Xm + Vg + " +k=1.00003738 +x_0=120091.4414020828" + IX + C + J + A2, 1, D + Xn + Vh + " +k=1.0000346179 +x_0=208788.4178816358" + Op + C + J + A2, 1, D + Xo + Vi + " +k=1.0000333645 +x_0=185013.9709423419 +y_0=0.007010414020828041" + C + J + A2, 1, H + Xp + Xq + Ka + " +k_0=1.0000392096" + Ys + " +y_0=45069.7588011176" + C + J + A2, 1, H + Xr + Xs + Bu + " +k_0=1.0000421209 +x_0=208483.6172720346 +y_0=134589.7539243078" + C + J + A2, 41, K + C + A2, 6, D + L3 + " +lon_0=68.51666666666667 +k=1 +x_0=1300000" + RX + C + E + A2, 1, D + L3 + " +lon_0=71.51666666666667 +k=1" + aB + RX + C + E + A2, 1, D + L3 + " +lon_0=74.51666666666667 +k=1" + aC + RX + C + E + A2, 1, D + L3 + " +lon_0=77.51666666666667 +k=1" + aD + RX + C + E + A2, 1, D + L3 + " +lon_0=80.51666666666667 +k=1 +x_0=5300000" + RX + C + E + A2, 12308, D + L3 + Gl + " +k=1" + DP + N + M + G + E + A2, 1, D + L3 + HO + " +k=1" + Eg + N + M + G + E + A2, 1, D + L3 + IG + " +k=1" + Jt + N + M + G + E + A2, 1, D + L3 + LN + " +k=1" + IM + N + M + G + E + A2, 1, D + L3 + JS + " +k=1" + MS + N + M + G + E + A2, 1, D + L3 + PS + " +k=1" + MT + N + M + G + E + A2, 1, D + L3 + RL + " +k=1" + LY + N + M + G + E + A2, 1, D + L3 + QW + " +k=1" + Jp + N + M + G + E + A2, 1, D + L3 + RM + " +k=1" + LZ + N + M + G + E + A2, 1, D + L3 + HP + " +k=1" + HU + N + M + G + E + A2, 1, D + L3 + HQ + " +k=1" + Gw + N + M + G + E + A2, 1, D + L3 + Hd + " +k=1" + Hu + N + M + G + E + A2, 1, D + L3 + HR + " +k=1" + Hv + N + M + G + E + A2, 1, D + L3 + HS + " +k=1" + It + N + M + G + E + A2, 1, D + L3 + EN + " +k=1" + Hs + N + M + G + E + A2, 1, D + L3 + Fy + " +k=1" + Ht + N + M + G + E + A2, 1, D + L3 + Fm + " +k=1" + HV + N + M + G + E + A2, 1, D + L3 + Fr + " +k=1" + Hw + N + M + G + E + A2, 1, D + L3 + Ed + " +k=1" + HW + N + M + G + E + A2, 1, D + L3 + Fn + " +k=1" + Hx + N + M + G + E + A2, 1, D + L3 + Pf + " +k=1" + La + N + M + G + E + A2, 1, D + L3 + Od + " +k=1" + Hy + N + M + G + E + A2, 1, D + L3 + NY + " +k=1" + Hz + N + M + G + E + A2, 1, D + L3 + Pg + " +k=1" + IA + N + M + G + E + A2, 1, D + L3 + NZ + " +k=1" + IB + N + M + G + E + A2, 1, D + L3 + Lf + " +k=1" + Gx + N + M + G + E + A2, 1, D + L3 + KG + " +k=1" + IT + N + M + G + E + A2, 1, D + L3 + KH + " +k=1" + Gc + N + M + G + E + A2, 1, D + L3 + Lh + " +k=1" + IU + N + M + G + E + A2, 103, I2 + Ki + c + HX + E + A2, 1, I2 + Mf + c + HX + E + A2, 1, I2 + KD + c + HX + E + A2, 1, I2 + JZ + c + HX + E + A2, 111, I2 + Mi + o + x + r + E + A2, 1, I2 + NS + o + x + r + E + A2, 1, I2 + Mg + o + x + r + E + A2, 1, I2 + NT + o + x + r + E + A2, 1, I2 + Ot + o + x + r + E + A2, 1, I2 + Nv + o + x + r + E + A2, 1, I2 + PM + o + x + r + E + A2, 1, I2 + Re + o + x + r + E + A2, 1, I2 + SM + o + x + r + E + A2, 1, I2 + MA + o + x + r + E + A2, 91, I2 + Mi + o + x + CB + E + A2, 1, I2 + NS + o + x + CB + E + A2, 1, I2 + Mg + o + x + CB + E + A2, 1, I2 + NT + o + x + CB + E + A2, 1, I2 + Ot + o + x + CB + E + A2, 1, I2 + Nv + o + x + CB + E + A2, 1, I2 + PM + o + x + CB + E + A2, 1, I2 + Re + o + x + CB + E + A2, 80, I2 + Mf + R + Cm + E + A2, 1, I2 + KD + R + Cm + E + A2, 1, I2 + JZ + R + Cm + E + A2, 1, I2 + JM + R + Cm + E + A2, 1, I2 + Me + R + Cm + E + A2, 59, I2 + JM + R + Cm + E + A2, 39, I2 + JZ + M + NL + E + A2, 1, I2 + JM + M + NL + E + A2, 251, D + BY + " +lon_0=1 +k=1" + h + Hk + R + EV + Zb + E + A2, 1, D + BY + " +lon_0=1 +k=1" + s + N + R + EV + Zb + E + A2, 31, I2 + Io + o + R + Ec + E + A2, 1, I2 + MB + o + R + Ec + E + A2, 1, I2 + Nx + o + R + Ec + E + A2, 110, I2 + NR + o + Bc + BS + In + E + A2, 1, I2 + Ki + o + Bc + BS + In + E + A2, 1, I2 + Mf + o + Bc + BS + In + E + A2, 99, I2 + Ki + o + c + ER + E + A2, 1, I2 + Mf + o + c + ER + E + A2, 1, I2 + KD + o + c + ER + E + A2, 58, I2 + Ki + c + ER + E + A2, 1, I2 + Mf + c + ER + E + A2, 1, I2 + KD + c + ER + E + A2, 51, I2 + Mh + o + Y + Cj + E + A2, 1, I2 + Mi + o + Y + Cj + E + A2, 1, I2 + NS + o + Y + Cj + E + A2, 141, D + L3 + NU + EP + u + N + c + Jw + E + A2, 1, D + " +lat_0=13.17638888888889 +lon_0=-59.55972222222222 +k=0.9999986" + Zl + " +y_0=75000" + c + Jw + E + A2, 121, D + L3 + HP + " +k=1" + HU + N + M + U + E + A2, 1, D + L3 + HQ + " +k=1" + Gw + N + M + U + E + A2, 1, D + L3 + Hd + " +k=1" + Hu + N + M + U + E + A2, 1, D + L3 + HR + " +k=1" + Hv + N + M + U + E + A2, 1, D + L3 + HS + " +k=1" + It + N + M + U + E + A2, 1, D + L3 + EN + " +k=1" + Hs + N + M + U + E + A2, 1, D + L3 + Fy + " +k=1" + Ht + N + M + U + E + A2, 1, D + L3 + Fm + " +k=1" + HV + N + M + U + E + A2, 1, D + L3 + Fr + " +k=1" + Hw + N + M + U + E + A2, 1, D + L3 + Ed + " +k=1" + HW + N + M + U + E + A2, 1, D + L3 + Fn + " +k=1" + Hx + N + M + U + E + A2, 30, D + L3 + HP + " +k=1" + O2 + N + M + U + E + A2, 1, D + L3 + HQ + " +k=1" + O2 + N + M + U + E + A2, 1, D + L3 + Hd + " +k=1" + O2 + N + M + U + E + A2, 1, D + L3 + HR + " +k=1" + O2 + N + M + U + E + A2, 1, D + L3 + HS + " +k=1" + O2 + N + M + U + E + A2, 1, D + L3 + EN + " +k=1" + O2 + N + M + U + E + A2, 1, D + L3 + Fy + " +k=1" + O2 + N + M + U + E + A2, 1, D + L3 + Fm + " +k=1" + O2 + N + M + U + E + A2, 1, D + L3 + Fr + " +k=1" + O2 + N + M + U + E + A2, 1, D + L3 + Ed + " +k=1" + O2 + N + M + U + E + A2, 1, D + L3 + Fn + " +k=1" + O2 + N + M + U + E + A2, 37, H + Ks + Kt + Hr + HN + Bn + " +y_0=5400000" + R + " +pm=brussels" + E + A2, 280, Pu + Kj + HN + " +k_0=1" + s + N + Y + Gf + " +pm=bern" + E + A2, 1, Pu + Kj + Ow + " +k_0=1" + a + IK + Y + Gf + E + A2, 1, Pu + Kj + Ow + " +k_0=1" + s + N + Y + Gf + E + A2, 36, I2 + IC + R + ES + E + A2, 78, D + LK + " +lon_0=-77.08091666666667 +k=1" + BZ + AH + R + ES + E + A2, 1, D + LK + " +lon_0=-74.08091666666667 +k=1" + BZ + AH + R + ES + E + A2, 1, D + LK + " +lon_0=-71.08091666666667 +k=1" + BZ + AH + R + ES + E + A2, 1, D + LK + " +lon_0=-68.08091666666667 +k=1" + BZ + AH + R + ES + E + A2, 133, I2 + JN + o + c + GO + E + A2, 1, I2 + KC + o + c + GO + E + A2, 58, D + L3 + " +lon_0=11.5" + AP + O2 + Ak + c + GO + E + A2, 1, D + L3 + IH + AP + O2 + Ak + c + GO + E + A2, 79, D + m + UQ + " +k=1" + AV + N + C + B + E + A2, 1, D + m + MP + " +k=1" + Ci + N + C + B + E + A2, 1, D + m + Pe + " +k=1" + Bo + N + C + B + E + A2, 1, D + m + Qk + " +k=1" + DP + N + C + B + E + A2, 1, D + m + US + " +k=1" + Eg + N + C + B + E + A2, 1, D + m + Zc + " +k=1" + Jt + N + C + B + E + A2, 1, D + m + Nb + " +k=1" + IM + N + C + B + E + A2, 4, D + m + UQ + " +k=1" + AV + N + j + B + E + A2, 1, D + m + MP + " +k=1" + Ci + N + j + B + E + A2, 1, D + m + Pe + " +k=1" + Bo + N + j + B + E + A2, 1, D + m + Qk + " +k=1" + DP + N + j + B + E + A2, 1, D + m + US + " +k=1" + Eg + N + j + B + E + A2, 1, D + m + Zc + " +k=1" + Jt + N + j + B + E + A2, 1, D + m + Nb + " +k=1" + IM + N + j + B + E + A2, 4, D + m + UQ + " +k=1" + AV + N + R + Bs + E + A2, 1, D + m + MP + " +k=1" + Ci + N + R + Bs + E + A2, 1, D + m + Pe + " +k=1" + Bo + N + R + Bs + E + A2, 1, D + m + Qk + " +k=1" + DP + N + R + Bs + E + A2, 1, D + m + US + " +k=1" + Eg + N + R + Bs + E + A2, 1, D + m + Zc + " +k=1" + Jt + N + R + Bs + E + A2, 1, D + m + Nb + " +k=1" + IM + N + R + Bs + E + A2, 37, I2 + NR + o + Bc + BS + Ax + E + A2, 1, I2 + Ki + o + Bc + BS + Ax + E + A2, 40, D + L3 + Gj + " +k=1" + s + N + Gk + Bc + BS + Ax + E + A2, 2, D + L3 + UE + " +k=1" + s + N + Gk + Bc + BS + Ax + E + A2, 2, D + L3 + RI + " +k=1" + s + N + Gk + Bc + BS + Ax + E + A2, 2, D + L3 + Gl + " +k=1" + s + N + Gk + Bc + BS + Ax + E + A2, 2, D + L3 + SP + " +k=1" + s + N + Gk + Bc + BS + Ax + E + A2, 2, D + L3 + RJ + " +k=1" + s + N + Gk + Bc + BS + Ax + E + A2, 2, D + L3 + HO + " +k=1" + s + N + Gk + Bc + BS + Ax + E + A2, 2, D + L3 + " +lon_0=29 +k=1" + s + N + Gk + Bc + BS + Ax + E + A2, 2, D + L3 + QQ + " +k=1" + s + N + Gk + Bc + BS + Ax + E + A2, 2, D + L3 + IG + " +k=1" + s + N + Gk + Bc + BS + Ax + E + A2, 39, I2 + JN + AU + BN + Gi + E + A2, 59, H + " +lat_1=36" + GM + " +lon_0=9.9" + QL + O2 + Hk + AU + BN + Gi + E + A2, 1, H + Sd + Se + " +lon_0=9.9" + Nk + O2 + Hk + AU + BN + Gi + E + A2, 129, I2 + ID + o + R + GR + E + A2, 1, I2 + Io + o + R + GR + E + A2, 1, I2 + MB + o + R + GR + E + A2, 1, I2 + Nx + o + R + GR + E + A2, 1, I2 + Nr + o + R + GR + E + A2, 175, H + aL + " +lat_0=34.65 +lon_0=37.35 +k_0=0.9996256" + AI + Hk + AU + BN + HI + E + A2, 70, H + aL + " +lat_0=34.65 +lon_0=37.35 +k_0=0.9996256" + AI + Hk + AU + BN + HI + E + A2, 10, GU + " +lat_0=34.2 +lon_0=39.15 +k=0.9995341" + s + N + AU + BN + HI + E + A2, 211, D + Gm + " +lon_0=35 +k=1" + AI + " +y_0=1100000" + Gn + HY + E + A2, 1, D + Gm + QQ + " +k=1 +x_0=615000 +y_0=810000" + Gn + HY + E + A2, 1, D + Gm + HO + " +k=1" + EW + IK + Gn + HY + E + A2, 1, D + Gm + HO + " +k=1" + EW + Tj + Gn + HY + E + A2, 34, I2 + Ja + R + n + E + A2, 1, I2 + KA + R + n + E + A2, 1, I2 + Oq + R + n + E + A2, 1, I2 + QD + R + n + E + A2, 1, I2 + JN + R + n + E + A2, 1, I2 + KC + R + n + E + A2, 1, I2 + NR + R + n + E + A2, 1, I2 + Ki + R + n + E + A2, 1, I2 + Mf + R + n + E + A2, 1, I2 + KD + R + n + E + A2, 1, I2 + JZ + R + n + E + A2, 52, D + L3 + HN + AP + O2 + N + R + n + E + A2, 5, D + L3 + " +lon_0=5" + AP + O2 + N + R + n + E + A2, 144, I2 + JM + c + NM + E + A2, 1, I2 + Me + c + NM + E + A2, 460, Pu + " +lat_0=47.14439372222222 +lon_0=19.04857177777778 +k_0=0.99993 +x_0=650000" + IK + aK + RE + E + A2, 130, D + L3 + " +lon_0=94.5" + V2 + h + DQ + j + B + E + A2, 1, D + L3 + " +lon_0=97.5" + V2 + h + DQ + j + B + E + A2, 1, D + L3 + " +lon_0=100.5" + V2 + h + DQ + j + B + E + A2, 1, D + L3 + " +lon_0=103.5" + V2 + h + DQ + j + B + E + A2, 1, D + L3 + " +lon_0=106.5" + V2 + h + DQ + j + B + E + A2, 1, D + L3 + " +lon_0=109.5" + V2 + h + DQ + j + B + E + A2, 1, D + L3 + " +lon_0=112.5" + V2 + h + DQ + j + B + E + A2, 1, D + L3 + " +lon_0=115.5" + V2 + h + DQ + j + B + E + A2, 1, D + L3 + " +lon_0=118.5" + V2 + h + DQ + j + B + E + A2, 1, D + L3 + " +lon_0=121.5" + V2 + h + DQ + j + B + E + A2, 1, D + L3 + " +lon_0=124.5" + V2 + h + DQ + j + B + E + A2, 1, D + L3 + Pj + V2 + h + DQ + j + B + E + A2, 1, D + L3 + " +lon_0=130.5" + V2 + h + DQ + j + B + E + A2, 1, D + L3 + Tk + V2 + h + DQ + j + B + E + A2, 1, D + L3 + " +lon_0=136.5" + V2 + h + DQ + j + B + E + A2, 1, D + L3 + " +lon_0=139.5" + V2 + h + DQ + j + B + E + A2, 1, I2 + QF + IR + Bh + Av + E + A2, 1, I2 + Ny + IR + Bh + Av + E + A2, 1, I2 + Mh + IR + Bh + Av + E + A2, 1, I2 + Mi + IR + Bh + Av + E + A2, 1, I2 + NS + IR + Bh + Av + E + A2, 1, I2 + Mg + IR + Bh + Av + E + A2, 1, I2 + NT + IR + Bh + Av + E + A2, 14, I2 + QF + j + B + E + A2, 1, I2 + Ny + j + B + E + A2, 1, I2 + Mh + j + B + E + A2, 1, I2 + Mi + j + B + E + A2, 1, I2 + NS + j + B + E + A2, 1, I2 + Mg + j + B + E + A2, 1, I2 + NT + j + B + E + A2, 5, I2 + Ny + o + j + B + E + A2, 1, I2 + Mh + o + j + B + E + A2, 1, I2 + Mi + o + j + B + E + A2, 1, I2 + NS + o + j + B + E + A2, 1, I2 + Mg + o + j + B + E + A2, 1, I2 + NT + o + j + B + E + A2, 1, I2 + Ot + o + j + B + E + A2, 1, I2 + Nv + o + j + B + E + A2, 3, I2 + Ny + o + IR + Bh + Av + E + A2, 1, I2 + Mh + o + IR + Bh + Av + E + A2, 1, I2 + Mi + o + IR + Bh + Av + E + A2, 1, I2 + NS + o + IR + Bh + Av + E + A2, 1, I2 + Mg + o + IR + Bh + Av + E + A2, 1, I2 + NT + o + IR + Bh + Av + E + A2, 1, I2 + Ot + o + IR + Bh + Av + E + A2, 1, I2 + Nv + o + IR + Bh + Av + E + A2, 52, I2 + QF + By + Ay + JR + E + A2, 1, I2 + Ny + By + Ay + JR + E + A2, 1, I2 + Mh + By + Ay + JR + E + A2, 99, I2 + Ny + By + Ay + NN + E + A2, 1, I2 + Mh + By + Ay + NN + E + A2, 52, H + " +lat_1=18" + OX + Ld + " +k_0=1 +x_0=167638.49597 +y_0=121918.90616" + RB + RC + ML + A2, 100, H + " +lat_1=18" + OX + Ld + " +k_0=1" + Bv + " +y_0=150000" + i + TG + E + A2, 105, I2 + Te + By + Ay + JQ + E + A2, 1, I2 + QF + By + Ay + JQ + E + A2, 5, I2 + Rb + Lp + Hp + GQ + E + A2, 1, I2 + Rc + Lp + Hp + GQ + E + A2, 1, I2 + SO + Lp + Hp + GQ + E + A2, 29, I2 + Rc + Go + CT + BT + E + A2, 1, I2 + SO + Go + CT + BT + E + A2, 1, I2 + Td + Go + CT + BT + E + A2, 1, I2 + Te + Go + CT + BT + E + A2, 1, I2 + QF + Go + CT + BT + E + A2, 1, I2 + Ny + Go + CT + BT + E + A2, 23, H + Sc + " +lat_0=39.5 +lon_0=68 +k_0=0.99846154 +x_0=2153865.73916853 +y_0=2368292.194628102" + HK + Gv + GT + A2, 1, H + Qq + Li + " +lon_0=68" + Fz + JX + JY + HK + Gv + GT + A2, 1, H + UM + IQ + " +lon_0=74" + Fz + JX + JY + HK + Gv + GT + A2, 1, H + " +lat_1=19 +lat_0=19 +lon_0=80" + Fz + JX + JY + HK + Gv + GT + A2, 1, H + " +lat_1=12 +lat_0=12 +lon_0=80" + Fz + JX + JY + HK + Gv + GT + A2, 1, H + UM + IQ + Hq + Fz + " +x_0=2743185.69 +y_0=914395.23" + By + Ay + JQ + E + A2, 1, H + Qq + Li + " +lon_0=68" + Fz + " +x_0=2743196.4 +y_0=914398.8" + Lp + Hp + GQ + E + A2, 1, H + UM + IQ + " +lon_0=74" + Fz + " +x_0=2743196.4 +y_0=914398.8" + Lp + Hp + GQ + E + A2, 1, H + Qq + Li + " +lon_0=68" + Fz + PX + Qa + Go + CT + BT + E + A2, 1, H + UM + IQ + " +lon_0=74" + Fz + PX + Qa + Go + CT + BT + E + A2, 1, H + UM + IQ + Hq + Fz + PX + Qa + Go + CT + BT + E + A2, 1, H + " +lat_1=19 +lat_0=19 +lon_0=80" + Fz + PX + Qa + Go + CT + BT + E + A2, 1, H + UM + IQ + Hq + Fz + JX + JY + HK + Gv + GT + A2, 1, H + " +lat_1=12 +lat_0=12 +lon_0=80" + Fz + PX + Qa + Go + CT + BT + E + A2, 117, Ck + " +lat_0=1.287646666666667 +lon_0=103.8530022222222" + Zl + " +y_0=30000" + GL + Bz + BV + E + A2, 47, I2 + Ny + GL + Bz + BV + E + A2, 1, I2 + Mh + GL + Bz + BV + E + A2, 52, H + Qq + Li + JS + PZ + AV + aG + c + Qh + E + A2, 118, I2 + IC + R + Hc + E + A2, 1, I2 + Hi + R + Hc + E + A2, 1, I2 + Gz + R + Hc + E + A2, 97, I2 + Ik + R + AX + E + A2, 1, I2 + IC + R + AX + E + A2, 1, I2 + Hi + R + AX + E + A2, 1, I2 + Gz + R + AX + E + A2, 1, I2 + ID + R + AX + E + A2, 56, I2 + Ik + o + R + AX + E + A2, 1, I2 + IC + o + R + AX + E + A2, 1, I2 + Hi + o + R + AX + E + A2, 1, I2 + Gz + o + R + AX + E + A2, 1, I2 + ID + o + R + AX + E + A2, 1, I2 + Io + o + R + AX + E + A2, 9, D + " +lat_0=-6 +lon_0=-80.5 +k=0.99983008 +x_0=222000 +y_0=1426834.743" + R + AX + E + A2, 1, D + " +lat_0=-9.5 +lon_0=-76 +k=0.99932994 +x_0=720000 +y_0=1039979.159" + R + AX + E + A2, 1, D + " +lat_0=-9.5" + IL + " +k=0.99952992 +x_0=1324000 +y_0=1040084.558" + R + AX + E + A2, 107, D + Vp + " +lon_0=-1" + Rv + " +x_0=274319.51" + N + c + TR + E + A2, 231, I2 + QD + AU + BN + E + A2, 160, D + L3 + Fm + CP + O2 + N + i + GC + E + A2, 1, D + L3 + ZU + CP + O2 + N + i + GC + E + A2, 1, D + L3 + ZV + CP + O2 + N + i + GC + E + A2, 1, D + L3 + Fr + CP + O2 + N + i + GC + E + A2, 1, D + L3 + Ru + CP + O2 + N + i + GC + E + A2, 433, I2 + Ja + C + B + E + A2, 1, I2 + KA + C + B + E + A2, 1, I2 + Oq + C + B + E + A2, 1, I2 + QD + C + B + E + A2, 1, I2 + JN + C + B + E + A2, 1, I2 + KC + C + B + E + A2, 1, I2 + NR + C + B + E + A2, 1, I2 + Ki + C + B + E + A2, 1, I2 + Mf + C + B + E + A2, 1, I2 + KD + C + B + E + A2, 47, D + L3 + II + AP + O2 + N + C + B + E + A2, 48, I2 + JN + o + R + Qd + E + A2, 259, H + Sd + Se + Yk + Nk + O2 + Hk + AU + BN + IO + E + A2, 1, H + " +lat_1=29.7 +lat_0=29.7" + Yk + " +k_0=0.9996155960000001" + O2 + Hk + AU + BN + IO + E + A2, 2, H + " +lat_1=26.1 +lat_0=26.1" + Yk + " +k_0=0.999616304 +x_0=1200000" + Is + AU + BN + IO + E + A2, 1, H + " +lat_1=22.5 +lat_0=22.5" + Yk + " +k_0=0.999616437" + AV + Is + AU + BN + IO + E + A2, 42, I2 + KD + Y + Tc + E + A2, 94, I2 + QD + c + GS + E + A2, 1, I2 + JN + c + GS + E + A2, 59, D + Qi + " +lon_0=4.5" + Rv + " +x_0=230738.26" + N + c + GS + E + A2, 1, D + Qi + " +lon_0=8.5" + Rv + " +x_0=670553.98" + N + c + GS + E + A2, 1, D + Qi + " +lon_0=12.5" + Rv + " +x_0=1110369.7" + N + c + GS + E + A2, 239, I2 + JN + AU + BN + NO + E + A2, 60, I2 + JN + o + AU + BN + NO + E + A2, 9, I2 + SK + X + E + A2, 1, I2 + TV + X + E + A2, 1, I2 + Xz + X + E + A2, 1, I2 + TY + X + E + A2, 1, I2 + RG + X + E + A2, 1, I2 + Ro + X + E + A2, 1, I2 + RH + X + E + A2, 1, I2 + TW + X + E + A2, 1, I2 + TX + X + E + A2, 1, I2 + QE + X + E + A2, 1, I2 + Ns + X + E + A2, 1, I2 + Nt + X + E + A2, 1, I2 + Nu + X + E + A2, 1, I2 + Nw + X + E + A2, 1, I2 + NP + X + E + A2, 1, I2 + NQ + X + E + A2, 1, I2 + Ik + X + E + A2, 1, I2 + IC + X + E + A2, 1, I2 + Hi + X + E + A2, 1, I2 + Gz + X + E + A2, 1, I2 + ID + X + E + A2, 1, I2 + Io + X + E + A2, 7, D + IY + IV + Pc + e + N + X + J + A2, 1, D + Gm + OS + BG + e + N + X + J + A2, 1, CU + " +lat_0=57" + Ku + Kv + V2 + " +x_0=5000000.001016002 +y_0=-5000000.001016002" + KE + GZ + X + J + A2, 1, D + Ft + YN + V2 + e + N + X + J + A2, 1, D + Ft + YO + V2 + e + N + X + J + A2, 1, D + Ft + ON + V2 + e + N + X + J + A2, 1, D + Ft + Ms + V2 + e + N + X + J + A2, 1, D + Ft + KI + V2 + e + N + X + J + A2, 1, D + Ft + YP + V2 + " +x_0=213360.4267208534" + N + X + J + A2, 1, D + Ft + YQ + V2 + e + N + X + J + A2, 1, D + Ft + SW + V2 + Px + N + X + J + A2, 1, H + Kw + Kx + UK + YR + Bw + N + X + J + A2, 1, H + DW + Jn + y + HA + Z2 + N + X + J + A2, 1, H + DX + DY + AA + HA + Z2 + N + X + J + A2, 1, H + Ap + DZ + Ml + AJ + Z2 + N + X + J + A2, 1, H + LO + QS + Da + Mm + Z2 + N + X + J + A2, 1, H + Db + Dc + Mn + Ir + Z2 + N + X + J + A2, 1, H + Dd + De + Df + Iw + Z2 + N + X + J + A2, 2, D + Bl + Cn + V2 + e + N + X + J + A2, 1, D + Bl + Co + V2 + e + N + X + J + A2, 1, D + Bl + Iv + BG + e + N + X + J + A2, 1, H + Dx + Dy + BC + IF + Z2 + N + X + J + A2, 1, H + Dz + Mq + EA + IF + Z2 + N + X + J + A2, 1, H + " +lat_1=39.71666666666667 +lat_2=40.78333333333333" + y + Ba + Z2 + N + X + J + A2, 1, H + LP + LQ + CY + Ba + Z2 + N + X + J + A2, 1, H + Ap + Dg + f + Ba + Z2 + N + X + J + A2, 1, H + Dh + Mo + Di + Jq + Px + N + X + J + A2, 1, D + Ch + Cp + Mp + e + N + X + J + A2, 1, D + Aq + CR + Am + e + N + X + J + A2, 1, D + Aq + Ob + Am + e + N + X + J + A2, 1, H + LR + Dj + QT + LS + Z2 + N + X + J + A2, 6, D + Gm + Cq + V2 + e + N + X + J + A2, 1, D + Gm + Cr + V2 + e + N + X + J + A2, 1, D + p + Cs + BJ + e + N + X + J + A2, 1, D + p + Jb + BJ + e + N + X + J + A2, 1, D + p + Ix + BG + e + N + X + J + A2, 1, D + f + Cz + EQ + e + N + X + J + A2, 1, D + f + DA + Am + e + N + X + J + A2, 1, D + DM + DB + AO + e + N + X + J + A2, 1, D + DM + DC + AO + e + N + X + J + A2, 1, H + EB + EC + Fo + GG + Z2 + N + X + J + A2, 1, H + AY + ED + Fs + GG + Z2 + N + X + J + A2, 1, H + EE + EF + AQ + Fl + Z2 + N + X + J + A2, 1, H + EG + EH + f + CV + Z2 + N + X + J + A2, 1, H + Az + DV + DM + Jo + Z2 + N + X + J + A2, 1, H + " +lat_1=36.73333333333333 +lat_2=37.93333333333333" + AB + EY + Z2 + N + X + J + A2, 1, H + " +lat_1=31.16666666666667 +lat_2=32.66666666666666 +lat_0=30.66666666666667" + Hg + Z2 + N + X + J + A2, 1, H + " +lat_1=29.3 +lat_2=30.7 +lat_0=28.66666666666667" + Bi + Z2 + N + X + J + A2, 1, D + AL + HJ + V2 + e + N + X + J + A2, 1, D + BD + DD + AO + e + N + X + J + A2, 1, H + " +lat_1=38.3 +lat_2=39.45" + CY + Ld + " +x_0=243840.4876809754" + N + X + J + A2, 1, H + " +lat_1=41.71666666666667 +lat_2=42.68333333333333" + Ip + GE + Px + N + X + J + A2, 1, H + " +lat_1=41.28333333333333 +lat_2=41.48333333333333" + Ip + IL + " +x_0=60960.12192024384" + N + X + J + A2, 4, H + " +lat_1=47.03333333333333 +lat_2=48.63333333333333" + Iq + DE + Z2 + N + X + J + A2, 1, H + " +lat_1=45.61666666666667 +lat_2=47.05" + IP + Js + Z2 + N + X + J + A2, 1, H + " +lat_1=43.78333333333333 +lat_2=45.21666666666667" + Nj + Na + Z2 + N + X + J + A2, 1, D + Cb + Ct + Pc + e + N + X + J + A2, 1, D + IY + Bx + Am + e + N + X + J + A2, 1, D + Cd + RS + BG + e + N + X + J + A2, 1, D + Cd + Hg + BG + e + N + X + J + A2, 1, D + Id + RT + Am + e + N + X + J + A2, 1, H + " +lat_1=34.41666666666666 +lat_2=33.86666666666667 +lat_0=34.13333333333333" + IW + " +x_0=1276106.450596901 +y_0=1268253.006858014" + X + J + A2, 48, D + AK + HJ + V2 + BF + N + C + B + J + A2, 1, D + BD + DD + AO + HT + N + C + B + J + A2, 1, H + FU + FV + Iq + DE + An + Ao + C + B + J + A2, 1, H + Ma + FW + IP + Js + An + Ao + C + B + J + A2, 1, H + FX + FY + Nj + Na + An + Ao + C + B + J + A2, 1, H + JT + Jn + FZ + CS + AG + N + C + B + J + A2, 1, H + Mb + RN + Mr + Ga + a + N + C + B + J + A2, 1, H + Fg + Fh + QX + CR + a + N + C + B + J + A2, 1, D + AK + HJ + V2 + BF + N + C + B + J + A2, 1, D + BD + DD + AO + HT + N + C + B + J + A2, 1, H + FU + FV + Iq + DE + An + Ao + C + B + J + A2, 1, H + Ma + FW + IP + Js + An + Ao + C + B + J + A2, 1, H + FX + FY + Nj + Na + An + Ao + C + B + J + A2, 1, H + JT + Jn + FZ + CS + AG + N + C + B + J + A2, 1, H + Mb + RN + Mr + Ga + a + N + C + B + J + A2, 1, H + Fg + Fh + QX + CR + a + N + C + B + J + A2, 1, D + AK + HJ + V2 + BF + N + C + B + J + A2, 1, D + BD + DD + AO + HT + N + C + B + J + A2, 1, H + FU + FV + Iq + DE + An + Ao + C + B + J + A2, 1, H + Ma + FW + IP + Js + An + Ao + C + B + J + A2, 1, H + FX + FY + Nj + Na + An + Ao + C + B + J + A2, 1, H + JT + Jn + FZ + CS + AG + N + C + B + J + A2, 1, H + Mb + RN + Mr + Ga + a + N + C + B + J + A2, 1, H + Fg + Fh + QX + CR + a + N + C + B + J + A2, 21, D + L3 + ET + V2 + Ab + N + C + B + E + A2, 1, D + L3 + CR + V2 + Ab + N + C + B + E + A2, 1, D + L3 + NV + V2 + Ab + N + C + B + E + A2, 1, D + L3 + Jh + V2 + Ab + N + C + B + E + A2, 1, D + L3 + Bu + V2 + Ab + N + C + B + E + A2, 1, D + L3 + Rs + V2 + Ab + N + C + B + E + A2, 1, D + L3 + OZ + V2 + Ab + N + C + B + E + A2, 1, D + L3 + " +lon_0=-53" + V2 + Ab + N + C + B + E + A2, 1, D + L3 + Zd + V2 + Ab + N + C + B + E + A2, 2, I2 + SK + C + B + E + A2, 1, I2 + TV + C + B + E + A2, 1, I2 + Xz + C + B + E + A2, 1, I2 + TY + C + B + E + A2, 1, I2 + RG + C + B + E + A2, 1, I2 + Ro + C + B + E + A2, 1, I2 + RH + C + B + E + A2, 1, I2 + TW + C + B + E + A2, 1, I2 + TX + C + B + E + A2, 1, I2 + QE + C + B + E + A2, 1, I2 + Ns + C + B + E + A2, 1, I2 + Nt + C + B + E + A2, 1, I2 + Nu + C + B + E + A2, 1, I2 + Nw + C + B + E + A2, 1, I2 + NP + C + B + E + A2, 1, I2 + NQ + C + B + E + A2, 1, I2 + Ik + C + B + E + A2, 1, I2 + IC + C + B + E + A2, 1, I2 + Hi + C + B + E + A2, 1, I2 + Gz + C + B + E + A2, 1, I2 + ID + C + B + E + A2, 1, I2 + Io + C + B + E + A2, 1, I2 + MB + C + B + E + A2, 6, D + IY + IV + Pc + h + N + C + B + E + A2, 1, D + Gm + OS + BG + a + N + C + B + E + A2, 1, CU + " +lat_0=57" + Ku + Kv + V2 + LX + EO + KE + GZ + C + B + E + A2, 1, D + Ft + YN + V2 + O2 + N + C + B + E + A2, 1, D + Ft + YO + V2 + O2 + N + C + B + E + A2, 1, D + Ft + ON + V2 + O2 + N + C + B + E + A2, 1, D + Ft + Ms + V2 + O2 + N + C + B + E + A2, 1, D + Ft + KI + V2 + O2 + N + C + B + E + A2, 1, D + Ft + YP + V2 + O2 + N + C + B + E + A2, 1, D + Ft + YQ + V2 + O2 + N + C + B + E + A2, 1, D + Ft + SW + V2 + O2 + N + C + B + E + A2, 1, H + Kw + Kx + UK + YR + BZ + N + C + B + E + A2, 1, H + DW + Jn + y + HA + Bd + Ae + C + B + E + A2, 1, H + DX + DY + AA + HA + Bd + Ae + C + B + E + A2, 1, H + Ap + DZ + Ml + AJ + Bd + Ae + C + B + E + A2, 1, H + LO + QS + Da + Mm + Bd + Ae + C + B + E + A2, 1, H + Db + Dc + Mn + Ir + Bd + Ae + C + B + E + A2, 1, H + Dd + De + Df + Iw + Bd + Ae + C + B + E + A2, 2, D + Bl + Cn + V2 + EX + N + C + B + E + A2, 1, D + Bl + Co + V2 + EX + N + C + B + E + A2, 1, D + Bl + Iv + BG + EX + N + C + B + E + A2, 1, H + Dx + Dy + BC + IF + u + N + C + B + E + A2, 1, H + Dz + Mq + EA + IF + u + Is + C + B + E + A2, 1, H + Eh + Ei + y + Ba + Fw + Fx + C + B + E + A2, 1, H + LP + LQ + CY + Ba + Fw + Fx + C + B + E + A2, 1, H + Ap + Dg + f + Ba + Fw + Fx + C + B + E + A2, 1, H + Dh + Mo + Di + Jq + QG + QH + C + B + E + A2, 1, D + Ch + Cp + Mp + h + N + C + B + E + A2, 1, D + Aq + CR + Am + h + N + C + B + E + A2, 1, D + Aq + Ob + Am + h + N + C + B + E + A2, 1, H + LR + Dj + QT + LS + a + N + C + B + E + A2, 1, D + Kn + Sf + AO + O2 + N + C + B + E + A2, 1, D + Ko + KO + AO + O2 + N + C + B + E + A2, 1, D + GV + KI + Jl + O2 + N + C + B + E + A2, 1, D + Kp + Sg + Jl + O2 + N + C + B + E + A2, 1, D + Kq + KP + " +k=1" + O2 + N + C + B + E + A2, 1, D + Gm + Cq + V2 + h + N + C + B + E + A2, 1, D + Gm + Cr + V2 + EW + N + C + B + E + A2, 1, D + p + Cs + BJ + h + N + C + B + E + A2, 1, D + p + Jb + BJ + O2 + N + C + B + E + A2, 1, D + p + Ix + BG + CX + N + C + B + E + A2, 1, D + f + Cz + EQ + AI + N + C + B + E + A2, 1, D + f + DA + Am + EW + N + C + B + E + A2, 1, D + DM + DB + AO + BU + KJ + C + B + E + A2, 1, D + DM + DC + AO + HT + KJ + C + B + E + A2, 1, H + EB + EC + Fo + GG + AV + AH + C + B + E + A2, 1, H + AY + ED + Fs + GG + O2 + N + C + B + E + A2, 1, H + EE + EF + AQ + Fl + u + N + C + B + E + A2, 1, H + EG + EH + f + CV + u + Is + C + B + E + A2, 2, H + Ej + Ek + AB + EY + O2 + Ae + C + B + E + A2, 1, H + FS + FT + IY + Hg + BZ + N + C + B + E + A2, 1, H + OH + OI + OJ + Bi + BZ + N + C + B + E + A2, 1, D + AK + HJ + V2 + AI + N + C + B + E + A2, 1, D + BD + DD + AO + HT + N + C + B + E + A2, 1, H + MU + Nz + AA + Ld + u + N + C + B + E + A2, 1, H + El + Dk + Ip + GE + h + Mk + C + B + E + A2, 1, H + Em + En + Ip + IL + O2 + N + C + B + E + A2, 1, H + Eo + Ep + Eq + Jh + Tl + N + C + B + E + A2, 1, H + OA + Er + Es + BE + Pk + N + C + B + E + A2, 1, H + Bq + OB + Fo + BE + LU + N + C + B + E + A2, 1, H + FU + FV + Iq + DE + CX + EK + C + B + E + A2, 1, H + Ma + FW + IP + Js + CX + EK + C + B + E + A2, 1, H + FX + FY + Nj + Na + CX + EK + C + B + E + A2, 1, D + Hj + Ct + CP + AI + N + C + B + E + A2, 1, D + Hj + Bx + CP + EW + N + C + B + E + A2, 1, D + Cd + RS + BG + Bv + N + C + B + E + A2, 1, D + Cd + Hg + BG + O2 + N + C + B + E + A2, 1, D + Id + RT + Am + YC + N + C + B + E + A2, 41, I2 + JM + c + DO + E + A2, 1, I2 + Me + c + DO + E + A2, 80, I2 + Gz + R + TS + E + A2, 80, "+proj=nzmg +lat_0=-41 +lon_0=173 +x_0=2510000 +y_0=6023150" + R + W + E + A2, 5, D + " +lat_0=-36.87986527777778 +lon_0=174.7643393611111" + V2 + AI + DN + R + W + E + A2, 1, D + " +lat_0=-37.76124980555556 +lon_0=176.46619725 +k=1" + AI + DN + R + W + E + A2, 1, D + " +lat_0=-38.62470277777778 +lon_0=177.8856362777778 +k=1" + AI + DN + R + W + E + A2, 1, D + " +lat_0=-39.65092930555556 +lon_0=176.6736805277778 +k=1" + AI + DN + R + W + E + A2, 1, D + " +lat_0=-39.13575830555556 +lon_0=174.22801175 +k=1" + AI + DN + R + W + E + A2, 1, D + " +lat_0=-39.51247038888889 +lon_0=175.6400368055556 +k=1" + AI + DN + R + W + E + A2, 1, D + " +lat_0=-40.24194713888889 +lon_0=175.4880996111111 +k=1" + AI + DN + R + W + E + A2, 1, D + " +lat_0=-40.92553263888889 +lon_0=175.6473496666667 +k=1" + AI + DN + R + W + E + A2, 1, D + " +lat_0=-41.30131963888888 +lon_0=174.7766231111111 +k=1" + AI + DN + R + W + E + A2, 1, D + " +lat_0=-40.71475905555556 +lon_0=172.6720465 +k=1" + AI + DN + R + W + E + A2, 1, D + " +lat_0=-41.27454472222222 +lon_0=173.2993168055555 +k=1" + AI + DN + R + W + E + A2, 1, D + " +lat_0=-41.28991152777778 +lon_0=172.1090281944444 +k=1" + AI + DN + R + W + E + A2, 1, D + " +lat_0=-41.81080286111111 +lon_0=171.5812600555556 +k=1" + AI + DN + R + W + E + A2, 1, D + " +lat_0=-42.33369427777778 +lon_0=171.5497713055556 +k=1" + AI + DN + R + W + E + A2, 1, D + " +lat_0=-42.68911658333333 +lon_0=173.0101333888889 +k=1" + AI + DN + R + W + E + A2, 1, D + " +lat_0=-41.54448666666666 +lon_0=173.8020741111111 +k=1" + AI + DN + R + W + E + A2, 1, D + " +lat_0=-42.88632236111111 +lon_0=170.9799935 +k=1" + AI + DN + R + W + E + A2, 1, D + " +lat_0=-43.11012813888889 +lon_0=170.2609258333333 +k=1" + AI + DN + R + W + E + A2, 1, D + " +lat_0=-43.97780288888889 +lon_0=168.606267 +k=1" + AI + DN + R + W + E + A2, 1, D + " +lat_0=-43.59063758333333 +lon_0=172.7271935833333 +k=1" + AI + DN + R + W + E + A2, 1, D + " +lat_0=-43.74871155555556 +lon_0=171.3607484722222 +k=1" + AI + DN + R + W + E + A2, 1, D + " +lat_0=-44.40222036111111 +lon_0=171.0572508333333 +k=1" + AI + DN + R + W + E + A2, 1, D + " +lat_0=-44.73526797222222 +lon_0=169.4677550833333 +k=1" + AI + DN + R + W + E + A2, 1, D + " +lat_0=-45.13290258333333 +lon_0=168.3986411944444 +k=1" + AI + DN + R + W + E + A2, 1, D + " +lat_0=-45.56372616666666 +lon_0=167.7388617777778 +k=1" + AI + DN + R + W + E + A2, 1, D + " +lat_0=-45.81619661111111 +lon_0=170.6285951666667 +k=1" + AI + DN + R + W + E + A2, 1, D + " +lat_0=-45.86151336111111 +lon_0=170.2825891111111" + Pc + AI + DN + R + W + E + A2, 1, D + " +lat_0=-46.60000961111111 +lon_0=168.342872 +k=1 +x_0=300002.66 +y_0=699999.58" + R + W + E + A2, 26, I2 + MA + o + R + W + E + A2, 1, I2 + Nq + o + R + W + E + A2, 1, I2 + PL + o + R + W + E + A2, 31, D + " +lat_0=-39 +lon_0=175.5 +k=1 +x_0=274319.5243848086 +y_0=365759.3658464114" + R + W + TU + A2, 1, D + Za + " +lon_0=171.5 +k=1 +x_0=457199.2073080143 +y_0=457199.2073080143" + R + W + TU + A2, 99, D + Fk + " +lon_0=-4.666666666666667 +k=1" + s + N + Hn + EL + Aa + SN + E + A2, 1, D + Fk + " +lon_0=-2.333333333333333 +k=1" + s + N + Hn + EL + Aa + SN + E + A2, 1, D + Fk + HN + " +k=1" + s + N + Hn + EL + Aa + SN + E + A2, 1, D + Fk + " +lon_0=2.5 +k=1" + s + N + Hn + EL + Aa + SN + E + A2, 1, D + Fk + Vr + " +k=1" + s + N + Hn + EL + Aa + SN + E + A2, 1, D + Fk + " +lon_0=10.16666666666667 +k=1" + s + N + Hn + EL + Aa + SN + E + A2, 1, D + Fk + " +lon_0=14.16666666666667 +k=1" + s + N + Hn + EL + Aa + SN + E + A2, 1, D + Fk + " +lon_0=18.33333333333333 +k=1" + s + N + Hn + EL + Aa + SN + E + A2, 31, I2 + KA + R + JL + E + A2, 64, D + BY + UZ + " +k=1 +x_0=180.598 +y_0=-86.98999999999999" + R + JL + E + A2, 7, H + PD + PE + " +lon_0=5.399999999999999 +k_0=0.99950908" + O2 + Hk + " +a=6376523" + RA + ZM + E + A2, 61, H + PD + PE + HN + " +k_0=0.999877341" + a + IK + AU + BN + Bk + Lv + E + A2, 1, H + " +lat_1=46.8 +lat_0=46.8" + HN + " +k_0=0.99987742" + a + IK + AU + BN + Bk + Lv + E + A2, 1, H + Xt + Xu + HN + " +k_0=0.999877499" + a + IK + AU + BN + Bk + Lv + E + A2, 1, H + Xv + Xw + HN + " +k_0=0.99994471 +x_0=234.358 +y_0=185861.369" + AU + BN + Bk + Lv + E + A2, 7, H + PD + PE + HN + " +k_0=0.999877341" + a + Tj + AU + BN + Bk + Lv + E + A2, 1, H + " +lat_1=46.8 +lat_0=46.8" + HN + " +k_0=0.99987742" + a + " +y_0=2200000" + AU + BN + Bk + Lv + E + A2, 1, H + Xt + Xu + HN + " +k_0=0.999877499" + a + " +y_0=3200000" + AU + BN + Bk + Lv + E + A2, 1, H + Xv + Xw + HN + " +k_0=0.99994471 +x_0=234.358 +y_0=4185861.369" + AU + BN + Bk + Lv + E + A2, 126, D + " +lat_0=49 +lon_0=-2 +k=0.9996012717" + u + " +y_0=-100000" + PV + Lx + E + A2, 491, Ck + LH + LI + Qx + " +y_0=126867.909" + Nc + Nd + DS + E + A2, 1, D + LH + LI + " +k=1" + Qx + " +y_0=1126867.909" + Nc + Nd + DS + E + A2, 1, Ck + LH + LI + Qx + " +y_0=1126867.909" + Nc + Nd + DS + E + A2, 39, I2 + JN + o + AU + BN + TH + E + A2, 116, I2 + Mh + o + C + B + E + A2, 1, I2 + Mi + o + C + B + E + A2, 1, I2 + NS + o + C + B + E + A2, 1, I2 + Mg + o + C + B + E + A2, 1, I2 + NT + o + C + B + E + A2, 1, I2 + Ot + o + C + B + E + A2, 1, I2 + Nv + o + C + B + E + A2, 1, I2 + PM + o + C + B + E + A2, 1, I2 + Re + o + C + B + E + A2, 1, I2 + SM + o + C + B + E + A2, 1, I2 + MA + o + C + B + E + A2, 46, D + L3 + Gl + " +k=1" + DP + N + M + F + E + A2, 1, D + L3 + HO + " +k=1" + Eg + N + M + F + E + A2, 1, D + L3 + IG + " +k=1" + Jt + N + M + F + E + A2, 1, D + L3 + LN + " +k=1" + IM + N + M + F + E + A2, 1, D + L3 + JS + " +k=1" + MS + N + M + F + E + A2, 1, D + L3 + PS + " +k=1" + MT + N + M + F + E + A2, 1, D + L3 + RL + " +k=1" + LY + N + M + F + E + A2, 1, D + L3 + QW + " +k=1" + Jp + N + M + F + E + A2, 1, D + L3 + RM + " +k=1" + LZ + N + M + F + E + A2, 1, D + L3 + HP + " +k=1" + HU + N + M + F + E + A2, 1, D + L3 + HQ + " +k=1" + Gw + N + M + F + E + A2, 1, D + L3 + Hd + " +k=1" + Hu + N + M + F + E + A2, 1, D + L3 + HR + " +k=1" + Hv + N + M + F + E + A2, 1, D + L3 + HS + " +k=1" + It + N + M + F + E + A2, 1, D + L3 + EN + " +k=1" + Hs + N + M + F + E + A2, 1, D + L3 + Fy + " +k=1" + Ht + N + M + F + E + A2, 1, D + L3 + Fm + " +k=1" + HV + N + M + F + E + A2, 1, D + L3 + Fr + " +k=1" + Hw + N + M + F + E + A2, 1, D + L3 + Ed + " +k=1" + HW + N + M + F + E + A2, 1, D + L3 + Fn + " +k=1" + Hx + N + M + F + E + A2, 1, D + L3 + Pf + " +k=1" + La + N + M + F + E + A2, 1, D + L3 + Od + " +k=1" + Hy + N + M + F + E + A2, 1, D + L3 + NY + " +k=1" + Hz + N + M + F + E + A2, 1, D + L3 + Pg + " +k=1" + IA + N + M + F + E + A2, 1, D + L3 + NZ + " +k=1" + IB + N + M + F + E + A2, 1, D + L3 + Lf + " +k=1" + Gx + N + M + F + E + A2, 1, D + L3 + KG + " +k=1" + IT + N + M + F + E + A2, 1, D + L3 + KH + " +k=1" + Gc + N + M + F + E + A2, 1, D + L3 + Lh + " +k=1" + IU + N + M + F + E + A2, 168, D + " +lat_0=24.45" + Vv + Jl + h + Hk + R + QO + E + A2, 391, GU + Xx + Yo + " +k=0.9999079" + s + N + Y + Fv + E + A2, 1, GU + Xx + Yo + " +k=0.9999079 +x_0=155000 +y_0=463000" + Y + Fv + E + A2, 109, UU + L3 + Nb + LX + Ak + x + Al + E + A2, 67, I2 + IC + x + Al + E + A2, 1, I2 + Hi + x + Al + E + A2, 1, I2 + Gz + x + Al + E + A2, 1, I2 + ID + x + Al + E + A2, 1, I2 + Io + x + Al + E + A2, 15, I2 + Ik + o + x + Al + E + A2, 1, I2 + IC + o + x + Al + E + A2, 1, I2 + Hi + o + x + Al + E + A2, 1, I2 + Gz + o + x + Al + E + A2, 1, I2 + ID + o + x + Al + E + A2, 1, I2 + Io + o + x + Al + E + A2, 1, I2 + MB + o + x + Al + E + A2, 1, I2 + Nx + o + x + Al + E + A2, 1, I2 + Nr + o + x + Al + E + A2, 25, I2 + Gz + o + R + Nn + E + A2, 1, I2 + ID + o + R + Nn + E + A2, 112, I2 + KC + o + HB + Bt + E + A2, 38, D + Pi + " +lon_0=11 +k=1" + s + N + Gk + HB + Bt + GK + A2, 2, D + Pi + " +lon_0=13 +k=1" + s + N + Gk + HB + Bt + GK + A2, 2, D + Pi + Gj + " +k=1" + s + N + Gk + HB + Bt + GK + A2, 2, D + Pi + UE + " +k=1" + s + N + Gk + HB + Bt + GK + A2, 2, D + Pi + RI + " +k=1" + s + N + Gk + HB + Bt + GK + A2, 2, D + Pi + Gl + " +k=1" + s + N + Gk + HB + Bt + GK + A2, 2, D + Pi + SP + " +k=1" + s + N + Gk + HB + Bt + GK + A2, 2, D + Pi + RJ + " +k=1" + s + N + Gk + HB + Bt + GK + A2, 317, CU + " +lat_0=-18.9 +lonc=44.10000000000001 +alpha=18.9" + EP + u + CO + " +gamma=18.9" + R + HD + Lv + E + A2, 36, I2 + JZ + o + R + HD + E + A2, 1, I2 + JM + o + R + HD + E + A2, 110, I2 + Mi + Lo + GD + E + A2, 1, I2 + NS + Lo + GD + E + A2, 21, CU + Qi + Yz + PF + Ph + " +x_0=590476.8714630401 +y_0=442857.653094361" + If + Lo + GD + " +to_meter=20.11676512155263" + A2, 1, CU + Qi + Yz + PF + Ph + " +x_0=590476.8727431979 +y_0=442857.6545573985" + If + Lo + GD + " +to_meter=0.3047994715386762" + A2, 1, CU + Qi + Yz + PF + Ph + " +x_0=590476.87 +y_0=442857.65" + If + Lo + GD + E + A2, 28, D + YA + " +lon_0=-8 +k=1" + h + KJ + PV + Bb + E + A2, 1, D + YA + " +lon_0=-8 +k=1.000035" + h + KJ + Ok + Bb + E + A2, 1, D + YA + " +lon_0=-8 +k=1.000035" + h + KJ + Ok + Bb + E + A2, 258, D + PT + Zz + V2 + s + N + Y + g + E + A2, 1, D + PT + NX + V2 + s + N + Y + g + E + A2, 1, D + GM + Ox + V2 + s + N + Y + g + E + A2, 1, D + PT + Tk + V2 + s + N + Y + g + E + A2, 1, D + GM + Oy + V2 + s + N + Y + g + E + A2, 1, D + GM + Rw + V2 + s + N + Y + g + E + A2, 1, D + GM + Oz + V2 + s + N + Y + g + E + A2, 1, D + GM + aA + V2 + s + N + Y + g + E + A2, 1, D + GM + PA + V2 + s + N + Y + g + E + A2, 1, D + Fs + PB + V2 + s + N + Y + g + E + A2, 1, D + IZ + ZH + V2 + s + N + Y + g + E + A2, 1, D + IZ + ZI + V2 + s + N + Y + g + E + A2, 1, D + IZ + ZJ + V2 + s + N + Y + g + E + A2, 1, D + IQ + " +lon_0=142" + V2 + s + N + Y + g + E + A2, 1, D + IQ + Pj + V2 + s + N + Y + g + E + A2, 1, D + IQ + " +lon_0=124" + V2 + s + N + Y + g + E + A2, 1, D + IQ + NX + V2 + s + N + Y + g + E + A2, 1, D + " +lat_0=20" + Rw + V2 + s + N + Y + g + E + A2, 1, D + IQ + ZR + V2 + s + N + Y + g + E + A2, 21, Ck + Vs + UX + " +x_0=86501.46392051999" + aS + Ee + Ef + JK + Vo + A2, 139, I2 + JM + Gn + E + A2, 1, I2 + Me + Gn + E + A2, 151, H + " +lat_1=36" + GM + SC + QL + O2 + Hk + AU + BN + JC + E + A2, 1, H + Sd + Se + SC + Nk + O2 + Hk + AU + BN + JC + E + A2, 1, H + " +lat_1=36" + GM + SC + QL + O2 + Hk + AU + BN + E + A2, 1, H + Sd + Se + SC + Nk + O2 + Hk + AU + BN + E + A2, 235, I2 + KA + c + Af + E + A2, 1, I2 + Oq + c + Af + E + A2, 1, I2 + QD + c + Af + E + A2, 1, I2 + JN + c + Af + E + A2, 59, H + " +lat_1=36" + GM + SC + QL + " +x_0=500135 +y_0=300090" + c + Af + E + A2, 1, H + Sd + Se + SC + Nk + " +x_0=500135 +y_0=300090" + c + Af + E + A2, 236, I2 + Ja + AU + BN + E + A2, 93, I2 + ID + R + HE + E + A2, 33, D + L3 + Nb + AP + O2 + N + R + HE + E + A2, 16, D + L3 + Vn + AP + O2 + N + R + HE + E + A2, 1, D + L3 + Vn + V2 + O2 + N + R + HE + E + A2, 80, D + L3 + RP + " +k=1" + s + EO + Y + Aw + Ls + E + A2, 1, D + L3 + QQ + " +k=1" + s + EO + Y + Aw + Ls + E + A2, 1, D + L3 + ZG + " +k=1" + s + EO + Y + Aw + Ls + E + A2, 1, D + L3 + PG + " +k=1" + s + EO + Y + z + E + A2, 1, D + L3 + Ig + " +k=1" + s + EO + Y + z + E + A2, 1, D + L3 + PH + " +k=1" + s + EO + Y + z + E + A2, 1, D + L3 + PG + " +k=1" + Bn + EO + Y + z + E + A2, 1, D + L3 + Ig + " +k=1 +x_0=450000" + EO + Y + z + E + A2, 1, D + L3 + PH + " +k=1" + YL + EO + Y + z + E + A2, 22, D + L3 + RP + " +k=1" + s + N + Y + Aw + Ls + E + A2, 1, D + L3 + QQ + " +k=1" + s + N + Y + Aw + Ls + E + A2, 1, D + L3 + ZG + " +k=1" + s + N + Y + Aw + Ls + E + A2, 1, D + L3 + PG + " +k=1" + Bn + N + Y + z + E + A2, 1, D + L3 + Ig + " +k=1 +x_0=450000" + N + Y + z + E + A2, 1, D + L3 + PH + " +k=1" + YL + N + Y + z + E + A2, 1, H + LM + Nh + " +lat_0=47.5" + Ig + u + Is + Y + z + E + A2, 1, D + L3 + RP + " +k=1" + Bn + N + Y + Aw + Ls + E + A2, 1, D + L3 + QQ + " +k=1 +x_0=450000" + N + Y + Aw + Ls + E + A2, 1, D + L3 + ZG + " +k=1" + YL + N + Y + Aw + Ls + E + A2, 10, H + Ks + Kt + Hr + " +lon_0=4.356939722222222 +x_0=150000.01256 +y_0=5400088.4378" + R + GP + E + A2, 70, H + " +lat_1=51.16666723333333 +lat_2=49.8333339" + Hr + " +lon_0=4.367486666666666 +x_0=150000.013 +y_0=5400088.438" + R + GP + E + A2, 96, D + L3 + ZO + " +k=1" + Ci + N + Y + AC + E + A2, 1, D + L3 + KB + " +k=1" + Bo + N + Y + AC + E + A2, 1, D + L3 + IH + " +k=1" + DP + N + Y + AC + E + A2, 1, D + L3 + Gj + " +k=1" + Eg + N + Y + AC + E + A2, 59, I2 + Ja + AU + BN + No + E + A2, 1, I2 + KA + AU + BN + No + E + A2, 71, GU + " +lat_0=45.9 +lon_0=25.39246588888889 +k=0.9996667" + O2 + Ae + R + QP + E + A2, 238, I2 + JZ + j + MR + E + A2, 1, I2 + JM + j + MR + E + A2, 62, D + L3 + SQ + " +k=1" + O2 + N + C + Rr + E + A2, 64, I2 + Ns + C + B + E + A2, 1, I2 + Nt + C + B + E + A2, 1, I2 + Nu + C + B + E + A2, 1, I2 + Nw + C + B + E + A2, 1, I2 + NP + C + B + E + A2, 1, I2 + NQ + C + B + E + A2, 1, I2 + Ik + C + B + E + A2, 1, I2 + IC + C + B + E + A2, 1, I2 + Hi + C + B + E + A2, 1, I2 + Gz + C + B + E + A2, 1, I2 + ID + C + B + E + A2, 1, I2 + Io + C + B + E + A2, 1, I2 + Ik + o + C + B + E + A2, 1, I2 + IC + o + C + B + E + A2, 1, I2 + Hi + o + C + B + E + A2, 1, I2 + Gz + o + C + B + E + A2, 1, I2 + ID + o + C + B + E + A2, 1, I2 + Io + o + C + B + E + A2, 1, I2 + MB + o + C + B + E + A2, 1, I2 + Nx + o + C + B + E + A2, 1, I2 + Nr + o + C + B + E + A2, 1, I2 + Ik + C + B + E + A2, 1, I2 + IC + C + B + E + A2, 1, I2 + Hi + C + B + E + A2, 1, I2 + Gz + C + B + E + A2, 1, I2 + ID + C + B + E + A2, 1, I2 + Io + C + B + E + A2, 1, I2 + Ik + o + C + B + E + A2, 1, I2 + IC + o + C + B + E + A2, 1, I2 + Hi + o + C + B + E + A2, 1, I2 + Gz + o + C + B + E + A2, 1, I2 + ID + o + C + B + E + A2, 1, I2 + Io + o + C + B + E + A2, 1, I2 + MB + o + C + B + E + A2, 1, I2 + Nx + o + C + B + E + A2, 1, I2 + Nr + o + C + B + E + A2, 1, H + " +lat_1=48.71666666666667 +lat_2=47.85" + Ib + IS + Z2 + N + X + J + A2, 1, H + " +lat_1=47.88333333333333 +lat_2=46.45 +lat_0=45.83333333333334" + IS + Z2 + N + X + J + A2, 1, H + " +lat_1=46.4 +lat_2=44.86666666666667" + IZ + IS + Z2 + N + X + J + A2, 2, H + " +lat_1=41.85 +lat_2=42.81666666666667 +lat_0=41.33333333333334" + CS + Z2 + N + X + J + A2, 1, H + " +lat_1=40.28333333333333" + Dk + BY + " +lon_0=-99.5" + Z2 + N + X + J + A2, 1, D + CQ + DF + V2 + e + N + X + J + A2, 1, D + CQ + DG + V2 + e + N + X + J + A2, 1, D + CQ + DH + V2 + e + N + X + J + A2, 1, D + Fp + DI + AO + e + N + X + J + A2, 1, D + BA + " +lon_0=-74.66666666666667" + EQ + Z2 + N + X + J + A2, 1, D + Bl + Cu + Hm + e + N + X + J + A2, 1, D + Bl + Iy + V2 + e + N + X + J + A2, 1, D + Bl + Cv + Iz + e + N + X + J + A2, 1, D + Fs + " +lon_0=-74.33333333333333" + AO + e + N + X + J + A2, 1, D + Fs + Cw + Ad + e + N + X + J + A2, 1, D + Fs + Cx + Ad + e + N + X + J + A2, 2, H + " +lat_1=34.33333333333334 +lat_2=36.16666666666666" + LT + NW + Z2 + N + X + J + A2, 1, H + " +lat_1=47.43333333333333" + Xy + Ib + EZ + Z2 + N + X + J + A2, 1, H + " +lat_1=46.18333333333333 +lat_2=47.48333333333333" + Be + EZ + Z2 + N + X + J + A2, 1, H + " +lat_1=40.43333333333333 +lat_2=41.7" + BY + ET + Z2 + N + X + J + A2, 1, H + " +lat_1=38.73333333333333 +lat_2=40.03333333333333" + Ch + ET + Z2 + N + X + J + A2, 1, H + " +lat_1=35.56666666666667" + Du + QU + Fl + Z2 + N + X + J + A2, 1, H + " +lat_1=33.93333333333333 +lat_2=35.23333333333333" + Do + Fl + Z2 + N + X + J + A2, 1, H + " +lat_1=44.33333333333334" + Nh + AK + AJ + Z2 + N + X + J + A2, 1, H + " +lat_1=42.33333333333334 +lat_2=44" + p + AJ + Z2 + N + X + J + A2, 1, H + " +lat_1=40.88333333333333 +lat_2=41.95" + BB + Ea + Z2 + N + X + J + A2, 2, D + EI + GE + " +k=0.9999938" + e + N + X + J + A2, 1, H + " +lat_1=33.76666666666667 +lat_2=34.96666666666667" + PT + CR + Z2 + N + X + J + A2, 2, H + " +lat_1=32.33333333333334 +lat_2=33.66666666666666" + Dr + CR + Z2 + N + X + J + A2, 1, H + " +lat_1=44.41666666666666 +lat_2=45.68333333333333" + AL + CS + Z2 + N + X + J + A2, 1, H + " +lat_1=42.83333333333334 +lat_2=44.4" + EJ + Ag + Z2 + N + X + J + A2, 2, H + aL + " +lat_2=36.18333333333333" + QV + Jr + Z2 + N + X + J + A2, 1, H + " +lat_1=32.13333333333333 +lat_2=33.96666666666667" + Ds + " +lon_0=-97.5" + Z2 + N + X + J + A2, 1, H + " +lat_1=30.11666666666667 +lat_2=31.88333333333333" + Cb + Ag + Z2 + N + X + J + A2, 1, H + " +lat_1=28.38333333333333 +lat_2=30.28333333333333" + Dt + Ji + Z2 + N + X + J + A2, 1, H + " +lat_1=26.16666666666667 +lat_2=27.83333333333333" + Cc + CV + Z2 + N + X + J + A2, 1, H + " +lat_1=40.71666666666667 +lat_2=41.78333333333333" + Br + BI + Z2 + N + X + J + A2, 1, H + " +lat_1=39.01666666666667 +lat_2=40.65" + AQ + BI + Z2 + N + X + J + A2, 1, H + " +lat_1=37.21666666666667 +lat_2=38.35" + f + BI + Z2 + N + X + J + A2, 1, D + Fp + LW + JA + e + N + X + J + A2, 1, H + " +lat_1=38.03333333333333 +lat_2=39.2" + AA + GF + Z2 + N + X + J + A2, 1, H + Dn + " +lat_2=37.96666666666667" + AB + GF + Z2 + N + X + J + A2, 1, H + " +lat_1=47.5" + Xy + Ib + Cy + Z2 + N + X + J + A2, 1, H + " +lat_1=45.83333333333334 +lat_2=47.33333333333334" + Dv + AJ + Z2 + N + X + J + A2, 1, H + " +lat_1=39 +lat_2=40.25" + Mr + Ga + Z2 + N + X + J + A2, 1, H + " +lat_1=37.48333333333333 +lat_2=38.88333333333333" + QX + CR + Z2 + N + X + J + A2, 1, H + " +lat_1=45.56666666666667 +lat_2=46.76666666666667" + Dw + Bu + Z2 + N + X + J + A2, 1, H + " +lat_1=44.25" + Hl + AL + Bu + Z2 + N + X + J + A2, 1, H + " +lat_1=42.73333333333333 +lat_2=44.06666666666667" + PR + Bu + Z2 + N + X + J + A2, 1, D + LL + DJ + Am + e + N + X + J + A2, 1, D + LL + DK + Am + e + N + X + J + A2, 1, D + LL + JB + Am + e + N + X + J + A2, 1, D + LL + DL + Am + e + N + X + J + A2, 6, D + L3 + Ji + AP + k + N + X + J + A2, 1, D + L3 + Rs + AP + k + N + X + J + A2, 1, D + L3 + Jh + AP + k + N + X + J + A2, 1, D + L3 + CR + AP + k + N + X + J + A2, 14, D + L3 + " +lon_0=-53" + V2 + Ab + N + X + E + A2, 1, D + L3 + Zd + V2 + Ab + N + X + E + A2, 1, D + L3 + Tf + V2 + Ab + N + X + E + A2, 1, D + L3 + RQ + V2 + Ab + N + X + E + A2, 1, D + L3 + RR + V2 + Ab + N + X + E + A2, 1, D + L3 + Tg + V2 + Ab + N + X + E + A2, 12, H + UF + Nh + IZ + HJ + s + N + X + E + A2, 1, H + CD + CE + Cc + Bi + Z2 + N + X + J + A2, 1, H + LM + RK + MV + IS + a + N + C + B + E + A2, 4, H + JT + Jn + FZ + CS + O2 + N + C + B + E + A2, 3, D + CQ + DF + V2 + h + Tm + C + B + E + A2, 1, D + CQ + DG + V2 + O2 + Hh + C + B + E + A2, 1, D + CQ + DH + V2 + CX + LV + C + B + E + A2, 1, D + Fp + DI + AO + AI + N + C + B + E + A2, 1, D + BA + Gp + V2 + Bn + N + C + B + E + A2, 1, D + Bl + Cu + Hm + OC + N + C + B + E + A2, 1, D + Bl + Iy + V2 + O2 + N + C + B + E + A2, 1, D + Bl + Cv + Iz + YD + N + C + B + E + A2, 1, D + BA + Gp + V2 + Bn + N + C + B + E + A2, 1, D + Fs + Cw + Ad + Bv + N + C + B + E + A2, 1, D + Fs + Cx + Ad + Qo + N + C + B + E + A2, 1, H + Dl + Dm + BB + Oc + AI + N + C + B + E + A2, 1, H + Et + Eu + LT + NW + Rh + N + C + B + E + A2, 1, H + BH + Ev + Ib + EZ + a + N + C + B + E + A2, 1, H + Ew + Ex + Be + EZ + a + N + C + B + E + A2, 1, H + OK + Fa + BY + ET + a + N + C + B + E + A2, 1, H + Fb + Fc + Ch + ET + a + N + C + B + E + A2, 1, H + Dn + Ey + QU + Fl + a + N + C + B + E + A2, 1, H + Ez + FA + Do + Fl + a + N + C + B + E + A2, 1, H + PP + CZ + AK + AJ + Ci + N + C + B + E + A2, 1, H + PQ + Ca + p + AJ + AV + N + C + B + E + A2, 1, H + MW + FB + BB + Ea + a + N + C + B + E + A2, 1, H + Dp + Dq + y + Ea + a + N + C + B + E + A2, 1, D + EI + GE + Lb + BU + N + C + B + E + A2, 3, H + FC + OD + Dr + CR + OE + N + C + B + E + A2, 1, H + Fd + Fe + AL + CS + a + N + C + B + E + A2, 1, H + OL + Ff + EJ + Ag + a + N + C + B + E + A2, 1, H + FD + MX + BC + MQ + a + N + C + B + E + A2, 1, H + FE + MY + QV + Jr + h + AH + C + B + E + A2, 1, H + FF + FG + Ds + CV + a + Cl + C + B + E + A2, 1, H + FH + FI + Cb + Ag + EW + Fq + C + B + E + A2, 1, H + FJ + FK + Dt + Ji + a + LV + C + B + E + A2, 1, H + CD + CE + Cc + CV + AI + Ju + C + B + E + A2, 1, H + AY + CF + Br + BI + O2 + AH + C + B + E + A2, 1, H + JF + CG + AQ + BI + O2 + Cl + C + B + E + A2, 1, H + JG + CH + f + BI + O2 + Fq + C + B + E + A2, 1, D + Fp + LW + JA + O2 + N + C + B + E + A2, 1, H + OF + FL + AA + GF + Bo + Cl + C + B + E + A2, 1, H + Az + Du + AB + GF + Bo + AH + C + B + E + A2, 1, H + BH + OG + Ib + Cy + O2 + N + C + B + E + A2, 1, H + FM + FN + Dv + AJ + O2 + N + C + B + E + A2, 1, H + Mb + RN + Mr + Ga + a + N + C + B + E + A2, 1, H + Fg + Fh + QX + CR + a + N + C + B + E + A2, 1, H + FO + FP + Dw + Bu + a + N + C + B + E + A2, 1, H + Jc + MZ + AL + Bu + a + N + C + B + E + A2, 1, H + FQ + FR + PR + Bu + a + N + C + B + E + A2, 1, D + CA + DJ + Ad + h + N + C + B + E + A2, 1, D + CA + DK + Ad + u + EK + C + B + E + A2, 1, D + CA + JB + Ad + a + N + C + B + E + A2, 1, D + CA + DL + Ad + CX + EK + C + B + E + A2, 3, H + GW + GX + GY + GA + h + IK + C + B + E + A2, 3, D + L3 + Ji + AP + k + N + C + B + J + A2, 1, D + L3 + Rs + AP + k + N + C + B + J + A2, 1, D + L3 + Jh + AP + k + N + C + B + J + A2, 1, D + L3 + CR + AP + k + N + C + B + J + A2, 14, D + L3 + " +lon_0=-53" + V2 + Ab + N + C + B + E + A2, 1, D + L3 + Zd + V2 + Ab + N + C + B + E + A2, 1, D + L3 + Tf + V2 + Ab + N + C + B + E + A2, 1, D + L3 + RQ + V2 + Ab + N + C + B + E + A2, 1, D + L3 + RR + V2 + Ab + N + C + B + E + A2, 1, D + L3 + Tg + V2 + Ab + N + C + B + E + A2, 1, D + L3 + IL + V2 + Ab + N + C + B + E + A2, 1, D + L3 + Th + V2 + Ab + N + C + B + E + A2, 1, D + L3 + Ti + V2 + Ab + N + C + B + E + A2, 1, D + L3 + Ga + V2 + Ab + N + C + B + E + A2, 1, D + L3 + ET + V2 + Ab + N + C + B + E + A2, 1, D + L3 + CR + V2 + Ab + N + C + B + E + A2, 1, D + L3 + NV + V2 + Ab + N + C + B + E + A2, 1, D + L3 + Jh + V2 + Ab + N + C + B + E + A2, 1, D + L3 + Bu + V2 + Ab + N + C + B + E + A2, 1, D + L3 + Rs + V2 + Ab + N + C + B + E + A2, 1, D + L3 + OZ + V2 + Ab + N + C + B + E + A2, 1, H + UF + Nh + IZ + HJ + s + N + C + B + E + A2, 1, H + CD + CE + " +lat_0=25.5" + Bi + BZ + N + C + B + E + A2, 2, I2 + SK + T + P + E + A2, 1, I2 + TV + T + P + E + A2, 1, I2 + Xz + T + P + E + A2, 1, I2 + TY + T + P + E + A2, 1, I2 + RG + T + P + E + A2, 1, I2 + Ro + T + P + E + A2, 1, I2 + RH + T + P + E + A2, 1, I2 + TW + T + P + E + A2, 1, I2 + TX + T + P + E + A2, 1, I2 + QE + T + P + E + A2, 1, I2 + Ns + T + P + E + A2, 1, I2 + Nt + T + P + E + A2, 1, I2 + Nu + T + P + E + A2, 1, I2 + Nw + T + P + E + A2, 1, I2 + NP + T + P + E + A2, 1, I2 + NQ + T + P + E + A2, 1, I2 + Ik + T + P + E + A2, 1, I2 + IC + T + P + E + A2, 1, I2 + Hi + T + P + E + A2, 1, I2 + Gz + T + P + E + A2, 1, I2 + ID + T + P + E + A2, 1, I2 + Io + T + P + E + A2, 1, I2 + MB + T + P + E + A2, 1, I2 + Nx + T + P + E + A2, 1, I2 + Nr + T + P + E + A2, 1, I2 + Os + T + P + E + A2, 1, I2 + SL + T + P + E + A2, 1, I2 + Ja + T + P + E + A2, 1, I2 + KA + T + P + E + A2, 1, I2 + Oq + T + P + E + A2, 1, I2 + QD + T + P + E + A2, 1, I2 + JN + T + P + E + A2, 1, I2 + KC + T + P + E + A2, 1, I2 + NR + T + P + E + A2, 1, I2 + Ki + T + P + E + A2, 1, I2 + Mf + T + P + E + A2, 1, I2 + KD + T + P + E + A2, 1, I2 + JZ + T + P + E + A2, 1, I2 + JM + T + P + E + A2, 1, I2 + Me + T + P + E + A2, 1, I2 + Rb + T + P + E + A2, 1, I2 + Rc + T + P + E + A2, 1, I2 + SO + T + P + E + A2, 1, I2 + Td + T + P + E + A2, 1, I2 + Te + T + P + E + A2, 1, I2 + QF + T + P + E + A2, 1, I2 + Ny + T + P + E + A2, 1, I2 + Mh + T + P + E + A2, 1, I2 + Mi + T + P + E + A2, 1, I2 + NS + T + P + E + A2, 1, I2 + Mg + T + P + E + A2, 1, I2 + NT + T + P + E + A2, 1, I2 + Ot + T + P + E + A2, 1, I2 + Nv + T + P + E + A2, 1, I2 + PM + T + P + E + A2, 1, I2 + Re + T + P + E + A2, 1, I2 + SM + T + P + E + A2, 1, I2 + MA + T + P + E + A2, 1, I2 + Nq + T + P + E + A2, 1, I2 + PL + T + P + E + A2, 41, I2 + SK + o + T + P + E + A2, 1, I2 + TV + o + T + P + E + A2, 1, I2 + Xz + o + T + P + E + A2, 1, I2 + TY + o + T + P + E + A2, 1, I2 + RG + o + T + P + E + A2, 1, I2 + Ro + o + T + P + E + A2, 1, I2 + RH + o + T + P + E + A2, 1, I2 + TW + o + T + P + E + A2, 1, I2 + TX + o + T + P + E + A2, 1, I2 + QE + o + T + P + E + A2, 1, I2 + Ns + o + T + P + E + A2, 1, I2 + Nt + o + T + P + E + A2, 1, I2 + Nu + o + T + P + E + A2, 1, I2 + Nw + o + T + P + E + A2, 1, I2 + NP + o + T + P + E + A2, 1, I2 + NQ + o + T + P + E + A2, 1, I2 + Ik + o + T + P + E + A2, 1, I2 + IC + o + T + P + E + A2, 1, I2 + Hi + o + T + P + E + A2, 1, I2 + Gz + o + T + P + E + A2, 1, I2 + ID + o + T + P + E + A2, 1, I2 + Io + o + T + P + E + A2, 1, I2 + MB + o + T + P + E + A2, 1, I2 + Nx + o + T + P + E + A2, 1, I2 + Nr + o + T + P + E + A2, 1, I2 + Os + o + T + P + E + A2, 1, I2 + SL + o + T + P + E + A2, 1, I2 + Ja + o + T + P + E + A2, 1, I2 + KA + o + T + P + E + A2, 1, I2 + Oq + o + T + P + E + A2, 1, I2 + QD + o + T + P + E + A2, 1, I2 + JN + o + T + P + E + A2, 1, I2 + KC + o + T + P + E + A2, 1, I2 + NR + o + T + P + E + A2, 1, I2 + Ki + o + T + P + E + A2, 1, I2 + Mf + o + T + P + E + A2, 1, I2 + KD + o + T + P + E + A2, 1, I2 + JZ + o + T + P + E + A2, 1, I2 + JM + o + T + P + E + A2, 1, I2 + Me + o + T + P + E + A2, 1, I2 + Rb + o + T + P + E + A2, 1, I2 + Rc + o + T + P + E + A2, 1, I2 + SO + o + T + P + E + A2, 1, I2 + Td + o + T + P + E + A2, 1, I2 + Te + o + T + P + E + A2, 1, I2 + QF + o + T + P + E + A2, 1, I2 + Ny + o + T + P + E + A2, 1, I2 + Mh + o + T + P + E + A2, 1, I2 + Mi + o + T + P + E + A2, 1, I2 + NS + o + T + P + E + A2, 1, I2 + Mg + o + T + P + E + A2, 1, I2 + NT + o + T + P + E + A2, 1, I2 + Ot + o + T + P + E + A2, 1, I2 + Nv + o + T + P + E + A2, 1, I2 + PM + o + T + P + E + A2, 1, I2 + Re + o + T + P + E + A2, 1, I2 + SM + o + T + P + E + A2, 1, I2 + MA + o + T + P + E + A2, 1, I2 + Nq + o + T + P + E + A2, 1, I2 + PL + o + T + P + E + A2, 41, I2 + SK + T + Q + E + A2, 1, I2 + TV + T + Q + E + A2, 1, I2 + Xz + T + Q + E + A2, 1, I2 + TY + T + Q + E + A2, 1, I2 + RG + T + Q + E + A2, 1, I2 + Ro + T + Q + E + A2, 1, I2 + RH + T + Q + E + A2, 1, I2 + TW + T + Q + E + A2, 1, I2 + TX + T + Q + E + A2, 1, I2 + QE + T + Q + E + A2, 1, I2 + Ns + T + Q + E + A2, 1, I2 + Nt + T + Q + E + A2, 1, I2 + Nu + T + Q + E + A2, 1, I2 + Nw + T + Q + E + A2, 1, I2 + NP + T + Q + E + A2, 1, I2 + NQ + T + Q + E + A2, 1, I2 + Ik + T + Q + E + A2, 1, I2 + IC + T + Q + E + A2, 1, I2 + Hi + T + Q + E + A2, 1, I2 + Gz + T + Q + E + A2, 1, I2 + ID + T + Q + E + A2, 1, I2 + Io + T + Q + E + A2, 1, I2 + MB + T + Q + E + A2, 1, I2 + Nx + T + Q + E + A2, 1, I2 + Nr + T + Q + E + A2, 1, I2 + Os + T + Q + E + A2, 1, I2 + SL + T + Q + E + A2, 1, I2 + Ja + T + Q + E + A2, 1, I2 + KA + T + Q + E + A2, 1, I2 + Oq + T + Q + E + A2, 1, I2 + QD + T + Q + E + A2, 1, I2 + JN + T + Q + E + A2, 1, I2 + KC + T + Q + E + A2, 1, I2 + NR + T + Q + E + A2, 1, I2 + Ki + T + Q + E + A2, 1, I2 + Mf + T + Q + E + A2, 1, I2 + KD + T + Q + E + A2, 1, I2 + JZ + T + Q + E + A2, 1, I2 + JM + T + Q + E + A2, 1, I2 + Me + T + Q + E + A2, 1, I2 + Rb + T + Q + E + A2, 1, I2 + Rc + T + Q + E + A2, 1, I2 + SO + T + Q + E + A2, 1, I2 + Td + T + Q + E + A2, 1, I2 + Te + T + Q + E + A2, 1, I2 + QF + T + Q + E + A2, 1, I2 + Ny + T + Q + E + A2, 1, I2 + Mh + T + Q + E + A2, 1, I2 + Mi + T + Q + E + A2, 1, I2 + NS + T + Q + E + A2, 1, I2 + Mg + T + Q + E + A2, 1, I2 + NT + T + Q + E + A2, 1, I2 + Ot + T + Q + E + A2, 1, I2 + Nv + T + Q + E + A2, 1, I2 + PM + T + Q + E + A2, 1, I2 + Re + T + Q + E + A2, 1, I2 + SM + T + Q + E + A2, 1, I2 + MA + T + Q + E + A2, 1, I2 + Nq + T + Q + E + A2, 1, I2 + PL + T + Q + E + A2, 41, I2 + SK + o + T + Q + E + A2, 1, I2 + TV + o + T + Q + E + A2, 1, I2 + Xz + o + T + Q + E + A2, 1, I2 + TY + o + T + Q + E + A2, 1, I2 + RG + o + T + Q + E + A2, 1, I2 + Ro + o + T + Q + E + A2, 1, I2 + RH + o + T + Q + E + A2, 1, I2 + TW + o + T + Q + E + A2, 1, I2 + TX + o + T + Q + E + A2, 1, I2 + QE + o + T + Q + E + A2, 1, I2 + Ns + o + T + Q + E + A2, 1, I2 + Nt + o + T + Q + E + A2, 1, I2 + Nu + o + T + Q + E + A2, 1, I2 + Nw + o + T + Q + E + A2, 1, I2 + NP + o + T + Q + E + A2, 1, I2 + NQ + o + T + Q + E + A2, 1, I2 + Ik + o + T + Q + E + A2, 1, I2 + IC + o + T + Q + E + A2, 1, I2 + Hi + o + T + Q + E + A2, 1, I2 + Gz + o + T + Q + E + A2, 1, I2 + ID + o + T + Q + E + A2, 1, I2 + Io + o + T + Q + E + A2, 1, I2 + MB + o + T + Q + E + A2, 1, I2 + Nx + o + T + Q + E + A2, 1, I2 + Nr + o + T + Q + E + A2, 1, I2 + Os + o + T + Q + E + A2, 1, I2 + SL + o + T + Q + E + A2, 1, I2 + Ja + o + T + Q + E + A2, 1, I2 + KA + o + T + Q + E + A2, 1, I2 + Oq + o + T + Q + E + A2, 1, I2 + QD + o + T + Q + E + A2, 1, I2 + JN + o + T + Q + E + A2, 1, I2 + KC + o + T + Q + E + A2, 1, I2 + NR + o + T + Q + E + A2, 1, I2 + Ki + o + T + Q + E + A2, 1, I2 + Mf + o + T + Q + E + A2, 1, I2 + KD + o + T + Q + E + A2, 1, I2 + JZ + o + T + Q + E + A2, 1, I2 + JM + o + T + Q + E + A2, 1, I2 + Me + o + T + Q + E + A2, 1, I2 + Rb + o + T + Q + E + A2, 1, I2 + Rc + o + T + Q + E + A2, 1, I2 + SO + o + T + Q + E + A2, 1, I2 + Td + o + T + Q + E + A2, 1, I2 + Te + o + T + Q + E + A2, 1, I2 + QF + o + T + Q + E + A2, 1, I2 + Ny + o + T + Q + E + A2, 1, I2 + Mh + o + T + Q + E + A2, 1, I2 + Mi + o + T + Q + E + A2, 1, I2 + NS + o + T + Q + E + A2, 1, I2 + Mg + o + T + Q + E + A2, 1, I2 + NT + o + T + Q + E + A2, 1, I2 + Ot + o + T + Q + E + A2, 1, I2 + Nv + o + T + Q + E + A2, 1, I2 + PM + o + T + Q + E + A2, 1, I2 + Re + o + T + Q + E + A2, 1, I2 + SM + o + T + Q + E + A2, 1, I2 + MA + o + T + Q + E + A2, 1, I2 + Nq + o + T + Q + E + A2, 1, I2 + PL + o + T + Q + E + A2, 41, I2 + SK + S + E + A2, 1, I2 + TV + S + E + A2, 1, I2 + Xz + S + E + A2, 1, I2 + TY + S + E + A2, 1, I2 + RG + S + E + A2, 1, I2 + Ro + S + E + A2, 1, I2 + RH + S + E + A2, 1, I2 + TW + S + E + A2, 1, I2 + TX + S + E + A2, 1, I2 + QE + S + E + A2, 1, I2 + Ns + S + E + A2, 1, I2 + Nt + S + E + A2, 1, I2 + Nu + S + E + A2, 1, I2 + Nw + S + E + A2, 1, I2 + NP + S + E + A2, 1, I2 + NQ + S + E + A2, 1, I2 + Ik + S + E + A2, 1, I2 + IC + S + E + A2, 1, I2 + Hi + S + E + A2, 1, I2 + Gz + S + E + A2, 1, I2 + ID + S + E + A2, 1, I2 + Io + S + E + A2, 1, I2 + MB + S + E + A2, 1, I2 + Nx + S + E + A2, 1, I2 + Nr + S + E + A2, 1, I2 + Os + S + E + A2, 1, I2 + SL + S + E + A2, 1, I2 + Ja + S + E + A2, 1, I2 + KA + S + E + A2, 1, I2 + Oq + S + E + A2, 1, I2 + QD + S + E + A2, 1, I2 + JN + S + E + A2, 1, I2 + KC + S + E + A2, 1, I2 + NR + S + E + A2, 1, I2 + Ki + S + E + A2, 1, I2 + Mf + S + E + A2, 1, I2 + KD + S + E + A2, 1, I2 + JZ + S + E + A2, 1, I2 + JM + S + E + A2, 1, I2 + Me + S + E + A2, 1, I2 + Rb + S + E + A2, 1, I2 + Rc + S + E + A2, 1, I2 + SO + S + E + A2, 1, I2 + Td + S + E + A2, 1, I2 + Te + S + E + A2, 1, I2 + QF + S + E + A2, 1, I2 + Ny + S + E + A2, 1, I2 + Mh + S + E + A2, 1, I2 + Mi + S + E + A2, 1, I2 + NS + S + E + A2, 1, I2 + Mg + S + E + A2, 1, I2 + NT + S + E + A2, 1, I2 + Ot + S + E + A2, 1, I2 + Nv + S + E + A2, 1, I2 + PM + S + E + A2, 1, I2 + Re + S + E + A2, 1, I2 + SM + S + E + A2, 1, I2 + MA + S + E + A2, 1, I2 + Nq + S + E + A2, 1, I2 + PL + S + E + A2, 1, BP + Hr + Qm + HN + Rd + Bd + Cl + S + E + A2, 3, D + L3 + Ji + AP + k + N + S + J + A2, 1, D + L3 + Rs + AP + k + N + S + J + A2, 1, D + L3 + Jh + AP + k + N + S + J + A2, 1, D + L3 + CR + AP + k + N + S + J + A2, 34, I2 + SK + o + S + E + A2, 1, I2 + TV + o + S + E + A2, 1, I2 + Xz + o + S + E + A2, 1, I2 + TY + o + S + E + A2, 1, I2 + RG + o + S + E + A2, 1, I2 + Ro + o + S + E + A2, 1, I2 + RH + o + S + E + A2, 1, I2 + TW + o + S + E + A2, 1, I2 + TX + o + S + E + A2, 1, I2 + QE + o + S + E + A2, 1, I2 + Ns + o + S + E + A2, 1, I2 + Nt + o + S + E + A2, 1, I2 + Nu + o + S + E + A2, 1, I2 + Nw + o + S + E + A2, 1, I2 + NP + o + S + E + A2, 1, I2 + NQ + o + S + E + A2, 1, I2 + Ik + o + S + E + A2, 1, I2 + IC + o + S + E + A2, 1, I2 + Hi + o + S + E + A2, 1, I2 + Gz + o + S + E + A2, 1, I2 + ID + o + S + E + A2, 1, I2 + Io + o + S + E + A2, 1, I2 + MB + o + S + E + A2, 1, I2 + Nx + o + S + E + A2, 1, I2 + Nr + o + S + E + A2, 1, I2 + Os + o + S + E + A2, 1, I2 + SL + o + S + E + A2, 1, I2 + Ja + o + S + E + A2, 1, I2 + KA + o + S + E + A2, 1, I2 + Oq + o + S + E + A2, 1, I2 + QD + o + S + E + A2, 1, I2 + JN + o + S + E + A2, 1, I2 + KC + o + S + E + A2, 1, I2 + NR + o + S + E + A2, 1, I2 + Ki + o + S + E + A2, 1, I2 + Mf + o + S + E + A2, 1, I2 + KD + o + S + E + A2, 1, I2 + JZ + o + S + E + A2, 1, I2 + JM + o + S + E + A2, 1, I2 + Me + o + S + E + A2, 1, I2 + Rb + o + S + E + A2, 1, I2 + Rc + o + S + E + A2, 1, I2 + SO + o + S + E + A2, 1, I2 + Td + o + S + E + A2, 1, I2 + Te + o + S + E + A2, 1, I2 + QF + o + S + E + A2, 1, I2 + Ny + o + S + E + A2, 1, I2 + Mh + o + S + E + A2, 1, I2 + Mi + o + S + E + A2, 1, I2 + NS + o + S + E + A2, 1, I2 + Mg + o + S + E + A2, 1, I2 + NT + o + S + E + A2, 1, I2 + Ot + o + S + E + A2, 1, I2 + Nv + o + S + E + A2, 1, I2 + PM + o + S + E + A2, 1, I2 + Re + o + S + E + A2, 1, I2 + SM + o + S + E + A2, 1, I2 + MA + o + S + E + A2, 1, I2 + Nq + o + S + E + A2, 1, I2 + PL + o + S + E + A2, 1, BP + m + " +lat_ts=-90" + HN + Rd + Bd + Cl + S + E + A2, 5, D + L3 + PN + AP + O2 + Ak + S + E + A2].reduce((acc, it, i2) => {
      if (i2 % 2 === 0) {
        const cur = acc.prev + it;
        const code = "EPSG:" + cur;
        acc.defs.push([code]);
        acc.prev = cur;
      } else {
        acc.defs[acc.defs.length - 1].push(it);
      }
      return acc;
    }, { defs: [], prev: 0 }).defs;
  }
});

// node_modules/reproject-geojson/node_modules/proj4-fully-loaded/proj4-fully-loaded.js
var require_proj4_fully_loaded = __commonJS({
  "node_modules/reproject-geojson/node_modules/proj4-fully-loaded/proj4-fully-loaded.js"(exports4, module) {
    var proj43 = (init_lib(), __toCommonJS(lib_exports));
    var defs2 = require_proj4js_definitions();
    if (typeof proj43 === "object" && typeof proj43.defs !== "function" && typeof proj43.default === "function") {
      proj43 = proj43.default;
    }
    proj43.defs(defs2);
    module.exports = proj43;
  }
});

// node_modules/reproject-geojson/reproject-geojson.js
var require_reproject_geojson = __commonJS({
  "node_modules/reproject-geojson/reproject-geojson.js"(exports4, module) {
    var proj43 = require_proj4_fully_loaded();
    var reprojectGeoJSONPluggable = require_pluggable();
    function reprojectGeoJSON(data, { from: _from = "EPSG:4326", in_place = false, to: _to = "EPSG:4326" }) {
      if (typeof _from === "number" || _from.match(/^\d+$/))
        _from = "EPSG:" + _from;
      if (typeof _to === "number" || _to.match(/^\d+$/))
        _to = "EPSG:" + _to;
      return reprojectGeoJSONPluggable(data, {
        in_place,
        reproject: proj43(_from, _to).forward
      });
    }
    if (typeof define === "function" && define.amd)
      define(function() {
        return reprojectGeoJSON;
      });
    if (typeof module === "object")
      module.exports = reprojectGeoJSON;
    if (typeof window === "object")
      window.reprojectGeoJSON = reprojectGeoJSON;
    if (typeof self === "object")
      self.reprojectGeoJSON = reprojectGeoJSON;
  }
});

// node_modules/geomask/geomask.js
var require_geomask = __commonJS({
  "node_modules/geomask/geomask.js"(exports4, module) {
    var lite = require_lite();
    var reprojectGeoJSON = require_reproject_geojson();
    function calcMask({
      debug = false,
      fname,
      raster_bbox,
      raster_srs,
      raster_height,
      raster_width,
      pixel_height,
      pixel_width,
      mask,
      mask_srs
    }) {
      if (raster_srs !== mask_srs) {
        mask = reprojectGeoJSON(mask, { from: mask_srs, to: raster_srs });
      }
      return lite[fname]({
        debug,
        raster_bbox,
        raster_height,
        raster_width,
        pixel_height,
        pixel_width,
        mask
      });
    }
    function inside(options) {
      return calcMask({ ...options, fname: "inside" });
    }
    function outside(options) {
      return calcMask({ ...options, fname: "outside" });
    }
    var geomask = { inside, outside };
    if (typeof module === "object")
      module.exports = geomask;
  }
});

// node_modules/geocanvas/src/core.js
var require_core = __commonJS({
  "node_modules/geocanvas/src/core.js"(exports4, module) {
    function maskImageData({
      data,
      data_bbox,
      data_height,
      data_width,
      data_srs,
      debug = false,
      geomask,
      mask,
      mask_srs,
      reproject,
      strategy = "outside",
      edition
    }) {
      if (!["inside", "outside"].includes(strategy)) {
        throw new Error(`[geocanvas] strategy can be either "inside" or "outside". you provided "${strategy}"`);
      }
      const { rows } = geomask[strategy]({
        raster_bbox: data_bbox,
        raster_height: data_height,
        raster_width: data_width,
        raster_srs: data_srs,
        mask,
        mask_srs,
        reproject
      });
      rows.forEach((ranges, r) => {
        if (ranges) {
          const row_offset = r * 4 * data_width;
          ranges.forEach(([start2, end]) => {
            for (let c = start2; c <= end; c++) {
              data[row_offset + c * 4 + 3] = 0;
            }
          });
        }
      });
    }
    function maskCanvas({
      canvas,
      canvas_bbox,
      canvas_srs,
      geomask,
      mask,
      mask_srs,
      reproject,
      strategy = "outside",
      edition,
      debug = false
    }) {
      if (debug)
        console.log("[geocanvas] starting to mask canvas");
      if (!["inside", "outside"].includes(strategy)) {
        throw new Error(`[geocanvas] strategy can be either "inside" or "outside". you provided "${strategy}"`);
      }
      const context = canvas.getContext("2d");
      const { height, width } = canvas;
      if (debug)
        console.log(`[geocanvas] canvas height is ${height} pixels`);
      if (debug)
        console.log(`[geocanvas] canvas width is ${width} pixels`);
      const imageData = context.getImageData(0, 0, width, height);
      maskImageData({
        data: imageData.data,
        data_bbox: canvas_bbox,
        data_height: height,
        data_srs: canvas_srs,
        data_width: width,
        debug,
        geomask,
        mask,
        mask_srs,
        reproject,
        strategy
      });
      if (debug)
        console.log("[geocanvas] image data after masking:", imageData);
      context.putImageData(imageData, 0, 0);
      if (debug)
        console.log("[geocanvas] put image data back");
      return canvas;
    }
    module.exports = { maskImageData, maskCanvas };
  }
});

// node_modules/geocanvas/src/full.js
var require_full = __commonJS({
  "node_modules/geocanvas/src/full.js"(exports4, module) {
    var geomask = require_geomask();
    var core = require_core();
    function maskImageData(options) {
      return core.maskImageData({ ...options, edition: "full", geomask });
    }
    function maskCanvas(options) {
      return core.maskCanvas({ ...options, edition: "full", geomask });
    }
    var geocanvas2 = { maskImageData, maskCanvas };
    if (typeof define === "function" && define.amd)
      define(function() {
        return geocanvas2;
      });
    if (typeof module === "object")
      module.exports = geocanvas2;
    if (typeof self === "object")
      self.geocanvas = geocanvas2;
    if (typeof window === "object")
      window.geocanvas = geocanvas2;
  }
});

// node_modules/iter-fun/index.js
var require_iter_fun = __commonJS({
  "node_modules/iter-fun/index.js"(exports4, module) {
    function addSymbolIterator(obj2) {
      try {
        obj2[Symbol.iterator] = function() {
          return this;
        };
      } catch (error) {
      }
    }
    function addSymbolIteratorFallback(obj2) {
      obj2["@@iterator"] = function() {
        return this;
      };
    }
    function wrapNextFunction(next) {
      const iter = { next };
      addSymbolIterator(iter);
      addSymbolIteratorFallback(iter);
      return iter;
    }
    function isArray(data) {
      try {
        return data.constructor.name.endsWith("Array");
      } catch {
        return false;
      }
    }
    function hasNext(data) {
      try {
        return typeof data.next === "function";
      } catch {
        return false;
      }
    }
    function hasIterator(data) {
      try {
        return "@@iterator" in data;
      } catch {
        return false;
      }
    }
    function hasSymbolIterator(data) {
      try {
        return Symbol.iterator in data.constructor.prototype;
      } catch {
        return false;
      }
    }
    function isIterator(data) {
      try {
        return Symbol.iterator in data && typeof data.next === "function" && data.propertyIsEnumerable("next") === false;
      } catch {
        return false;
      }
    }
    function getIterator(data) {
      const iter = data["@@iterator"];
      if (hasNext(iter)) {
        return iter;
      } else if (typeof iter === "function") {
        return iter();
      }
    }
    function createIterator(data) {
      let i = 0;
      let len = data.length;
      const next = () => i++ < len ? { value: data[i], done: false } : { done: true };
      return wrapNextFunction(next);
    }
    function getOrCreateIterator(data) {
      if (isIterator(data)) {
        return data;
      } else if (hasSymbolIterator(data)) {
        return data[Symbol.iterator]();
      } else if (hasNext(data)) {
        return wrapNextFunction(data.next);
      } else if (hasIterator(data)) {
        return getIterator(data);
      } else if (typeof data === "string" || isArray(data)) {
        return createIterator(data);
      } else {
        throw "[iter-fun] unable to determine iterator";
      }
    }
    function zip2(iters) {
      iters = iters.map(getOrCreateIterator);
      return wrapNextFunction(function next() {
        const values = iters.map((iter) => iter.next());
        if (values.every(({ done }) => done)) {
          return { done: true };
        } else {
          return {
            done: false,
            value: values.map(({ value }) => value)
          };
        }
      });
    }
    if (typeof module === "object") {
      module.exports = {
        addSymbolIterator,
        addSymbolIteratorFallback,
        isIterator,
        isArray,
        hasNext,
        hasSymbolIterator,
        hasIterator,
        getIterator,
        createIterator,
        getOrCreateIterator,
        wrapNextFunction,
        zip: zip2
      };
    }
  }
});

// node_modules/xdim/src/prepared-select-funcs.js
var require_prepared_select_funcs = __commonJS({
  "node_modules/xdim/src/prepared-select-funcs.js"(exports4, module) {
    module.exports = {
      "1": function({ point: point3 }) {
        const parent = this.data;
        const index = point3[this.d0v0];
        return { parent, index, value: parent[index] };
      },
      "2": function({ point: point3 }) {
        const parent = this.data;
        const index = this.m0v0 * point3[this.d0v0] + this.m0v1 * point3[this.d0v1];
        return { parent, index, value: parent[index] };
      },
      "3": function({ point: point3 }) {
        const parent = this.data;
        const index = this.m0v0 * point3[this.d0v0] + this.m0v1 * point3[this.d0v1] + this.m0v2 * point3[this.d0v2];
        return { parent, index, value: parent[index] };
      },
      "4": function({ point: point3 }) {
        const parent = this.data;
        const index = this.m0v0 * point3[this.d0v0] + this.m0v1 * point3[this.d0v1] + this.m0v2 * point3[this.d0v2] + this.m0v3 * point3[this.d0v3];
        return { parent, index, value: parent[index] };
      },
      "5": function({ point: point3 }) {
        const parent = this.data;
        const index = this.m0v0 * point3[this.d0v0] + this.m0v1 * point3[this.d0v1] + this.m0v2 * point3[this.d0v2] + this.m0v3 * point3[this.d0v3] + this.m0v4 * point3[this.d0v4];
        return { parent, index, value: parent[index] };
      },
      "1,1": function({ point: point3 }) {
        const parent = this.data[point3[this.d0v0]];
        const index = point3[this.d1v0];
        return { parent, index, value: parent[index] };
      },
      "1,2": function({ point: point3 }) {
        const parent = this.data[point3[this.d0v0]];
        const index = this.m1v0 * point3[this.d1v0] + this.m1v1 * point3[this.d1v1];
        return { parent, index, value: parent[index] };
      },
      "1,3": function({ point: point3 }) {
        const parent = this.data[point3[this.d0v0]];
        const index = this.m1v0 * point3[this.d1v0] + this.m1v1 * point3[this.d1v1] + this.m1v2 * point3[this.d1v2];
        return { parent, index, value: parent[index] };
      },
      "1,4": function({ point: point3 }) {
        const parent = this.data[point3[this.d0v0]];
        const index = this.m1v0 * point3[this.d1v0] + this.m1v1 * point3[this.d1v1] + this.m1v2 * point3[this.d1v2] + this.m1v3 * point3[this.d1v3];
        return { parent, index, value: parent[index] };
      },
      "1,5": function({ point: point3 }) {
        const parent = this.data[point3[this.d0v0]];
        const index = this.m1v0 * point3[this.d1v0] + this.m1v1 * point3[this.d1v1] + this.m1v2 * point3[this.d1v2] + this.m1v3 * point3[this.d1v3] + this.m1v4 * point3[this.d1v4];
        return { parent, index, value: parent[index] };
      },
      "1,1,1": function({ point: point3 }) {
        const parent = this.data[point3[this.d0v0]][point3[this.d1v0]];
        const index = point3[this.d2v0];
        return { parent, index, value: parent[index] };
      },
      "1,1,2": function({ point: point3 }) {
        const parent = this.data[point3[this.d0v0]][point3[this.d1v0]];
        const index = this.m2v0 * point3[this.d2v0] + this.m2v1 * point3[this.d2v1];
        return { parent, index, value: parent[index] };
      },
      "1,1,3": function({ point: point3 }) {
        const parent = this.data[point3[this.d0v0]][point3[this.d1v0]];
        const index = this.m2v0 * point3[this.d2v0] + this.m2v1 * point3[this.d2v1] + this.m2v2 * point3[this.d2v2];
        return { parent, index, value: parent[index] };
      },
      "1,1,4": function({ point: point3 }) {
        const parent = this.data[point3[this.d0v0]][point3[this.d1v0]];
        const index = this.m2v0 * point3[this.d2v0] + this.m2v1 * point3[this.d2v1] + this.m2v2 * point3[this.d2v2] + this.m2v3 * point3[this.d2v3];
        return { parent, index, value: parent[index] };
      },
      "1,1,5": function({ point: point3 }) {
        const parent = this.data[point3[this.d0v0]][point3[this.d1v0]];
        const index = this.m2v0 * point3[this.d2v0] + this.m2v1 * point3[this.d2v1] + this.m2v2 * point3[this.d2v2] + this.m2v3 * point3[this.d2v3] + this.m2v4 * point3[this.d2v4];
        return { parent, index, value: parent[index] };
      },
      "1,1,1,1": function({ point: point3 }) {
        const parent = this.data[point3[this.d0v0]][point3[this.d1v0]][point3[this.d2v0]];
        const index = point3[this.d3v0];
        return { parent, index, value: parent[index] };
      },
      "1,1,1,2": function({ point: point3 }) {
        const parent = this.data[point3[this.d0v0]][point3[this.d1v0]][point3[this.d2v0]];
        const index = this.m3v0 * point3[this.d3v0] + this.m3v1 * point3[this.d3v1];
        return { parent, index, value: parent[index] };
      },
      "1,1,1,3": function({ point: point3 }) {
        const parent = this.data[point3[this.d0v0]][point3[this.d1v0]][point3[this.d2v0]];
        const index = this.m3v0 * point3[this.d3v0] + this.m3v1 * point3[this.d3v1] + this.m3v2 * point3[this.d3v2];
        return { parent, index, value: parent[index] };
      },
      "1,1,1,4": function({ point: point3 }) {
        const parent = this.data[point3[this.d0v0]][point3[this.d1v0]][point3[this.d2v0]];
        const index = this.m3v0 * point3[this.d3v0] + this.m3v1 * point3[this.d3v1] + this.m3v2 * point3[this.d3v2] + this.m3v3 * point3[this.d3v3];
        return { parent, index, value: parent[index] };
      },
      "1,1,1,5": function({ point: point3 }) {
        const parent = this.data[point3[this.d0v0]][point3[this.d1v0]][point3[this.d2v0]];
        const index = this.m3v0 * point3[this.d3v0] + this.m3v1 * point3[this.d3v1] + this.m3v2 * point3[this.d3v2] + this.m3v3 * point3[this.d3v3] + this.m3v4 * point3[this.d3v4];
        return { parent, index, value: parent[index] };
      },
      "1,1,1,1,1": function({ point: point3 }) {
        const parent = this.data[point3[this.d0v0]][point3[this.d1v0]][point3[this.d2v0]][point3[this.d3v0]];
        const index = point3[this.d4v0];
        return { parent, index, value: parent[index] };
      },
      "1,1,1,1,2": function({ point: point3 }) {
        const parent = this.data[point3[this.d0v0]][point3[this.d1v0]][point3[this.d2v0]][point3[this.d3v0]];
        const index = this.m4v0 * point3[this.d4v0] + this.m4v1 * point3[this.d4v1];
        return { parent, index, value: parent[index] };
      },
      "1,1,1,1,3": function({ point: point3 }) {
        const parent = this.data[point3[this.d0v0]][point3[this.d1v0]][point3[this.d2v0]][point3[this.d3v0]];
        const index = this.m4v0 * point3[this.d4v0] + this.m4v1 * point3[this.d4v1] + this.m4v2 * point3[this.d4v2];
        return { parent, index, value: parent[index] };
      },
      "1,1,1,1,4": function({ point: point3 }) {
        const parent = this.data[point3[this.d0v0]][point3[this.d1v0]][point3[this.d2v0]][point3[this.d3v0]];
        const index = this.m4v0 * point3[this.d4v0] + this.m4v1 * point3[this.d4v1] + this.m4v2 * point3[this.d4v2] + this.m4v3 * point3[this.d4v3];
        return { parent, index, value: parent[index] };
      },
      "1,1,1,1,5": function({ point: point3 }) {
        const parent = this.data[point3[this.d0v0]][point3[this.d1v0]][point3[this.d2v0]][point3[this.d3v0]];
        const index = this.m4v0 * point3[this.d4v0] + this.m4v1 * point3[this.d4v1] + this.m4v2 * point3[this.d4v2] + this.m4v3 * point3[this.d4v3] + this.m4v4 * point3[this.d4v4];
        return { parent, index, value: parent[index] };
      }
    };
  }
});

// node_modules/xdim/src/prepared-update-funcs.js
var require_prepared_update_funcs = __commonJS({
  "node_modules/xdim/src/prepared-update-funcs.js"(exports4, module) {
    module.exports = {
      "1": function({ point: point3, value }) {
        this.data[point3[this.d0v0]] = value;
      },
      "2": function({ point: point3, value }) {
        this.data[this.m0v0 * point3[this.d0v0] + this.m0v1 * point3[this.d0v1]] = value;
      },
      "3": function({ point: point3, value }) {
        this.data[this.m0v0 * point3[this.d0v0] + this.m0v1 * point3[this.d0v1] + this.m0v2 * point3[this.d0v2]] = value;
      },
      "4": function({ point: point3, value }) {
        this.data[this.m0v0 * point3[this.d0v0] + this.m0v1 * point3[this.d0v1] + this.m0v2 * point3[this.d0v2] + this.m0v3 * point3[this.d0v3]] = value;
      },
      "5": function({ point: point3, value }) {
        this.data[this.m0v0 * point3[this.d0v0] + this.m0v1 * point3[this.d0v1] + this.m0v2 * point3[this.d0v2] + this.m0v3 * point3[this.d0v3] + this.m0v4 * point3[this.d0v4]] = value;
      },
      "1,1": function({ point: point3, value }) {
        this.data[point3[this.d0v0]][point3[this.d1v0]] = value;
      },
      "1,2": function({ point: point3, value }) {
        this.data[point3[this.d0v0]][this.m1v0 * point3[this.d1v0] + this.m1v1 * point3[this.d1v1]] = value;
      },
      "1,3": function({ point: point3, value }) {
        this.data[point3[this.d0v0]][this.m1v0 * point3[this.d1v0] + this.m1v1 * point3[this.d1v1] + this.m1v2 * point3[this.d1v2]] = value;
      },
      "1,4": function({ point: point3, value }) {
        this.data[point3[this.d0v0]][this.m1v0 * point3[this.d1v0] + this.m1v1 * point3[this.d1v1] + this.m1v2 * point3[this.d1v2] + this.m1v3 * point3[this.d1v3]] = value;
      },
      "1,5": function({ point: point3, value }) {
        this.data[point3[this.d0v0]][this.m1v0 * point3[this.d1v0] + this.m1v1 * point3[this.d1v1] + this.m1v2 * point3[this.d1v2] + this.m1v3 * point3[this.d1v3] + this.m1v4 * point3[this.d1v4]] = value;
      },
      "1,1,1": function({ point: point3, value }) {
        this.data[point3[this.d0v0]][point3[this.d1v0]][point3[this.d2v0]] = value;
      },
      "1,1,2": function({ point: point3, value }) {
        this.data[point3[this.d0v0]][point3[this.d1v0]][this.m2v0 * point3[this.d2v0] + this.m2v1 * point3[this.d2v1]] = value;
      },
      "1,1,3": function({ point: point3, value }) {
        this.data[point3[this.d0v0]][point3[this.d1v0]][this.m2v0 * point3[this.d2v0] + this.m2v1 * point3[this.d2v1] + this.m2v2 * point3[this.d2v2]] = value;
      },
      "1,1,4": function({ point: point3, value }) {
        this.data[point3[this.d0v0]][point3[this.d1v0]][this.m2v0 * point3[this.d2v0] + this.m2v1 * point3[this.d2v1] + this.m2v2 * point3[this.d2v2] + this.m2v3 * point3[this.d2v3]] = value;
      },
      "1,1,5": function({ point: point3, value }) {
        this.data[point3[this.d0v0]][point3[this.d1v0]][this.m2v0 * point3[this.d2v0] + this.m2v1 * point3[this.d2v1] + this.m2v2 * point3[this.d2v2] + this.m2v3 * point3[this.d2v3] + this.m2v4 * point3[this.d2v4]] = value;
      },
      "1,1,1,1": function({ point: point3, value }) {
        this.data[point3[this.d0v0]][point3[this.d1v0]][point3[this.d2v0]][point3[this.d3v0]] = value;
      },
      "1,1,1,2": function({ point: point3, value }) {
        this.data[point3[this.d0v0]][point3[this.d1v0]][point3[this.d2v0]][this.m3v0 * point3[this.d3v0] + this.m3v1 * point3[this.d3v1]] = value;
      },
      "1,1,1,3": function({ point: point3, value }) {
        this.data[point3[this.d0v0]][point3[this.d1v0]][point3[this.d2v0]][this.m3v0 * point3[this.d3v0] + this.m3v1 * point3[this.d3v1] + this.m3v2 * point3[this.d3v2]] = value;
      },
      "1,1,1,4": function({ point: point3, value }) {
        this.data[point3[this.d0v0]][point3[this.d1v0]][point3[this.d2v0]][this.m3v0 * point3[this.d3v0] + this.m3v1 * point3[this.d3v1] + this.m3v2 * point3[this.d3v2] + this.m3v3 * point3[this.d3v3]] = value;
      },
      "1,1,1,5": function({ point: point3, value }) {
        this.data[point3[this.d0v0]][point3[this.d1v0]][point3[this.d2v0]][this.m3v0 * point3[this.d3v0] + this.m3v1 * point3[this.d3v1] + this.m3v2 * point3[this.d3v2] + this.m3v3 * point3[this.d3v3] + this.m3v4 * point3[this.d3v4]] = value;
      },
      "1,1,1,1,1": function({ point: point3, value }) {
        this.data[point3[this.d0v0]][point3[this.d1v0]][point3[this.d2v0]][point3[this.d3v0]][point3[this.d4v0]] = value;
      },
      "1,1,1,1,2": function({ point: point3, value }) {
        this.data[point3[this.d0v0]][point3[this.d1v0]][point3[this.d2v0]][point3[this.d3v0]][this.m4v0 * point3[this.d4v0] + this.m4v1 * point3[this.d4v1]] = value;
      },
      "1,1,1,1,3": function({ point: point3, value }) {
        this.data[point3[this.d0v0]][point3[this.d1v0]][point3[this.d2v0]][point3[this.d3v0]][this.m4v0 * point3[this.d4v0] + this.m4v1 * point3[this.d4v1] + this.m4v2 * point3[this.d4v2]] = value;
      },
      "1,1,1,1,4": function({ point: point3, value }) {
        this.data[point3[this.d0v0]][point3[this.d1v0]][point3[this.d2v0]][point3[this.d3v0]][this.m4v0 * point3[this.d4v0] + this.m4v1 * point3[this.d4v1] + this.m4v2 * point3[this.d4v2] + this.m4v3 * point3[this.d4v3]] = value;
      },
      "1,1,1,1,5": function({ point: point3, value }) {
        this.data[point3[this.d0v0]][point3[this.d1v0]][point3[this.d2v0]][point3[this.d3v0]][this.m4v0 * point3[this.d4v0] + this.m4v1 * point3[this.d4v1] + this.m4v2 * point3[this.d4v2] + this.m4v3 * point3[this.d4v3] + this.m4v4 * point3[this.d4v4]] = value;
      }
    };
  }
});

// node_modules/xdim/src/xdim.js
var require_xdim = __commonJS({
  "node_modules/xdim/src/xdim.js"(exports4, module) {
    var layoutCache = {};
    var { wrapNextFunction } = require_iter_fun();
    var preparedSelectFunctions = require_prepared_select_funcs();
    var preparedUpdateFunctions = require_prepared_update_funcs();
    var ARRAY_TYPES = {
      Array,
      Int8Array,
      Uint8Array,
      Uint8ClampedArray,
      Int16Array,
      Uint16Array,
      Float32Array,
      Float64Array
    };
    try {
      ARRAY_TYPES.BigInt64Array = BigInt64Array;
      ARRAY_TYPES.BigUint64Array = BigUint64Array;
    } catch (error) {
    }
    function parseDimensions(str) {
      const dims = {};
      const re = /[A-Za-z]+/g;
      let arr;
      while ((arr = re.exec(str)) !== null) {
        const [match2] = arr;
        dims[match2] = {
          name: match2
        };
      }
      return dims;
    }
    var parseVectors = (str) => str.match(/\[[^\]]+\]/g);
    var removeBraces = (str) => str.startsWith("[") && str.endsWith("]") ? str.substring(1, str.length - 1) : str;
    var removeParentheses = (str) => str.startsWith("(") && str.endsWith(")") ? str.substring(1, str.length - 1) : str;
    var matchSequences = (str) => str.match(/(\(.*?\)|[^\(,\s]+)(?=\s*,|\s*$)/g);
    var parseSequences = (str) => {
      str = removeBraces(str);
      str = removeParentheses(str);
      const seqs = matchSequences(str);
      if (seqs.length === 1) {
        return {
          type: "Vector",
          dim: seqs[0]
        };
      } else {
        return {
          type: "Matrix",
          parts: seqs.map(parseSequences)
        };
      }
    };
    function checkValidity(str) {
      const invalid = str.match(/[^ A-Za-z,\[\]]/g);
      if (invalid) {
        throw new Error("The following invalid characters were used: " + invalid.map((c) => `"${c}"`).join(", "));
      } else {
        return true;
      }
    }
    function parse2(str, { useLayoutCache = true } = { useLayoutCache: true }) {
      if (useLayoutCache && str in layoutCache)
        return layoutCache[str];
      checkValidity(str);
      const vectors = parseVectors(str);
      const dims = vectors.map(parseSequences);
      const result2 = {
        type: "Layout",
        summary: dims.map((it) => it.type === "Matrix" ? it.parts.length : 1),
        dims
      };
      if (useLayoutCache)
        layoutCache[str] = result2;
      return result2;
    }
    function update({ useLayoutCache = true, data, layout, point: point3, sizes = {}, value }) {
      if (typeof layout === "string")
        layout = parse2(layout, { useLayoutCache });
      const { dims } = layout;
      for (let idim = 0; idim < dims.length; idim++) {
        const last = idim === dims.length - 1;
        const arr = dims[idim];
        let offset;
        if (arr.type === "Vector") {
          offset = point3[arr.dim];
        } else {
          const { parts } = arr;
          offset = 0;
          let multiplier = 1;
          for (let i = parts.length - 1; i >= 0; i--) {
            const part = parts[i];
            const { dim } = part;
            offset += multiplier * point3[dim];
            if (i > 0) {
              if (!(dim in sizes))
                throw new Error(`you cannot calculate the location without knowing the size of the "${dim}" dimension.`);
              multiplier *= sizes[dim];
            }
          }
        }
        if (last) {
          data[offset] = value;
        } else {
          data = data[offset];
        }
      }
    }
    function prepareUpdate2({ useLayoutCache = true, data, layout, sizes = {} }) {
      if (typeof layout === "string") {
        layout = parse2(layout, { useLayoutCache });
      }
      const { dims } = layout;
      const numDims = dims.length;
      const multipliers = getMultipliers({ useLayoutCache, layout, sizes });
      const end = numDims - 1;
      const key = layout.summary.toString();
      if (key in preparedUpdateFunctions) {
        const _this = { data };
        layout.dims.map((it, depth) => {
          if (it.type === "Vector") {
            _this[`d${depth}v0`] = it.dim;
          } else if (it.type === "Matrix") {
            it.parts.forEach((part, ipart) => {
              _this[`d${depth}v${ipart}`] = part.dim;
              _this[`m${depth}v${ipart}`] = multipliers[part.dim];
            });
          }
        });
        return preparedUpdateFunctions[key].bind(_this);
      }
      return ({ point: point3, value }) => {
        let currentData = data;
        for (let idim = 0; idim < numDims; idim++) {
          const last = idim === end;
          const arr = dims[idim];
          let offset;
          if (arr.type === "Vector") {
            offset = point3[arr.dim];
          } else {
            offset = arr.parts.reduce((acc, { dim }) => acc + multipliers[dim] * point3[dim], 0);
          }
          if (last) {
            currentData[offset] = value;
          } else {
            currentData = currentData[offset];
          }
        }
      };
    }
    function iterClip({ data, layout, order, rect = {}, sizes = {}, useLayoutCache = true }) {
      if (!data)
        throw new Error("[xdim] must specify data");
      if (!layout)
        throw new Error("[xdim] must specify layout");
      const points = iterPoints({ order, sizes, rect });
      return wrapNextFunction(function next() {
        const { value: point3, done } = points.next();
        if (done) {
          return { done: true };
        } else {
          const { value } = select({ data, layout, point: point3, sizes, useLayoutCache });
          return { done: false, value };
        }
      });
    }
    function validateRect({ rect = {} }) {
      if (rect) {
        for (let key in rect) {
          const value = rect[key];
          if (value.length !== 2)
            throw new Error(`[xdim] uh oh. invalid hyper-rectangle`);
          const [start2, end] = value;
          if (start2 > end)
            throw new Error(`[xdim] uh oh. invalid range for "${key}".  Start of ${start2} can't be greater than end of ${end}.`);
          if (start2 < 0)
            throw new Error(`[xdim] uh oh. invalid hyper-rectangle with start ${start2}`);
        }
      }
    }
    function clip({ useLayoutCache = true, data, layout, rect, sizes = {}, flat = false, validate = true }) {
      if (validate)
        validateRect({ rect });
      if (typeof layout === "string")
        layout = parse2(layout, { useLayoutCache });
      let datas = [data];
      layout.dims.forEach((arr) => {
        let new_datas = [];
        datas.forEach((data2) => {
          if (arr.type === "Vector") {
            const [start2, end] = rect[arr.dim];
            new_datas = new_datas.concat(data2.slice(start2, end + 1));
          } else {
            const { parts } = arr;
            let offsets = [0];
            let multiplier = 1;
            for (let i = parts.length - 1; i >= 0; i--) {
              const part = parts[i];
              const { dim } = part;
              const [start2, end] = rect[dim];
              const new_offsets = [];
              for (let n = start2; n <= end; n++) {
                offsets.forEach((offset) => {
                  new_offsets.push(offset + multiplier * n);
                });
              }
              offsets = new_offsets;
              multiplier *= sizes[dim];
            }
            offsets.forEach((offset) => {
              new_datas.push(data2[offset]);
            });
          }
        });
        datas = new_datas;
      });
      if (flat) {
        return {
          data: datas
        };
      }
      const out_sizes = Object.fromEntries(Object.entries(rect).map(([dim, [start2, end]]) => [dim, end - start2 + 1]));
      const { data: out_data } = prepareData2({
        layout,
        sizes: out_sizes
      });
      const max_depth = layout.dims.length;
      const step = (arr, depth) => {
        if (depth === max_depth) {
          for (let i = 0; i < arr.length; i++) {
            arr[i] = datas.shift();
          }
        } else {
          arr.forEach((sub) => step(sub, depth + 1));
        }
      };
      step(out_data, 1);
      return { data: out_data };
    }
    function getMultipliers({ useLayoutCache = true, layout, sizes }) {
      if (typeof layout === "string") {
        layout = parse2(layout, { useLayoutCache });
      }
      const { dims } = layout;
      const numDims = dims.length;
      let multipliers = {};
      for (let idim = 0; idim < numDims; idim++) {
        const arr = dims[idim];
        if (arr.type === "Vector") {
          multipliers[arr.dim] = 1;
        } else {
          const { parts } = arr;
          let multiplier = 1;
          for (let i = parts.length - 1; i >= 0; i--) {
            const { dim } = parts[i];
            multipliers[dim] = multiplier;
            multiplier *= sizes[parts[i].dim];
          }
        }
      }
      return multipliers;
    }
    function prepareSelect({ useLayoutCache = true, data, layout, sizes = {} }) {
      if (typeof layout === "string") {
        layout = parse2(layout, { useLayoutCache });
      }
      const { dims } = layout;
      const numDims = dims.length;
      const multipliers = getMultipliers({ useLayoutCache, layout, sizes });
      const end = numDims - 1;
      const key = layout.summary.toString();
      if (key in preparedSelectFunctions) {
        const _this = { data };
        layout.dims.map((it, depth) => {
          if (it.type === "Vector") {
            _this[`d${depth}v0`] = it.dim;
          } else if (it.type === "Matrix") {
            it.parts.forEach((part, ipart) => {
              _this[`d${depth}v${ipart}`] = part.dim;
              _this[`m${depth}v${ipart}`] = multipliers[part.dim];
            });
          }
        });
        return preparedSelectFunctions[key].bind(_this);
      }
      return ({ point: point3 }) => {
        let currentData = data;
        for (let idim = 0; idim < numDims; idim++) {
          const last = idim === end;
          const arr = dims[idim];
          let offset;
          if (arr.type === "Vector") {
            offset = point3[arr.dim];
          } else {
            offset = arr.parts.reduce((acc, { dim }) => acc + multipliers[dim] * point3[dim], 0);
          }
          if (last) {
            return {
              index: offset,
              parent: currentData,
              value: currentData[offset]
            };
          } else {
            currentData = currentData[offset];
          }
        }
      };
    }
    function select({ useLayoutCache = true, data, layout, point: point3, sizes = {} }) {
      if (typeof layout === "string") {
        layout = parse2(layout, { useLayoutCache });
      }
      let parent;
      let index;
      let value = data;
      const { dims } = layout;
      const len = dims.length;
      for (let idim = 0; idim < len; idim++) {
        const arr = dims[idim];
        if (arr.type === "Vector") {
          const i = point3[arr.dim];
          parent = value;
          index = i;
          value = value[i];
        } else {
          const { parts } = arr;
          let offset = 0;
          let multiplier = 1;
          for (let i = parts.length - 1; i >= 0; i--) {
            const part = parts[i];
            if (part.type === "Vector") {
              const { dim } = part;
              offset += multiplier * point3[dim];
              if (i > 0) {
                if (!(dim in sizes))
                  throw new Error(`you cannot calculate the location without knowing the size of the "${dim}" dimension.`);
                multiplier *= sizes[dim];
              }
            }
          }
          parent = value;
          index = offset;
          value = value[offset];
        }
      }
      return { index, value, parent };
    }
    function addDims({ arr, fill = void 0, lens, arrayTypes }) {
      if (lens.length === 0)
        return arr;
      const len = lens[0];
      if (lens.length === 1) {
        const lastArrayType = arrayTypes ? arrayTypes[arrayTypes.length - 1] : "Array";
        for (let i = 0; i < arr.length; i++) {
          arr[i] = new ARRAY_TYPES[lastArrayType](len).fill(fill);
        }
      } else {
        for (let i = 0; i < arr.length; i++) {
          const sub = new Array(len).fill(fill);
          arr[i] = sub;
          addDims({ arr: sub, fill, lens: lens.slice(1), arrayTypes });
        }
      }
      return arr;
    }
    function createMatrix({ fill = void 0, shape, arrayTypes }) {
      const len = shape[0];
      if (shape.length === 1) {
        if (Array.isArray(arrayTypes) && arrayTypes.length !== 1)
          throw new Error("[xdim] shape and arrayTypes have different lengths");
        const arrayType = Array.isArray(arrayTypes) ? arrayTypes[0] : "Array";
        return new ARRAY_TYPES[arrayType](len).fill(fill);
      }
      const arr = new Array(len).fill(fill);
      return addDims({ arr, fill, lens: shape.slice(1), arrayTypes });
    }
    function prepareData2({ fill = void 0, layout, useLayoutCache = true, sizes, arrayTypes }) {
      if (typeof layout === "string")
        layout = parse2(layout, { useLayoutCache });
      const shape = layout.dims.map((it) => {
        if (it.type === "Vector") {
          return sizes[it.dim];
        } else if (it.type === "Matrix") {
          return it.parts.reduce((total, part) => {
            if (!(part.dim in sizes))
              throw new Error(`[xdim] could not find "${part.dim}" in sizes: { ${Object.keys(sizes).join(", ")} }`);
            return total * sizes[part.dim];
          }, 1);
        }
      });
      const data = createMatrix({ fill, shape, arrayTypes });
      return { data, shape, arrayTypes };
    }
    function iterRange({ start: start2 = 0, end = 100 }) {
      let i = start2 - 1;
      end = end + 1;
      return wrapNextFunction(function next() {
        i++;
        if (i === end) {
          return { done: true };
        } else {
          return { done: false, value: i };
        }
      });
    }
    function iterPoints({ order, sizes, rect = {} }) {
      const names34 = Array.isArray(order) ? order : Object.keys(sizes).sort((a, b) => sizes[a] - sizes[b]);
      const iters = new Array(names34.length);
      const current = {};
      for (let i = 0; i < names34.length - 1; i++) {
        const name = names34[i];
        const [start3, end2] = rect[name] || [0, sizes[name] - 1];
        iters[i] = iterRange({ start: start3 + 1, end: end2 });
        current[name] = start3;
      }
      const lastName = names34[names34.length - 1];
      const [start2, end] = rect[lastName] || [0, sizes[lastName] - 1];
      iters[iters.length - 1] = iterRange({ start: start2, end });
      current[lastName] = start2 - 1;
      return wrapNextFunction(function next() {
        for (let i = iters.length - 1; i >= 0; i--) {
          const { value, done } = iters[i].next();
          if (done) {
            if (i === 0) {
              return { done: true };
            }
          } else {
            for (let ii = i + 1; ii < iters.length; ii++) {
              const nameii = names34[ii];
              const [start3, end2] = rect[nameii] || [0, sizes[nameii] - 1];
              iters[ii] = iterRange({ start: start3 + 1, end: end2 });
              current[nameii] = start3;
            }
            current[names34[i]] = value;
            return { value: current, done: false };
          }
        }
      });
    }
    function transform2({ data, fill = void 0, from, to, sizes, useLayoutCache = true }) {
      if (typeof from === "string")
        from = parse2(from, { useLayoutCache });
      if (typeof to === "string")
        to = parse2(to, { useLayoutCache });
      const { data: out_data } = prepareData2({ fill, layout: to, sizes });
      const update2 = prepareUpdate2({
        useLayoutCache,
        data: out_data,
        layout: to,
        sizes
      });
      const points = iterPoints({ sizes });
      for (point of points) {
        const { value } = select({
          data,
          layout: from,
          point,
          sizes
        });
        update2({
          point,
          value
        });
      }
      return { data: out_data };
    }
    module.exports = {
      addDims,
      checkValidity,
      createMatrix,
      iterClip,
      iterRange,
      iterPoints,
      matchSequences,
      parse: parse2,
      parseDimensions,
      parseSequences,
      parseVectors,
      prepareData: prepareData2,
      prepareSelect,
      prepareUpdate: prepareUpdate2,
      removeBraces,
      removeParentheses,
      select,
      transform: transform2,
      update,
      clip,
      validateRect
    };
  }
});

// node_modules/quick-scale/quick-scale.js
var require_quick_scale = __commonJS({
  "node_modules/quick-scale/quick-scale.js"(exports4, module) {
    function _identity(n) {
      return n;
    }
    function _scale_number(old_min, old_range, new_min, new_range, n) {
      return new_min + new_range * (n - old_min) / old_range;
    }
    function _scale_and_flip_number(old_min, old_range, new_max, new_range, n) {
      return new_max - new_range * (n - old_min) / old_range;
    }
    function _scale_and_round_number(old_min, old_range, new_min, new_range, n) {
      return Math.round(new_min + new_range * (n - old_min) / old_range);
    }
    function _scale_and_flip_and_round_number(old_min, old_range, new_max, new_range, n) {
      return Math.round(new_max - new_range * (n - old_min) / old_range);
    }
    function createScaleFunction3([old_min, old_max], [new_min, new_max], { flip, no_range_value, no_range_value_strategy = "highest", round = false } = {}) {
      const old_range = old_max - old_min;
      const new_range = new_max - new_min;
      if (old_range === 0) {
        if (typeof no_range_value === "number") {
          return _identity.bind(null, no_range_value);
        } else if (no_range_value_strategy === "highest") {
          return _identity.bind(null, new_max);
        } else if (no_range_value_strategy === "lowest") {
          return _identity.bind(null, new_min);
        } else if (no_range_value_strategy === "middle") {
          let n = (new_max - new_min) / 2;
          if (round)
            n = Math.round(n);
          return _identity.bind(null, n);
        }
      }
      if (flip) {
        if (round) {
          return _scale_and_flip_and_round_number.bind(null, old_min, old_range, new_max, new_range);
        } else {
          return _scale_and_flip_number.bind(null, old_min, old_range, new_max, new_range);
        }
      } else {
        if (round) {
          return _scale_and_round_number.bind(null, old_min, old_range, new_min, new_range);
        } else {
          return _scale_number.bind(null, old_min, old_range, new_min, new_range);
        }
      }
    }
    function _scale(pixel, ...rest) {
      return create(rest)(pixel);
    }
    var quickScale = {
      _identity,
      _scale,
      _scale_number,
      _scale_and_flip_number,
      _scale_and_round_number,
      _scale_and_flip_and_round_number,
      createScaleFunction: createScaleFunction3
    };
    if (typeof define === "object")
      define(function() {
        return quickScale;
      });
    if (typeof module === "object")
      module.exports = quickScale;
    if (typeof window === "object")
      window.quickScale = quickScale;
    if (typeof self === "object")
      self.quickScale = quickScale;
  }
});

// node_modules/utm-utils/src/isUTM.js
var require_isUTM = __commonJS({
  "node_modules/utm-utils/src/isUTM.js"(exports4, module) {
    module.exports = function isUTM2(projection) {
      const projstr = projection.toString();
      return projstr.startsWith("326") || projstr.startsWith("327");
    };
  }
});

// node_modules/utm-utils/src/getZone.js
var require_getZone = __commonJS({
  "node_modules/utm-utils/src/getZone.js"(exports4, module) {
    module.exports = function getZone(projection) {
      return Number.parseInt(projection.toString().substring(3));
    };
  }
});

// node_modules/utm-utils/src/getHemisphere.js
var require_getHemisphere = __commonJS({
  "node_modules/utm-utils/src/getHemisphere.js"(exports4, module) {
    module.exports = function getHemisphere(projection) {
      const projstr = projection.toString();
      if (projstr.startsWith("326")) {
        return "N";
      } else if (projstr.startsWith("327")) {
        return "S";
      }
    };
  }
});

// node_modules/utm-utils/src/getProjString.js
var require_getProjString = __commonJS({
  "node_modules/utm-utils/src/getProjString.js"(exports4, module) {
    var getZone = require_getZone();
    var getHemisphere = require_getHemisphere();
    module.exports = function getProjString2(projection) {
      const zone = getZone(projection);
      const hemisphere = getHemisphere(projection);
      return `+proj=utm +zone=${zone}${hemisphere === "S" ? " +south " : " "}+ellps=WGS84 +datum=WGS84 +units=m +no_defs`;
    };
  }
});

// node_modules/proj4-fully-loaded/proj4-fully-loaded.js
var require_proj4_fully_loaded2 = __commonJS({
  "node_modules/proj4-fully-loaded/proj4-fully-loaded.js"(exports4, module) {
    var proj43 = (init_lib(), __toCommonJS(lib_exports));
    var defs2 = require_proj4js_definitions();
    if (typeof proj43 === "object" && typeof proj43.defs !== "function" && typeof proj43.default === "function") {
      proj43 = proj43.default;
    }
    proj43.defs(defs2);
    if (typeof define === "function" && define.amd) {
      define(function() {
        return proj43;
      });
    }
    if (typeof module === "object") {
      module.exports = proj43;
      module.exports.default = proj43;
    }
  }
});

// node_modules/preciso/compare_positive.js
var require_compare_positive2 = __commonJS({
  "node_modules/preciso/compare_positive.js"(exports4, module) {
    "use strict";
    function compare_positive(a, b) {
      const alen = a.length;
      const blen = b.length;
      const aidx = a.indexOf(".");
      const bidx = b.indexOf(".");
      const a_adjusted_dot_index = aidx === -1 ? alen : aidx;
      const b_adjusted_dot_index = bidx === -1 ? blen : bidx;
      const offset = a_adjusted_dot_index - b_adjusted_dot_index;
      let left = Math.max(a_adjusted_dot_index, b_adjusted_dot_index);
      let right = Math.max(alen - a_adjusted_dot_index, blen - b_adjusted_dot_index);
      let aoffset = offset < 0 ? -1 * offset : 0;
      let boffset = offset <= 0 ? 0 : offset;
      let imax = left + 1 + right - 1;
      let i = 0;
      while (i < imax) {
        const ai = i - aoffset;
        const achar = ai === a_adjusted_dot_index ? "." : a[ai] || "0";
        const bi = i - boffset;
        const bchar = bi === b_adjusted_dot_index ? "." : b[bi] || "0";
        if (achar !== bchar) {
          if (achar > bchar)
            return ">";
          else if (achar < bchar)
            return "<";
        }
        i++;
      }
      return "=";
    }
    module.exports = compare_positive;
    module.exports.default = compare_positive;
  }
});

// node_modules/preciso/expand.js
var require_expand2 = __commonJS({
  "node_modules/preciso/expand.js"(exports4, module) {
    "use strict";
    function expand(n) {
      if (n[0] === "+")
        n = n.substring(1);
      const sign = n[0] === "-" ? "-" : "";
      if (sign === "-")
        n = n.substring(1);
      const index_of_e = n.indexOf("e");
      if (index_of_e === -1)
        return sign + n;
      let index_of_dot = n.indexOf(".");
      if (index_of_dot === -1)
        index_of_dot = index_of_e;
      const shift = Number(n.substring(index_of_e + 1));
      const base = n.substring(0, index_of_e).replace(".", "");
      const normshift = index_of_dot + shift;
      const baselen = base.length;
      if (normshift >= baselen) {
        const zct = normshift - baselen;
        let result2 = base;
        for (let i = 0; i < zct; i++)
          result2 += "0";
        return sign + result2;
      } else if (normshift < 0) {
        let result2 = "0.";
        for (let i = 0; i > normshift; i--)
          result2 += "0";
        result2 += base;
        return sign + result2;
      } else {
        return sign + base.substring(0, normshift) + "." + base.substring(normshift);
      }
    }
    module.exports = expand;
    module.exports.default = expand;
  }
});

// node_modules/preciso/clean.js
var require_clean2 = __commonJS({
  "node_modules/preciso/clean.js"(exports4, module) {
    "use strict";
    var expand = require_expand2();
    module.exports = function clean(n) {
      if (n[0] === "+")
        n = n.substring(1);
      n = expand(n);
      n = n.replace(/^0+(?=\d)/, "");
      if (n.includes("."))
        n = n.replace(/\.?0+$/, "");
      if (n === "")
        n = "0";
      if (n === "-0")
        n = "0";
      return n;
    };
  }
});

// node_modules/preciso/constants.js
var require_constants = __commonJS({
  "node_modules/preciso/constants.js"(exports4, module) {
    "use strict";
    var MAX_SAFE_INTEGER = 9007199254740991;
    var MAX_SAFE_INTEGER_LENGTH = MAX_SAFE_INTEGER.toString().length - 1;
    module.exports = {
      MAX_SAFE_INTEGER,
      MAX_SAFE_INTEGER_LENGTH
    };
  }
});

// node_modules/preciso/long_addition.js
var require_long_addition2 = __commonJS({
  "node_modules/preciso/long_addition.js"(exports4, module) {
    "use strict";
    var { MAX_SAFE_INTEGER_LENGTH } = require_constants();
    function long_addition(a, b) {
      const alen = a.length;
      const blen = b.length;
      const aidx = a.indexOf(".");
      const bidx = b.indexOf(".");
      const a_adjusted_dot_index = aidx === -1 ? alen : aidx;
      const b_adjusted_dot_index = bidx === -1 ? blen : bidx;
      if (aidx === -1 && bidx === -1 && alen < MAX_SAFE_INTEGER_LENGTH && blen < MAX_SAFE_INTEGER_LENGTH) {
        return (Number(a) + Number(b)).toFixed();
      }
      const offset = a_adjusted_dot_index - b_adjusted_dot_index;
      let left = Math.max(a_adjusted_dot_index, b_adjusted_dot_index);
      let right = Math.max(alen - a_adjusted_dot_index - 1, blen - b_adjusted_dot_index - 1);
      let aoffset = offset < 0 ? -1 * offset : 0;
      let boffset = offset <= 0 ? 0 : offset;
      let imax = left + 1 + right - 1;
      let result2 = "";
      let carried = 0;
      let i = imax;
      if (right > 0) {
        while (i > imax - right) {
          const achar = a[i - aoffset] || "0";
          const bchar = b[i - boffset] || "0";
          let n = Number(achar) + Number(bchar) + carried;
          if (n >= 10) {
            n -= 10;
            carried = 1;
          } else {
            carried = 0;
          }
          if (result2 !== "" || n !== 0) {
            result2 = n + result2;
          }
          i--;
        }
        if (result2)
          result2 = "." + result2;
        i--;
      }
      if (left > 0) {
        while (i >= 0) {
          const achar = a[i - aoffset] || "0";
          const bchar = b[i - boffset] || "0";
          let n = Number(achar) + Number(bchar) + carried;
          if (n >= 10) {
            n -= 10;
            carried = 1;
          } else {
            carried = 0;
          }
          result2 = n + result2;
          i--;
        }
      }
      if (carried === 1) {
        result2 = carried + result2;
      }
      if (result2[0] === ".")
        result2 = "0" + result2;
      return result2;
    }
    module.exports = long_addition;
    module.exports.default = long_addition;
  }
});

// node_modules/preciso/long_subtraction.js
var require_long_subtraction2 = __commonJS({
  "node_modules/preciso/long_subtraction.js"(exports4, module) {
    "use strict";
    var { MAX_SAFE_INTEGER_LENGTH } = require_constants();
    function long_subtraction(a, b) {
      const alen = a.length;
      const blen = b.length;
      const aidx = a.indexOf(".");
      const bidx = b.indexOf(".");
      const a_adjusted_dot_index = aidx === -1 ? alen : aidx;
      const b_adjusted_dot_index = bidx === -1 ? blen : bidx;
      if (aidx === -1 && bidx === -1 && alen < MAX_SAFE_INTEGER_LENGTH && blen < MAX_SAFE_INTEGER_LENGTH) {
        return (Number(a) - Number(b)).toFixed();
      }
      const offset = a_adjusted_dot_index - b_adjusted_dot_index;
      let left = Math.max(a_adjusted_dot_index, b_adjusted_dot_index);
      let right = Math.max(alen - a_adjusted_dot_index - 1, blen - b_adjusted_dot_index - 1);
      let aoffset = offset < 0 ? -1 * offset : 0;
      let boffset = offset <= 0 ? 0 : offset;
      let imax = left + 1 + right - 1;
      let result2 = "";
      let borrowed = 0;
      let i = imax;
      if (right > 0) {
        while (i > imax - right) {
          let top = a[i - aoffset] || "0";
          let bottom = b[i - boffset] || "0";
          top -= borrowed;
          borrowed = 0;
          let n = top - bottom;
          if (n < 0) {
            while (n < 0) {
              borrowed++;
              n += 10;
            }
          } else if (borrowed) {
            borrowed--;
          }
          if (result2 !== "" || n !== 0) {
            result2 = n + result2;
          }
          i--;
        }
        if (result2 !== "") {
          result2 = "." + result2;
        }
        i--;
      }
      if (left > 0) {
        while (i > 0) {
          let top = a[i - aoffset] || "0";
          let bottom = b[i - boffset] || "0";
          top -= borrowed;
          borrowed = 0;
          let n2 = top - bottom;
          if (n2 < 0) {
            while (n2 < 0) {
              borrowed++;
              n2 += 10;
            }
          } else if (borrowed) {
            borrowed--;
          }
          result2 = n2 + result2;
          i--;
        }
        const achar = a[0 - aoffset] || "0";
        const bchar = b[0 - boffset] || "0";
        let n = Number(achar) - (borrowed > 0 ? 1 : 0) - Number(bchar);
        if (n !== 0) {
          result2 = n + result2;
        }
        result2 = result2.replace(/^0+/, "");
      }
      if (result2[0] === ".")
        result2 = "0" + result2;
      return result2;
    }
    module.exports = long_subtraction;
    module.exports.default = long_subtraction;
  }
});

// node_modules/preciso/add.js
var require_add2 = __commonJS({
  "node_modules/preciso/add.js"(exports4, module) {
    "use strict";
    var compare_positive = require_compare_positive2();
    var clean = require_clean2();
    var long_addition = require_long_addition2();
    var long_subtraction = require_long_subtraction2();
    function add3(a, b) {
      a = clean(a);
      b = clean(b);
      const apos = a[0] !== "-";
      const bpos = b[0] !== "-";
      if (apos && bpos) {
        return long_addition(a, b);
      } else if (!apos && !bpos) {
        return "-" + long_addition(a.substring(1), b.substring(1));
      } else if (!apos && bpos) {
        a = a.substring(1);
        switch (compare_positive(a, b)) {
          case "=":
            return "0";
          case "<":
            return long_subtraction(b, a);
          case ">":
            return "-" + long_subtraction(a, b);
        }
      } else if (apos && !bpos) {
        b = b.substring(1);
        switch (compare_positive(a, b)) {
          case "=":
            return "0";
          case "<":
            return "-" + long_subtraction(b, a);
          case ">":
            return long_subtraction(a, b);
        }
      }
    }
    module.exports = add3;
    module.exports.default = add3;
  }
});

// node_modules/preciso/absolute.js
var require_absolute2 = __commonJS({
  "node_modules/preciso/absolute.js"(exports4, module) {
    "use strict";
    var clean = require_clean2();
    function absolute(n) {
      n = clean(n);
      if (n[0] === "-")
        return n.substring(1);
      else
        return n;
    }
    module.exports = absolute;
    module.exports.default = absolute;
  }
});

// node_modules/preciso/subtract.js
var require_subtract2 = __commonJS({
  "node_modules/preciso/subtract.js"(exports4, module) {
    "use strict";
    var clean = require_clean2();
    var compare_positive = require_compare_positive2();
    var long_addition = require_long_addition2();
    var long_subtraction = require_long_subtraction2();
    function subtract2(a, b) {
      a = clean(a);
      b = clean(b);
      const a_is_positive = a[0] !== "-";
      const b_is_positive = b[0] !== "-";
      if (a_is_positive) {
        if (b_is_positive) {
          const comparison = compare_positive(a, b);
          if (comparison === ">") {
            return long_subtraction(a, b);
          } else if (comparison === "<") {
            return "-" + long_subtraction(b, a);
          } else {
            return "0";
          }
        } else {
          return long_addition(a, b.substring(1));
        }
      } else if (b_is_positive) {
        return "-" + long_addition(a.substring(1), b);
      } else {
        a = a.substring(1);
        b = b.substring(1);
        const comparison = compare_positive(a, b);
        if (comparison === ">") {
          return "-" + long_subtraction(a, b);
        } else if (comparison === "<") {
          return long_subtraction(b, a);
        } else {
          return "0";
        }
      }
    }
    module.exports = subtract2;
    module.exports.default = subtract2;
  }
});

// node_modules/preciso/truncate_decimal.js
var require_truncate_decimal = __commonJS({
  "node_modules/preciso/truncate_decimal.js"(exports4, module) {
    "use strict";
    function truncate_decimal(n) {
      return n.substring(0, n.indexOf("."));
    }
    module.exports = truncate_decimal;
    module.exports.default = truncate_decimal;
  }
});

// node_modules/preciso/round_last_decimal.js
var require_round_last_decimal2 = __commonJS({
  "node_modules/preciso/round_last_decimal.js"(exports4, module) {
    "use strict";
    var add3 = require_add2();
    var truncate_decimal = require_truncate_decimal();
    var up = ["5", "6", "7", "8", "9"];
    function round_last_decimal(n) {
      if (n.match(/\.9+$/)) {
        return add3(truncate_decimal(n), "1");
      }
      if (n[0] === "+")
        n = n.substring(1);
      const len = n.length;
      let result2 = "";
      const last_char = n[n.length - 1];
      if (up.includes(last_char)) {
        let i;
        for (i = len - 2; i >= 0; i--) {
          const char = n[i];
          if (char === "." || char === "-")
            continue;
          const nchar = Number(char) + 1;
          if (nchar === 10) {
            result2 = "0" + result2;
          } else {
            result2 = nchar + result2;
            break;
          }
        }
        if (i > 0)
          result2 = n.substring(0, i) + result2;
      } else {
        result2 = n.substring(0, len - 1);
      }
      if (result2[result2.length - 1] === ".")
        result2 = result2.substring(0, result2.length - 1);
      if (result2.indexOf(".") > -1)
        result2 = result2.replace(/0+$/, "");
      return result2;
    }
    module.exports = round_last_decimal;
    module.exports.default = round_last_decimal;
  }
});

// node_modules/preciso/long_division.js
var require_long_division2 = __commonJS({
  "node_modules/preciso/long_division.js"(exports4, module) {
    "use strict";
    var compare_positive = require_compare_positive2();
    var add3 = require_add2();
    var subtract2 = require_subtract2();
    var round_last_decimal = require_round_last_decimal2();
    function long_division(dividend, divisor, { max_decimal_digits = 100, ellipsis = false } = {}) {
      if (dividend[0] === "0")
        dividend = dividend.substring(1);
      if (divisor[0] === "0")
        divisor = divisor.substring(1);
      const dividend_index_of_dot = dividend.indexOf(".");
      const divisor_index_of_dot = divisor.indexOf(".");
      const adjusted_dividend_index_of_dot = dividend_index_of_dot === -1 ? dividend.length : dividend_index_of_dot;
      const divisor_num_decimal_places = divisor_index_of_dot === -1 ? 0 : divisor.length - 1 - divisor_index_of_dot;
      let repeating = false;
      dividend = dividend.replace(/\./, "");
      divisor = divisor.replace(/\./, "");
      const dividend_length = dividend.length;
      let current = "";
      let quotient = "";
      let comparison;
      let offset = -1 * divisor_num_decimal_places;
      let skip = 0;
      for (let i = 0; i < dividend_length; i++) {
        const char = dividend[i];
        current += char;
        comparison = compare_positive(current, divisor);
        if (comparison === ">") {
          let times = 1;
          let product = add3(divisor, divisor);
          let passed_product = divisor;
          while (compare_positive(product, current) !== ">") {
            times++;
            passed_product = product;
            product = add3(product, divisor);
          }
          times = times.toString();
          if (quotient !== "") {
            for (let i2 = times.length; i2 <= skip; i2++)
              quotient += "0";
          }
          quotient += times;
          current = subtract2(current, passed_product);
          skip = 0;
        } else if (comparison === "<") {
          if (quotient === "") {
            offset++;
          }
          skip++;
          continue;
        } else if (comparison === "=") {
          if (quotient !== "") {
            for (let i2 = 0; i2 < skip; i2++)
              quotient += "0";
          }
          quotient += "1";
          current = "0";
          skip = 0;
        }
      }
      if (current.match(/^0+$/g)) {
        if (comparison === "<") {
          quotient += current.substring(0, current.length - 1);
        }
      } else {
        const previous = {};
        const idot2 = adjusted_dividend_index_of_dot - offset;
        const qlen2 = quotient.length;
        const imax = idot2 - qlen2 + max_decimal_digits + 1;
        if (quotient === "") {
          skip = 0;
        }
        for (let i = 0; i < imax; i++) {
          current += "0";
          if (ellipsis) {
            if (current in previous) {
              previous[current]++;
              if (previous[current] > 3) {
                quotient += "...";
                repeating = true;
                break;
              }
            } else {
              previous[current] = 1;
            }
          }
          const comparison2 = compare_positive(current, divisor);
          if (comparison2 === ">") {
            let times = 1;
            let product = add3(divisor, divisor);
            let passed_product = divisor;
            while (compare_positive(product, current) !== ">") {
              times++;
              passed_product = product;
              product = add3(product, divisor);
            }
            times = times.toString();
            for (let i2 = times.length; i2 <= skip; i2++)
              quotient += "0";
            quotient += times;
            current = subtract2(current, passed_product);
            if (current === "0") {
              break;
            }
            skip = 0;
          } else if (comparison2 === "<") {
            skip++;
            continue;
          } else if (comparison2 === "=") {
            for (let i2 = 0; i2 < skip; i2++)
              quotient += "0";
            quotient += "1";
            skip = 0;
            break;
          }
        }
      }
      const idot = adjusted_dividend_index_of_dot - offset;
      const qlen = quotient.length;
      let num_decimals;
      if (idot === qlen) {
        num_decimals = 0;
      } else if (idot < 0) {
        quotient = "0." + "0".repeat(Math.abs(idot)) + quotient;
        num_decimals = qlen - idot;
      } else if (idot > qlen) {
        for (let i = qlen; i < idot; i++)
          quotient += "0";
        num_decimals = 0;
      } else if (idot < qlen) {
        quotient = quotient.substring(0, idot) + "." + quotient.substring(idot);
        num_decimals = qlen - idot;
      } else if (idot === 0) {
        quotient = "0." + quotient;
        num_decimals = qlen;
      }
      quotient = quotient.replace(/^0+/, "");
      quotient = quotient.replace(/\.\d+0+$/, "");
      if (!repeating) {
        const extra_decimals = num_decimals - max_decimal_digits;
        if (extra_decimals > 0) {
          quotient = round_last_decimal(quotient.substring(0, quotient.length - extra_decimals + 1));
        }
      }
      if (quotient[0] === ".")
        quotient = "0" + quotient;
      return quotient;
    }
    module.exports = long_division;
    module.exports.default = long_division;
  }
});

// node_modules/preciso/divide.js
var require_divide2 = __commonJS({
  "node_modules/preciso/divide.js"(exports4, module) {
    "use strict";
    var absolute = require_absolute2();
    var clean = require_clean2();
    var long_division = require_long_division2();
    function divide2(dividend, divisor, options) {
      dividend = clean(dividend);
      divisor = clean(divisor);
      if (divisor === "0")
        throw new Error("[preciso] division by zero");
      if (dividend === "" || dividend === "0")
        return "0";
      const dividend_is_positive = dividend[0] !== "-";
      const divisor_is_positive = divisor[0] !== "-";
      const out_sign = dividend_is_positive !== divisor_is_positive ? "-" : "";
      if (!dividend_is_positive)
        dividend = absolute(dividend);
      if (!divisor_is_positive)
        divisor = absolute(divisor);
      return out_sign + long_division(dividend, divisor, options);
    }
    module.exports = divide2;
    module.exports.default = divide2;
  }
});

// node_modules/preciso/long_multiplication.js
var require_long_multiplication2 = __commonJS({
  "node_modules/preciso/long_multiplication.js"(exports4, module) {
    "use strict";
    var { MAX_SAFE_INTEGER_LENGTH } = require_constants();
    var CHUNK_SIZE = 15;
    function long_multiplication(a, b) {
      if (a === "0" || b === "0")
        return "0";
      const top_index_of_dot = a.indexOf(".");
      const bottom_index_of_dot = b.indexOf(".");
      const a_num_integer_places = top_index_of_dot === -1 ? a.length : top_index_of_dot;
      const b_num_integer_places = bottom_index_of_dot === -1 ? b.length : bottom_index_of_dot;
      const max_total_num_integer_places = a_num_integer_places + b_num_integer_places;
      const a_num_decimal_places = top_index_of_dot === -1 ? 0 : a.length - 1 - top_index_of_dot;
      const b_num_decimal_places = bottom_index_of_dot === -1 ? 0 : b.length - 1 - bottom_index_of_dot;
      const out_num_decimal_places = a_num_decimal_places + b_num_decimal_places;
      if (out_num_decimal_places === 0 && max_total_num_integer_places < MAX_SAFE_INTEGER_LENGTH) {
        return (Number(a) * Number(b)).toFixed(0);
      }
      const aint = a.replace(".", "");
      const bint = b.replace(".", "");
      const alen = aint.length;
      const blen = bint.length;
      const chunks = [];
      let i = alen;
      while (i >= 0) {
        const end = i;
        const start2 = i -= CHUNK_SIZE;
        const str = aint.substring(start2, end);
        chunks.push([Number(str), str.length]);
      }
      const partial_products = [];
      const partials = [];
      for (let i2 = 0, ireverse = blen - 1; ireverse >= 0; ireverse--, i2++) {
        const bstr = bint[ireverse];
        const bnum = Number(bstr);
        let carried2 = 0;
        let partial = "";
        const ichunklast = chunks.length - 1;
        chunks.forEach(([chunk, chunklen], c) => {
          const subpartial = carried2 + bnum * chunk;
          let subpartstr = subpartial.toString();
          const subpartcharlen = subpartstr.length;
          if (subpartcharlen > chunklen && c !== ichunklast) {
            const islice = -1 * chunklen;
            partial = subpartstr.slice(islice) + partial;
            carried2 = Number(subpartstr.slice(0, islice));
          } else {
            const imax = chunklen - subpartcharlen;
            for (let i3 = 0; i3 < imax; i3++) {
              subpartstr = "0" + subpartstr;
            }
            carried2 = 0;
            partial = subpartstr + partial;
          }
        });
        partial += "0".repeat(i2);
        partial_products.push(partial);
        partials.push([Array.from(partial).map((char) => Number(char)), partial.length]);
      }
      const num_partials = partial_products.length;
      const number_of_columns = partials[partials.length - 1][1] + num_partials;
      let result2 = "";
      let carried = 0;
      for (let icol = 0; icol < number_of_columns; icol++) {
        let sum = carried;
        const pmax = Math.min(icol, num_partials - 1);
        for (let p = 0; p <= pmax; p++) {
          const [pnums, plen] = partials[p];
          const i2 = plen - 1 - icol;
          if (i2 >= 0) {
            sum += pnums[i2];
          }
        }
        if (sum >= 10) {
          sum = sum.toString();
          result2 = sum[sum.length - 1] + result2;
          carried = Number(sum.slice(0, -1));
        } else {
          result2 = sum + result2;
          carried = 0;
        }
      }
      if (out_num_decimal_places === 0) {
        result2 = result2.replace(/^0+/, "");
      } else {
        const idot = result2.length - out_num_decimal_places;
        result2 = result2.substring(0, idot) + "." + result2.substring(idot);
        result2 = result2.replace(/^0+/, "");
        result2 = result2.replace(/\.?0+$/, "");
        if (result2[0] === ".")
          result2 = "0" + result2;
      }
      return result2;
    }
    module.exports = long_multiplication;
    module.exports.default = long_multiplication;
  }
});

// node_modules/preciso/multiply.js
var require_multiply2 = __commonJS({
  "node_modules/preciso/multiply.js"(exports4, module) {
    "use strict";
    var absolute = require_absolute2();
    var clean = require_clean2();
    var compare_positive = require_compare_positive2();
    var long_multiplication = require_long_multiplication2();
    function multiply2(a, b) {
      a = clean(a);
      b = clean(b);
      const apos = a[0] !== "-";
      const bpos = b[0] !== "-";
      const out_sign = apos !== bpos ? "-" : "";
      a = absolute(a);
      b = absolute(b);
      const comparison = compare_positive(a, b);
      if (comparison === "<") {
        const aold = a;
        const bold = b;
        a = bold;
        b = aold;
      }
      return out_sign + long_multiplication(a, b);
    }
    module.exports = multiply2;
    module.exports.default = multiply2;
  }
});

// node_modules/get-epsg-code/dist/get-epsg-code-all.node.min.js
var require_get_epsg_code_all_node_min = __commonJS({
  "node_modules/get-epsg-code/dist/get-epsg-code-all.node.min.js"(exports4, module) {
    !function(t, e) {
      "object" == typeof exports4 && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define([], e) : "object" == typeof exports4 ? exports4["get-epsg-code"] = e() : t["get-epsg-code"] = e();
    }("undefined" != typeof self ? self : exports4, function() {
      return function(t) {
        var e = {};
        function o(r) {
          if (e[r])
            return e[r].exports;
          var n = e[r] = { i: r, l: false, exports: {} };
          return t[r].call(n.exports, n, n.exports, o), n.l = true, n.exports;
        }
        return o.m = t, o.c = e, o.d = function(t2, e2, r) {
          o.o(t2, e2) || Object.defineProperty(t2, e2, { enumerable: true, get: r });
        }, o.r = function(t2) {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
        }, o.t = function(t2, e2) {
          if (1 & e2 && (t2 = o(t2)), 8 & e2)
            return t2;
          if (4 & e2 && "object" == typeof t2 && t2 && t2.__esModule)
            return t2;
          var r = /* @__PURE__ */ Object.create(null);
          if (o.r(r), Object.defineProperty(r, "default", { enumerable: true, value: t2 }), 2 & e2 && "string" != typeof t2)
            for (var n in t2)
              o.d(r, n, function(e3) {
                return t2[e3];
              }.bind(null, n));
          return r;
        }, o.n = function(t2) {
          var e2 = t2 && t2.__esModule ? function() {
            return t2.default;
          } : function() {
            return t2;
          };
          return o.d(e2, "a", e2), e2;
        }, o.o = function(t2, e2) {
          return Object.prototype.hasOwnProperty.call(t2, e2);
        }, o.p = "", o(o.s = 1);
      }([function(t, e, o) {
        const r = o(5);
        t.exports = function(t2, e2, o2) {
          const n = o2 && o2.debug || false, a = o2 && o2.startIndex || 0;
          n && console.log("starting findTag with", e2, " and ", o2);
          const i = r(t2, `<${e2}[ >]`, a);
          if (n && console.log("start:", i), -1 === i)
            return;
          const s = i + e2.length + r(t2.slice(i + e2.length), "[ /]" + e2 + ">", 0) + 1 + e2.length + 1;
          if (n && console.log("end:", s), -1 === s)
            return;
          const C = t2.slice(i, s);
          return { inner: C.slice(C.indexOf(">") + 1, C.lastIndexOf("<")), outer: C, start: i, end: s };
        };
      }, function(t, e, o) {
        var r = o(2), n = o(0), a = o(6), i = o(12).default, s = o(7), C = o(8), E = (C.ARRAY_TYPE, C.EXCLUDED_FORMATS), d = C.BYTES_PER_VALUE, f = C.DATA_VIEW_READER_NAME, D = C.FORMATS, c = C.HASHED_FIELDS, g = C.NUM_FIELDS, l = (C.NUM_HASHED_FIELDS, C.UNSUPPORTED_MSG), p = D.ESRI_WKT, A2 = D.GEOSERVER, u = D.MAPFILE, Q = D.MAPNIK, h = D.OGC_GML, R = D.OGC_XML, G = D.OGC_WKT, I2 = D.POSTGIS, x = D.PROJ_4, w = D.PROJ_4_JS, M = o(9), m = new DataView(M), B = o(11).hash, F = ["PROJECTEDCRS", "PROJCRS", "GEOGCS", "GEOCCS", "PROJCS", "LOCAL_CS", "GEODCRS", "GEODETICCRS", "GEODETICDATUM", "ENGCRS", "ENGINEERINGCRS"];
        function O2(t2) {
          return function(t3) {
            return !(!(t3 = t3.trim()).startsWith("PROJCS[") && !t3.startsWith("GEOGCS[")) && F.some(function(e2) {
              return t3.includes(e2);
            });
          }(t2) ? t2.includes("AUTHORITY") ? G : p : t2.includes("gml:ProjectedCRS") || t2.includes("gml:GeodeticCRS") || t2.includes("gml:GeographicCRS") ? t2.includes("gml:srsID") ? R : h : t2.startsWith("+proj=") ? x : t2.startsWith('proj4.defs("EPSG:') ? w : /^\d{1,6}\=(PROJCS|GEOGCS)/.test(t2) ? A2 : t2.startsWith("PROJECTION") && t2.endsWith("END") ? u : t2.endsWith("</Map>") ? Q : t2.startsWith("INSERT") ? I2 : "SOMETHING ELSE";
        }
        function k(t2, e2, o2) {
          o2 && console.log("looking up " + e2);
          var r2 = B(t2);
          o2 && console.log("hashed:", r2);
          var n2 = c.indexOf(e2) + 1;
          o2 && console.log("offset:", n2);
          for (var a2 = n2 * d; a2 < M.byteLength; a2 += g * d) {
            if (r2 === m[f](a2, true))
              return m[f](a2 - n2 * d, true);
          }
        }
        function T(t2, e2) {
          var o2 = !(!e2 || !e2.debug) && e2.debug, C2 = O2(t2);
          if (o2 && console.log("dataType:", C2), o2 && console.log("EXCLUDED_FORMATS:", E), E.includes(C2.toLowerCase()))
            throw new Error(l.replace("{}", C2));
          if (C2 === G) {
            var d2 = i(t2);
            if (o2 && console.log("parsed:", d2), d2.AUTHORITY) {
              var f2 = d2.AUTHORITY;
              return Number(f2.epsg || f2.EPSG);
            }
          } else {
            if (C2 == p) {
              var D2 = i(t2);
              if (o2 && console.log("parsed:", D2), D2.name.match(/^WGS_1984_UTM_Zone_\d{1,2}(N|S)$/)) {
                var c2 = D2.name.split("_").pop(), g2 = c2.substring(0, c2.length - 1), M2 = "N" == c2.substr(-1) ? 6 : 7;
                return Number.parseInt("32" + M2 + g2);
              }
              return k(t2 = s(t2), p, false);
            }
            if (C2 === h) {
              var m2 = n(t2, "gml:identifier", { debug: o2 }).inner;
              return Number(m2.replace("urn:ogc:def:crs:EPSG::", ""));
            }
            if (C2 === R)
              return Number(r(t2, ["gml:srsID", "gml:name"], { debug: o2 }).inner);
            if (C2 === x) {
              if (t2.startsWith("+proj=utm")) {
                var B2 = t2.split(" ").find(function(t3) {
                  return t3.startsWith("+zone=");
                }).split("=")[1], F2 = t2.includes("+south") ? "7" : "6";
                return Number.parseInt("32" + F2 + B2);
              }
              return k(t2, x);
            }
            if (C2 === w)
              return Number(t2.substring(17, t2.indexOf('"', 17)));
            if (C2 === A2)
              return Number(t2.match(/^\d{1,6}/)[0]);
            if (C2 === u) {
              if (t2.includes("init=epsg:"))
                return Number.parseInt(/("init\=epsg:)(\d{1,10})(")/.exec(t2)[2]);
              if (t2.includes('"proj=utm"')) {
                var Z2 = /("zone\=)(\d{1,2})(")/.exec(t2)[2], H = t2.includes('"south"') ? "7" : "6";
                return Number.parseInt("32" + H + Z2);
              }
              return k(t2, u);
            }
            if (C2 === Q) {
              var U = n(t2, "Map");
              return T(a(U.outer, "srs"));
            }
            if (C2 === I2)
              return Number(t2.substring(t2.indexOf("values (") + 8, t2.indexOf("EPSG") - 3).trim());
          }
        }
        void 0 !== t.exports && (t.exports = T), "undefined" != typeof window ? window.getEPSGCode = T : "undefined" != typeof self && (self.getEPSGCode = T);
      }, function(t, e, o) {
        const r = o(3);
        t.exports = function(t2, e2, o2) {
          const n = o2 && o2.debug || false, a = r(t2, e2, { debug: n, returnOnFirst: true });
          return Array.isArray(a) && 1 === a.length ? a[0] : void 0;
        };
      }, function(t, e, o) {
        const r = o(4);
        t.exports = function(t2, e2, o2) {
          const n = o2 && o2.debug || false, a = o2 && o2.returnOnFirst || false;
          let i = r(t2, e2.shift(), { debug: n });
          n && console.log("first tags are:", i);
          for (let t3 = 0; t3 < e2.length; t3++) {
            const o3 = e2[t3];
            let s = [];
            for (let C = 0; C < i.length; C++) {
              const E = i[C], d = r(E.outer, o3, { debug: n, startIndex: 1 });
              if (d.length > 0) {
                if (d.forEach((t4) => {
                  t4.start += E.start, t4.end += E.start;
                }), a && t3 === e2.length - 1)
                  return [d[0]];
                s = s.concat(d);
              }
            }
            i = s;
          }
          return i;
        };
      }, function(t, e, o) {
        const r = o(0);
        t.exports = function(t2, e2, o2) {
          const n = [], a = o2 && o2.debug || false;
          let i, s = o2 && o2.startIndex || 0;
          for (; i = r(t2, e2, { debug: a, startIndex: s }); )
            s = i.end, n.push(i);
          return n;
        };
      }, function(t, e) {
        t.exports = function(t2, e2, o) {
          const r = new RegExp(e2).exec(t2.slice(o));
          return r ? o + r.index : -1;
        };
      }, function(t, e) {
        t.exports = function(t2, e2, o) {
          const r = o && o.debug || false;
          r && console.log("getting " + e2 + " in " + t2);
          const n = "object" == typeof t2 ? t2.outer : t2, a = `${e2}\\="(.*)"`;
          r && console.log("pattern:", a);
          const i = new RegExp(a).exec(n);
          if (i)
            return i[1];
        };
      }, function(t, e) {
        t.exports = function(t2) {
          return t2 = (t2 = t2.replace('DATUM["D_', 'DATUM["')).replace(/\.\d{16,}/g, function(t3) {
            return t3.substr(0, 16);
          });
        };
      }, function(t, e) {
        var o = ["esriwkt", "mapfile", "proj4"], r = o;
        "undefined" != typeof process && process.env;
        var n = [];
        "undefined" != typeof process && process.env, r.includes("esriwkt") || n.push("esriwkt"), r.includes("mapfile") || n.push("mapfile"), r.includes("proj4") || (n.push("mapnik"), n.push("proj4")), n.sort();
        var a = r.length, i = a + 1, s = Int16Array;
        t.exports = { ARRAY_TYPE: s, DATA_VIEW_READER_NAME: "getInt16", BYTES_PER_VALUE: 2, DEFAULT_HASHED_FIELDS: o, EXCLUDED_FORMATS: n, FORMATS: { ESRI_WKT: "esriwkt", GEOSERVER: "geoserver", MAPFILE: "mapfile", MAPNIK: "mapnik", OGC_GML: "gml", OGC_XML: "xml", OGC_WKT: "wkt", POSTGIS: "postgis", PROJ_4: "proj4", PROJ_4_JS: "js" }, HASHED_FIELDS: r, NUM_HASHED_FIELDS: a, NUM_FIELDS: i, UNSUPPORTED_MSG: "[get-epsg-code] {} format not supported" };
      }, function(t, e, o) {
        t.exports = o(10)("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");
      }, function(t, e, o) {
        "use strict";
        t.exports = function(t2) {
          for (var e2 = "undefined" != typeof window && "function" == typeof window.atob ? window.atob(t2) : Buffer.from(t2, "base64").toString("binary"), o2 = new Uint8Array(e2.length), r = 0; r < e2.length; ++r)
            o2[r] = e2.charCodeAt(r);
          return o2.buffer;
        };
      }, function(t, e) {
        t.exports = { hash: function(t2) {
          var e2, o = 0;
          if (0 === (t2 = (t2 = t2.trim()).replace(/  /g, " ")).length)
            return o;
          for (t2.length, e2 = 0; e2 < t2.length; e2++)
            o = (o << 5) - o + t2.charCodeAt(e2), o |= 0;
          return o = Math.round(o / Math.pow(2, 16));
        } };
      }, function(t, e, o) {
        "use strict";
        o.r(e);
        var r = function(t2) {
          return new E(t2).output();
        }, n = /\s/, a = /[A-Za-z]/, i = /[A-Za-z84]/, s = /[,\]]/, C = /[\d\.E\-\+]/;
        function E(t2) {
          if ("string" != typeof t2)
            throw new Error("not a string");
          this.text = t2.trim(), this.level = 0, this.place = 0, this.root = null, this.stack = [], this.currentObject = null, this.state = 1;
        }
        function d(t2, e2, o2) {
          Array.isArray(e2) && (o2.unshift(e2), e2 = null);
          var r2 = e2 ? {} : t2, n2 = o2.reduce(function(t3, e3) {
            return f(e3, t3), t3;
          }, r2);
          e2 && (t2[e2] = n2);
        }
        function f(t2, e2) {
          if (Array.isArray(t2)) {
            var o2, r2 = t2.shift();
            if ("PARAMETER" === r2 && (r2 = t2.shift()), 1 === t2.length)
              return Array.isArray(t2[0]) ? (e2[r2] = {}, void f(t2[0], e2[r2])) : void (e2[r2] = t2[0]);
            if (t2.length)
              if ("TOWGS84" !== r2)
                switch (Array.isArray(r2) || (e2[r2] = {}), r2) {
                  case "UNIT":
                  case "PRIMEM":
                  case "VERT_DATUM":
                    return e2[r2] = { name: t2[0].toLowerCase(), convert: t2[1] }, void (3 === t2.length && f(t2[2], e2[r2]));
                  case "SPHEROID":
                  case "ELLIPSOID":
                    return e2[r2] = { name: t2[0], a: t2[1], rf: t2[2] }, void (4 === t2.length && f(t2[3], e2[r2]));
                  case "PROJECTEDCRS":
                  case "PROJCRS":
                  case "GEOGCS":
                  case "GEOCCS":
                  case "PROJCS":
                  case "LOCAL_CS":
                  case "GEODCRS":
                  case "GEODETICCRS":
                  case "GEODETICDATUM":
                  case "EDATUM":
                  case "ENGINEERINGDATUM":
                  case "VERT_CS":
                  case "VERTCRS":
                  case "VERTICALCRS":
                  case "COMPD_CS":
                  case "COMPOUNDCRS":
                  case "ENGINEERINGCRS":
                  case "ENGCRS":
                  case "FITTED_CS":
                  case "LOCAL_DATUM":
                  case "DATUM":
                    return t2[0] = ["name", t2[0]], void d(e2, r2, t2);
                  default:
                    for (o2 = -1; ++o2 < t2.length; )
                      if (!Array.isArray(t2[o2]))
                        return f(t2, e2[r2]);
                    return d(e2, r2, t2);
                }
              else
                e2[r2] = t2;
            else
              e2[r2] = true;
          } else
            e2[t2] = true;
        }
        E.prototype.readCharicter = function() {
          var t2 = this.text[this.place++];
          if (4 !== this.state)
            for (; n.test(t2); ) {
              if (this.place >= this.text.length)
                return;
              t2 = this.text[this.place++];
            }
          switch (this.state) {
            case 1:
              return this.neutral(t2);
            case 2:
              return this.keyword(t2);
            case 4:
              return this.quoted(t2);
            case 5:
              return this.afterquote(t2);
            case 3:
              return this.number(t2);
            case -1:
              return;
          }
        }, E.prototype.afterquote = function(t2) {
          if ('"' === t2)
            return this.word += '"', void (this.state = 4);
          if (s.test(t2))
            return this.word = this.word.trim(), void this.afterItem(t2);
          throw new Error(`havn't handled "` + t2 + '" in afterquote yet, index ' + this.place);
        }, E.prototype.afterItem = function(t2) {
          return "," === t2 ? (null !== this.word && this.currentObject.push(this.word), this.word = null, void (this.state = 1)) : "]" === t2 ? (this.level--, null !== this.word && (this.currentObject.push(this.word), this.word = null), this.state = 1, this.currentObject = this.stack.pop(), void (this.currentObject || (this.state = -1))) : void 0;
        }, E.prototype.number = function(t2) {
          if (!C.test(t2)) {
            if (s.test(t2))
              return this.word = parseFloat(this.word), void this.afterItem(t2);
            throw new Error(`havn't handled "` + t2 + '" in number yet, index ' + this.place);
          }
          this.word += t2;
        }, E.prototype.quoted = function(t2) {
          '"' !== t2 ? this.word += t2 : this.state = 5;
        }, E.prototype.keyword = function(t2) {
          if (i.test(t2))
            this.word += t2;
          else {
            if ("[" === t2) {
              var e2 = [];
              return e2.push(this.word), this.level++, null === this.root ? this.root = e2 : this.currentObject.push(e2), this.stack.push(this.currentObject), this.currentObject = e2, void (this.state = 1);
            }
            if (!s.test(t2))
              throw new Error(`havn't handled "` + t2 + '" in keyword yet, index ' + this.place);
            this.afterItem(t2);
          }
        }, E.prototype.neutral = function(t2) {
          if (a.test(t2))
            return this.word = t2, void (this.state = 2);
          if ('"' === t2)
            return this.word = "", void (this.state = 4);
          if (C.test(t2))
            return this.word = t2, void (this.state = 3);
          if (!s.test(t2))
            throw new Error(`havn't handled "` + t2 + '" in neutral yet, index ' + this.place);
          this.afterItem(t2);
        }, E.prototype.output = function() {
          for (; this.place < this.text.length; )
            this.readCharicter();
          if (-1 === this.state)
            return this.root;
          throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
        };
        function D(t2) {
          return 0.017453292519943295 * t2;
        }
        e.default = function(t2) {
          var e2 = r(t2), o2 = e2.shift(), n2 = e2.shift();
          e2.unshift(["name", n2]), e2.unshift(["type", o2]);
          var a2 = {};
          return f(e2, a2), function(t3) {
            "GEOGCS" === t3.type ? t3.projName = "longlat" : "LOCAL_CS" === t3.type ? (t3.projName = "identity", t3.local = true) : "object" == typeof t3.PROJECTION ? t3.projName = Object.keys(t3.PROJECTION)[0] : t3.projName = t3.PROJECTION, t3.UNIT && (t3.units = t3.UNIT.name.toLowerCase(), "metre" === t3.units && (t3.units = "meter"), t3.UNIT.convert && ("GEOGCS" === t3.type ? t3.DATUM && t3.DATUM.SPHEROID && (t3.to_meter = t3.UNIT.convert * t3.DATUM.SPHEROID.a) : t3.to_meter = t3.UNIT.convert));
            var e3 = t3.GEOGCS;
            function o3(e4) {
              return e4 * (t3.to_meter || 1);
            }
            "GEOGCS" === t3.type && (e3 = t3), e3 && (e3.DATUM ? t3.datumCode = e3.DATUM.name.toLowerCase() : t3.datumCode = e3.name.toLowerCase(), "d_" === t3.datumCode.slice(0, 2) && (t3.datumCode = t3.datumCode.slice(2)), "new_zealand_geodetic_datum_1949" !== t3.datumCode && "new_zealand_1949" !== t3.datumCode || (t3.datumCode = "nzgd49"), "wgs_1984" === t3.datumCode && ("Mercator_Auxiliary_Sphere" === t3.PROJECTION && (t3.sphere = true), t3.datumCode = "wgs84"), "_ferro" === t3.datumCode.slice(-6) && (t3.datumCode = t3.datumCode.slice(0, -6)), "_jakarta" === t3.datumCode.slice(-8) && (t3.datumCode = t3.datumCode.slice(0, -8)), ~t3.datumCode.indexOf("belge") && (t3.datumCode = "rnb72"), e3.DATUM && e3.DATUM.SPHEROID && (t3.ellps = e3.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk"), "international" === t3.ellps.toLowerCase().slice(0, 13) && (t3.ellps = "intl"), t3.a = e3.DATUM.SPHEROID.a, t3.rf = parseFloat(e3.DATUM.SPHEROID.rf, 10)), e3.DATUM && e3.DATUM.TOWGS84 && (t3.datum_params = e3.DATUM.TOWGS84), ~t3.datumCode.indexOf("osgb_1936") && (t3.datumCode = "osgb36"), ~t3.datumCode.indexOf("osni_1952") && (t3.datumCode = "osni52"), (~t3.datumCode.indexOf("tm65") || ~t3.datumCode.indexOf("geodetic_datum_of_1965")) && (t3.datumCode = "ire65"), "ch1903+" === t3.datumCode && (t3.datumCode = "ch1903"), ~t3.datumCode.indexOf("israel") && (t3.datumCode = "isr93")), t3.b && !isFinite(t3.b) && (t3.b = t3.a), [["standard_parallel_1", "Standard_Parallel_1"], ["standard_parallel_2", "Standard_Parallel_2"], ["false_easting", "False_Easting"], ["false_northing", "False_Northing"], ["central_meridian", "Central_Meridian"], ["latitude_of_origin", "Latitude_Of_Origin"], ["latitude_of_origin", "Central_Parallel"], ["scale_factor", "Scale_Factor"], ["k0", "scale_factor"], ["latitude_of_center", "Latitude_Of_Center"], ["latitude_of_center", "Latitude_of_center"], ["lat0", "latitude_of_center", D], ["longitude_of_center", "Longitude_Of_Center"], ["longitude_of_center", "Longitude_of_center"], ["longc", "longitude_of_center", D], ["x0", "false_easting", o3], ["y0", "false_northing", o3], ["long0", "central_meridian", D], ["lat0", "latitude_of_origin", D], ["lat0", "standard_parallel_1", D], ["lat1", "standard_parallel_1", D], ["lat2", "standard_parallel_2", D], ["azimuth", "Azimuth"], ["alpha", "azimuth", D], ["srsCode", "name"]].forEach(function(e4) {
              return o4 = t3, n3 = (r2 = e4)[0], a3 = r2[1], void (!(n3 in o4) && a3 in o4 && (o4[n3] = o4[a3], 3 === r2.length && (o4[n3] = r2[2](o4[n3]))));
              var o4, r2, n3, a3;
            }), t3.long0 || !t3.longc || "Albers_Conic_Equal_Area" !== t3.projName && "Lambert_Azimuthal_Equal_Area" !== t3.projName || (t3.long0 = t3.longc), t3.lat_ts || !t3.lat1 || "Stereographic_South_Pole" !== t3.projName && "Polar Stereographic (variant B)" !== t3.projName || (t3.lat0 = D(t3.lat1 > 0 ? 90 : -90), t3.lat_ts = t3.lat1);
          }(a2), a2;
        };
      }]);
    });
  }
});

// node_modules/proj4-merge/proj4-merge.js
var require_proj4_merge = __commonJS({
  "node_modules/proj4-merge/proj4-merge.js"(exports4, module) {
    function merge() {
      const instances = [];
      const isEmpty = (it) => typeof it === "object" && Object.keys(it).length === 0 && JSON.stringify(it) === "{}";
      const add3 = (it) => {
        if (!it)
          return;
        if (Array.isArray(it))
          return it.forEach(add3);
        if (it.default)
          it = it.default;
        if (isEmpty(it))
          return;
        instances.push(it);
      };
      Array.from(arguments).forEach(add3);
      if (instances.length === 0)
        throw Error("[proj4-merge] merge called with zero instances of proj4");
      const [first, ...rest] = instances;
      rest.forEach((instance) => {
        first.defs(Object.entries(instance.defs));
      });
      return first;
    }
    if (typeof define === "function" && define.amd) {
      define(function() {
        return merge;
      });
    }
    if (typeof module === "object") {
      module.exports = merge;
      module.exports.default = merge;
    }
  }
});

// node_modules/reproject-bbox/pluggable.js
var require_pluggable2 = __commonJS({
  "node_modules/reproject-bbox/pluggable.js"(exports4, module) {
    function reprojectBoundingBoxPluggable({ bbox, reproject }) {
      const [xmin, ymin, xmax, ymax] = bbox;
      const topleft = reproject([xmin, ymax]);
      const topright = reproject([xmax, ymax]);
      const bottomleft = reproject([xmin, ymin]);
      const bottomright = reproject([xmax, ymin]);
      const corners = [topleft, topright, bottomleft, bottomright];
      const xs = corners.map((corner) => corner[0]);
      const ys = corners.map((corner) => corner[1]);
      return [Math.min(...xs), Math.min(...ys), Math.max(...xs), Math.max(...ys)];
    }
    if (typeof define === "function" && define.amd)
      define(function() {
        return reprojectBoundingBoxPluggable;
      });
    if (typeof module === "object") {
      module.exports = reprojectBoundingBoxPluggable;
      module.exports.default = reprojectBoundingBoxPluggable;
    }
    if (typeof window === "object")
      window.reprojectBoundingBoxPluggable = reprojectBoundingBoxPluggable;
    if (typeof self === "object")
      self.reprojectBoundingBoxPluggable = reprojectBoundingBoxPluggable;
  }
});

// node_modules/reproject-bbox/reproject-bbox.js
var require_reproject_bbox = __commonJS({
  "node_modules/reproject-bbox/reproject-bbox.js"(exports4, module) {
    var merge = require_proj4_merge();
    var proj43 = require_proj4_fully_loaded2();
    var reprojectBoundingBoxPluggable = require_pluggable2();
    if (typeof merge !== "function") {
      console.warn("[reproject-bbox] failed to import proj4-merge");
    }
    function reprojectBoundingBox2({ bbox, from, proj4: _proj4, to }) {
      if (typeof from === "number")
        from = "EPSG:" + from;
      if (typeof to === "number")
        to = "EPSG:" + to;
      const instances = [_proj4, proj43];
      if (typeof window === "object" && window.proj4)
        instances.push(window.proj4);
      if (typeof self === "object" && self.proj4)
        instances.push(self.proj4);
      const proj = merge(instances);
      const fwd = proj(from, to).forward;
      return reprojectBoundingBoxPluggable({ bbox, reproject: fwd });
    }
    if (typeof define === "function" && define.amd) {
      define(function() {
        return reprojectBoundingBox2;
      });
    }
    if (typeof module === "object") {
      module.exports = reprojectBoundingBox2;
      module.exports.default = reprojectBoundingBox2;
    }
    if (typeof window === "object") {
      window.reprojectBoundingBox = reprojectBoundingBox2;
    }
    if (typeof self === "object") {
      self.reprojectBoundingBox = reprojectBoundingBox2;
    }
  }
});

// node_modules/snap-bbox/snap-bbox.js
var require_snap_bbox = __commonJS({
  "node_modules/snap-bbox/snap-bbox.js"(exports4, module) {
    module.exports = ({ bbox, container, debug, origin, padding, scale }) => {
      if (debug)
        console.log("[snap-bbox] starting");
      if (debug)
        console.log("[snap-bbox] bbox:", bbox);
      if (debug)
        console.log("[snap-bbox] debug:", debug);
      if (debug)
        console.log("[snap-bbox] origin:", origin);
      if (debug)
        console.log("[snap-bbox] padding:", padding);
      if (debug)
        console.log("[snap-bbox] scale:", scale);
      const [originX, originY] = origin;
      if (debug)
        console.log("[snap-bbox] originX:", originX);
      if (debug)
        console.log("[snap-bbox] originY:", originY);
      const [padX, padY] = padding || [0, 0];
      if (debug)
        console.log("[snap-bbox] padX:", padX);
      if (debug)
        console.log("[snap-bbox] padY:", padY);
      const [scale_x, scale_y] = scale;
      if (debug)
        console.log("[snap-bbox] scale_x:", scale_x);
      if (debug)
        console.log("[snap-bbox] scale_y:", scale_y);
      const sign_scale_x = Math.sign(scale_x);
      const sign_scale_y = Math.sign(scale_y);
      if (debug)
        console.log("[snap-bbox] sign_scale_x:", sign_scale_x);
      if (debug)
        console.log("[snap-bbox] sign_scale_y:", sign_scale_y);
      const [xmin, ymin, xmax, ymax] = bbox;
      if (debug)
        console.log("[snap-bbox] xmin:", xmin);
      if (debug)
        console.log("[snap-bbox] ymin:", ymin);
      if (debug)
        console.log("[snap-bbox] xmax:", xmax);
      if (debug)
        console.log("[snap-bbox] ymax:", ymax);
      const left = (xmin - originX) / scale_x;
      const right = (xmax - originX) / scale_x;
      const top = (ymax - originY) / scale_y;
      const bottom = (ymin - originY) / scale_y;
      if (debug)
        console.log("[snap-bbox] left:", left);
      if (debug)
        console.log("[snap-bbox] right:", right);
      if (debug)
        console.log("[snap-bbox] top:", top);
      if (debug)
        console.log("[snap-bbox] bottom:", bottom);
      let left_int = Math.floor(left) - padX;
      let right_int = Math.ceil(right) + padX;
      let top_int = Math.floor(top) - padY;
      let bottom_int = Math.ceil(bottom) + padY;
      if (debug)
        console.log("[snap-bbox] left_int:", left_int);
      if (debug)
        console.log("[snap-bbox] right_int:", right_int);
      if (debug)
        console.log("[snap-bbox] top_int:", top_int);
      if (debug)
        console.log("[snap-bbox] bottom_int:", bottom_int);
      if (container) {
        if (debug)
          console.log("[snap-bbox] container:", container);
        const min_left = (container[0] - originX) / scale_x;
        const max_right = (container[2] - originX) / scale_x;
        const min_top = (container[3] - originY) / scale_y;
        const max_bottom = (container[1] - originY) / scale_y;
        if (debug)
          console.log("[snap-bbox] min_left:", min_left);
        if (debug)
          console.log("[snap-bbox] max_right:", max_right);
        if (debug)
          console.log("[snap-bbox] min_top:", min_top);
        if (debug)
          console.log("[snap-bbox] max_bottom:", max_bottom);
        const min_left_int = Math.ceil(min_left);
        const max_right_int = Math.floor(max_right);
        const min_top_int = Math.ceil(min_top);
        const max_bottom_int = Math.floor(max_bottom);
        if (debug)
          console.log("[snap-bbox] min_left_int:", min_left_int);
        if (debug)
          console.log("[snap-bbox] max_right_int:", max_right_int);
        if (debug)
          console.log("[snap-bbox] min_top_int:", min_top_int);
        if (debug)
          console.log("[snap-bbox] max_bottom_int:", max_bottom_int);
        left_int = Math.max(left_int, min_left_int);
        right_int = Math.min(right_int, max_right_int);
        top_int = Math.max(top_int, min_top_int);
        bottom_int = Math.min(bottom_int, max_bottom_int);
        if (debug)
          console.log("[snap-bbox] after containment, left_int:", left_int);
        if (debug)
          console.log("[snap-bbox] after containment, right_int:", right_int);
        if (debug)
          console.log("[snap-bbox] after containment, top_int:", top_int);
        if (debug)
          console.log("[snap-bbox] after containment, bottom_int:", bottom_int);
      }
      const bbox_in_grid_cells = [
        left_int === 0 ? 0 : left_int,
        bottom_int === 0 ? 0 : bottom_int,
        right_int === 0 ? 0 : right_int,
        top_int === 0 ? 0 : top_int
      ];
      if (debug)
        console.log("[snap-bbox] bbox_in_grid_cells:", bbox_in_grid_cells);
      const bbox_in_coordinate_system = [
        originX + left_int * scale_x,
        originY + bottom_int * scale_y,
        originX + right_int * scale_x,
        originY + top_int * scale_y
      ];
      return { bbox_in_coordinate_system, bbox_in_grid_cells };
    };
  }
});

// node_modules/georaster-layer-for-leaflet/dist/v3/babel/esm/georaster-layer-for-leaflet.js
var import_runtime = __toESM(require_runtime());
var L2 = __toESM(require_leaflet_src());
var import_chroma_js = __toESM(require_chroma());
var import_geocanvas = __toESM(require_full());

// node_modules/pixel-utils/dist/esm/fit/index.js
var import_xdim = __toESM(require_xdim());

// node_modules/pixel-utils/dist/esm/raw-to-rgba/index.js
var import_quick_scale = __toESM(require_quick_scale());

// node_modules/pixel-utils/dist/esm/enums.js
var Layout;
(function(Layout2) {
  Layout2["[band][row][column]"] = "[band][row][column]";
  Layout2["[band][row,column]"] = "[band][row,column]";
  Layout2["[band,row,column]"] = "[band,row,column]";
  Layout2["[row,column,band]"] = "[row,column,band]";
  Layout2["[row,column][band]"] = "[row,column][band]";
  Layout2["[row][column][band]"] = "[row][column][band]";
  Layout2["[row][column,band]"] = "[row][column,band]";
})(Layout || (Layout = {}));

// node_modules/pixel-utils/dist/esm/make-no-data-rgb/index.js
function makeNoDataRGB(noDataValue) {
  return [noDataValue, noDataValue, noDataValue];
}

// node_modules/pixel-utils/dist/esm/raw-to-rgb/index.js
var import_quick_scale2 = __toESM(require_quick_scale());

// node_modules/pixel-utils/dist/esm/raw-to-rgb/convert-single.js
function convert_raw_one_band_pixel_to_rgb(noDataValue, noDataPixel, scale, pixel) {
  if (pixel.includes(noDataValue))
    return noDataPixel;
  const scaled = scale(pixel[0]);
  return [scaled, scaled, scaled];
}

// node_modules/pixel-utils/dist/esm/raw-to-rgb/convert-single-str.js
function convert_raw_one_band_pixel_to_rgb_str(noDataValue, noDataPixel, scale, pixel) {
  if (pixel.includes(noDataValue))
    return noDataPixel;
  const scaled = scale(pixel[0]);
  return "rgb(" + scaled + ", " + scaled + ", " + scaled + ")";
}

// node_modules/pixel-utils/dist/esm/raw-to-rgb/convert-double.js
function convert_raw_two_band_pixel_to_rgb(noDataValue, noDataPixel, scaleFunction1, scaleFunction2, pixel) {
  if (pixel.includes(noDataValue))
    return noDataPixel;
  return [scaleFunction1(pixel[0]), scaleFunction2(pixel[1]), 0];
}

// node_modules/pixel-utils/dist/esm/raw-to-rgb/convert-double-str.js
function convert_raw_two_band_pixel_to_rgb_str(noDataValue, noDataPixel, scaleFunction1, scaleFunction2, pixel) {
  if (pixel.includes(noDataValue))
    return noDataPixel;
  return "rgb(" + scaleFunction1(pixel[0]) + ", " + scaleFunction2(pixel[1]) + ", 0)";
}

// node_modules/pixel-utils/dist/esm/raw-to-rgb/convert-triple.js
function convert_raw_three_band_pixel_to_rgb(noDataValue, noDataPixel, scaleFunction1, scaleFunction2, scaleFunction3, pixel) {
  if (pixel.includes(noDataValue))
    return noDataPixel;
  return [scaleFunction1(pixel[0]), scaleFunction2(pixel[1]), scaleFunction3(pixel[2])];
}

// node_modules/pixel-utils/dist/esm/raw-to-rgb/convert-triple-str.js
function convert_raw_three_band_pixel_to_rgb_css(noDataValue, noDataPixel, scaleFunction1, scaleFunction2, scaleFunction3, pixel) {
  if (pixel.includes(noDataValue))
    return noDataPixel;
  return "rgb(" + scaleFunction1(pixel[0]) + ", " + scaleFunction2(pixel[1]) + ", " + scaleFunction3(pixel[2]) + ")";
}

// node_modules/pixel-utils/dist/esm/raw-to-rgb/convert-many.js
function convert_raw_two_band_pixel_to_rgb2(noDataValue, noDataPixel, scaleFunction1, scaleFunction2, scaleFunction3, pixel) {
  pixel = pixel.slice(0, 3);
  if (pixel.includes(noDataValue))
    return noDataPixel;
  return [scaleFunction1(pixel[0]), scaleFunction2(pixel[1]), scaleFunction3(pixel[2])];
}

// node_modules/pixel-utils/dist/esm/raw-to-rgb/convert-many-str.js
function convert_raw_two_band_pixel_to_rgb_str2(noDataValue, noDataPixel, scaleFunction1, scaleFunction2, scaleFunction3, pixel) {
  pixel = pixel.slice(0, 3);
  if (pixel.includes(noDataValue))
    return noDataPixel;
  return "rgb(" + scaleFunction1(pixel[0]) + ", " + scaleFunction2(pixel[1]) + ", " + scaleFunction3(pixel[2]) + ")";
}

// node_modules/pixel-utils/dist/esm/rgb-to-str/index.js
function rgbToStr([r, g, b]) {
  return "rgb(" + r + ", " + g + ", " + b + ")";
}

// node_modules/pixel-utils/dist/esm/raw-to-rgb/index.js
function rawToRgb({
  format = "array",
  ranges,
  flip,
  new_no_data_pixel,
  new_no_data_value,
  no_range_value,
  no_range_value_strategy,
  old_no_data_value,
  round = true
}) {
  const nbands = ranges.length;
  if (new_no_data_pixel && new_no_data_value) {
    throw new Error("[pixel-utils/raw-to-rgb] can't specify both new_no_data_pixel and new_no_data_value");
  }
  if (new_no_data_pixel === void 0 || new_no_data_pixel === null) {
    if (new_no_data_value === void 0 || new_no_data_value === null) {
      new_no_data_pixel = makeNoDataRGB(null);
    } else {
      new_no_data_pixel = makeNoDataRGB(new_no_data_value);
    }
  }
  if (new_no_data_pixel === void 0)
    throw new Error("[raw-to-rgb] undefined new_no_data_pixel");
  const new_range = [0 === new_no_data_value ? 1 : 0, 255 === new_no_data_value ? 254 : 255];
  const options = {
    flip,
    no_range_value,
    no_range_value_strategy,
    round
  };
  const scalefns = ranges.slice(0, 3).map((rng) => (0, import_quick_scale2.createScaleFunction)(rng, new_range, options));
  if (nbands === 1) {
    if (format === "string") {
      return convert_raw_one_band_pixel_to_rgb_str.bind(null, old_no_data_value, rgbToStr(new_no_data_pixel), ...scalefns);
    } else {
      return convert_raw_one_band_pixel_to_rgb.bind(null, old_no_data_value, new_no_data_pixel, ...scalefns);
    }
  } else if (nbands === 2) {
    if (format === "string") {
      return convert_raw_two_band_pixel_to_rgb_str.bind(null, old_no_data_value, rgbToStr(new_no_data_pixel), ...scalefns);
    } else {
      return convert_raw_two_band_pixel_to_rgb.bind(null, old_no_data_value, new_no_data_pixel, ...scalefns);
    }
  } else if (nbands === 3) {
    if (format === "string") {
      return convert_raw_three_band_pixel_to_rgb_css.bind(null, old_no_data_value, rgbToStr(new_no_data_pixel), ...scalefns);
    } else {
      return convert_raw_three_band_pixel_to_rgb.bind(null, old_no_data_value, new_no_data_pixel, ...scalefns);
    }
  } else if (nbands >= 4) {
    if (format === "string") {
      return convert_raw_two_band_pixel_to_rgb_str2.bind(null, old_no_data_value, rgbToStr(new_no_data_pixel), ...scalefns);
    } else {
      return convert_raw_two_band_pixel_to_rgb2.bind(null, old_no_data_value, new_no_data_pixel, ...scalefns);
    }
  } else {
    throw new Error("[pixel-utils/raw-to-rgb] invalid number of bands: " + nbands);
  }
}

// node_modules/georaster-layer-for-leaflet/dist/v3/babel/esm/georaster-layer-for-leaflet.js
var import_isUTM = __toESM(require_isUTM());
var import_getProjString = __toESM(require_getProjString());
var import_proj4_fully_loaded = __toESM(require_proj4_fully_loaded2());

// node_modules/geo-extent/dist/geo-extent.mjs
var import_add = __toESM(require_add2(), 1);
var import_divide = __toESM(require_divide2(), 1);
var import_multiply = __toESM(require_multiply2(), 1);
var import_subtract = __toESM(require_subtract2(), 1);
var import_get_epsg_code = __toESM(require_get_epsg_code_all_node_min(), 1);
var import_reproject_bbox = __toESM(require_reproject_bbox(), 1);
var avg = (a, b) => (0, import_divide.default)((0, import_add.default)(a.toString(), b.toString()), "2");
var isAry = (o) => Array.isArray(o);
var isDef = (o) => o !== void 0 && o !== null && o !== "";
var isFunc = (o) => typeof o === "function";
var isObj = (o) => typeof o === "object";
var isStr = (o) => typeof o === "string";
var isNum = (o) => typeof o === "number";
var isBoxStr = (o) => isStr(o) && !!o.match(/^[-|+]?[\d\.]+(, ?[-|+]?[\d\.]+){3}$/);
var isLeafletLatLngBounds = (o) => isObj(o) && hasFuncs(o, ["getEast", "getNorth", "getSouth", "getWest"]);
var hasFunc = (o, f) => isObj(o) && isFunc(o[f]);
var hasObj = (o, k) => isObj(o) && isObj(o[k]);
var hasFuncs = (o, fs) => fs.every((f) => hasFunc(o, f));
var hasObjs = (o, ks) => ks.every((k) => hasObj(o, k));
var hasKey = (o, k) => isObj(o) && o[k] !== void 0 && o[k] !== null;
var hasKeys = (o, ks) => ks.every((k) => hasKey(o, k));
var allNums = (ary) => isAry(ary) && ary.every(isNum);
var allStrs = (ary) => isAry(ary) && ary.every(isStr);
var getConstructor = (o) => typeof obj === "object" && typeof obj.constructor === "function" || void 0;
var normalize = (srs) => {
  if (!srs)
    return srs;
  if (isStr(srs) && srs.startsWith("EPSG:"))
    return srs;
  if (isStr(srs) && srs.match(/^\d+$/))
    return "EPSG:" + srs;
  else if (isNum(srs))
    return "EPSG:" + srs;
  const code = (0, import_get_epsg_code.default)(srs);
  if (isNum(code))
    return "EPSG:" + code;
  return srs;
};
var GeoExtent = class {
  constructor(o, { srs } = {}) {
    this.srs = normalize(srs);
    let xmin, xmax, ymin, ymax;
    let xmin_str, xmax_str, ymin_str, ymax_str;
    if (getConstructor(o) === this.constructor) {
      ({ xmin, xmax, ymin, ymax } = o);
      if (isDef(o.srs)) {
        this.srs = normalize(o.srs);
      }
    }
    if (isBoxStr(o))
      o = o.split(/, ?/);
    if (isAry(o) && o.length === 4 && allNums(o)) {
      [xmin, ymin, xmax, ymax] = o;
    } else if (isAry(o) && o.length === 4 && allStrs(o)) {
      [xmin_str, ymin_str, xmax_str, ymax_str] = o;
      [xmin, ymin, xmax, ymax] = o.map((str) => Number(str));
    } else if (isAry(o) && o.length === 2 && o.every(isAry) && o.every((o2) => o2.length === 2 && allNums(o2))) {
      [[ymin, xmin], [ymax, xmax]] = o;
    } else if (isLeafletLatLngBounds(o)) {
      xmin = o.getWest(), xmax = o.getEast(), ymin = o.getSouth(), ymax = o.getNorth();
      if (!isDef(this.srs))
        this.srs = "EPSG:4326";
    } else if (isAry(o) && o.length === 2 && o.every((it) => hasKeys(it, ["x", "y"]))) {
      [{ x: xmin, y: ymin }, { x: xmax, y: ymax }] = o;
    } else if (isObj(o) && hasKeys(o, ["x", "y"]) && isNum(o.x) && isNum(o.y)) {
      xmin = xmax = o.x;
      ymin = ymax = o.y;
      if (hasKey(o, "spatialReference") && hasKey(o.spatialReference, "wkid")) {
        if (!isDef(this.srs))
          this.srs = normalize(o.spatialReference.wkid);
      }
    } else if (isObj(o) && hasKeys(o, ["xmin", "xmax", "ymin", "ymax"])) {
      ({ xmin, xmax, ymin, ymax } = o);
      const keys = ["srs", "crs", "proj", "projection"];
      for (let i = 0; i < keys.length; i++) {
        const k = keys[i];
        const v = o[k];
        const normalized = normalize(v);
        if (normalized) {
          this.srs = normalized;
          break;
        }
      }
      if (!this.srs && isDef(o.srs)) {
        this.srs = o.srs;
      }
    } else if (isAry(o) && o.length === 2 && allNums(o)) {
      xmin = xmax = o[0];
      ymin = ymax = o[1];
    } else if (isObj(o) && hasFuncs(o, ["getCoordinates"])) {
      const xy = o.getCoordinates();
      xmin = xmax = xy[0];
      ymin = ymax = xy[1];
    } else if (isObj(o) && hasKey(o, "bbox") && o.bbox.length === 4 && allNums(o)) {
      [xmin, ymin, xmax, ymax] = o.bbox;
    } else if (hasObj(o, "_bounds") && isLeafletLatLngBounds(o._bounds)) {
      const { _bounds } = o;
      xmin = _bounds.getWest(), xmax = _bounds.getEast(), ymin = _bounds.getSouth(), ymax = _bounds.getNorth();
      if (!this.srs)
        this.srs = "EPSG:4326";
    } else if (isObj(o) && isObj(o._bounds) && hasObjs(o._bounds, ["_southWest", "_northEast"])) {
      ({ lat: ymin, lng: xmin } = o._bounds._southWest);
      ({ lat: ymax, lng: xmax } = o._bounds._northEast);
      if (!isDef(this.srs))
        this.srs = "EPSG:4326";
    } else {
      throw new Error("[geo-extent] unknown format");
    }
    this.xmin = xmin;
    this.xmin_str = xmin_str || xmin.toString();
    this.ymin = ymin;
    this.ymin_str = ymin_str || ymin.toString();
    this.xmax = xmax;
    this.xmax_str = xmax_str || xmax.toString();
    this.ymax = ymax;
    this.ymax_str = ymax_str || ymax.toString();
    this.width_str = (0, import_subtract.default)(this.xmax_str, this.xmin_str);
    this.width = Number(this.width_str);
    this.height_str = (0, import_subtract.default)(this.ymax_str, this.ymin_str);
    this.height = Number(this.height_str);
    this.bottomLeft = { x: xmin, y: ymin };
    this.bottomRight = { x: xmax, y: ymin };
    this.topLeft = { x: xmin, y: ymax };
    this.topRight = { x: xmax, y: ymax };
    this.leafletBounds = [
      [this.ymin, this.xmin],
      [this.ymax, this.xmax]
    ];
    this.area_str = (0, import_multiply.default)(this.width_str, this.height_str);
    this.area = Number(this.area_str);
    this.perimeter_str = (0, import_add.default)((0, import_multiply.default)(this.width_str, "2"), (0, import_multiply.default)(this.height_str, "2"));
    this.perimeter = Number(this.perimeter_str);
    this.bbox = [xmin, ymin, xmax, ymax];
    this.bbox_str = [this.xmin_str, this.ymin_str, this.xmax_str, this.ymax_str];
    this.center_str = {
      x: avg(xmin_str || xmin, xmax_str || xmax),
      y: avg(ymin_str || ymin, ymax_str || ymax)
    };
    this.center = { x: Number(this.center_str.x), y: Number(this.center_str.y) };
    this.str = this.bbox_str.join(",");
  }
  _pre(_this, _other) {
    _other = new this.constructor(_other);
    if (!isDef(_this.srs) && !isDef(_other.srs)) {
    } else if (isDef(_this.srs) && !isDef(_other.srs)) {
      _other = new _this.constructor({ ..._other, srs: _this.srs });
    } else if (!isDef(_this.srs) && isDef(_other.srs)) {
      _this = new _this.constructor({ ..._this, srs: _other.srs });
    } else if (isDef(_this.srs) && isDef(_other.srs) && _this.srs !== _other.srs) {
      _other = _other.reproj(_this.srs);
    } else if (isDef(_this.srs) && isDef(_other.srs) && _this.srs === _other.srs) {
    } else {
      throw "UH OH";
    }
    return [_this, _other];
  }
  clone() {
    return new this.constructor(this);
  }
  contains(other) {
    const [_this, _other] = this._pre(this, other);
    const xContains = _other.xmin >= _this.xmin && _other.xmax <= _this.xmax;
    const yContains = _other.ymin >= _this.ymin && _other.ymax <= _this.ymax;
    return xContains && yContains;
  }
  crop(other) {
    other = new this.constructor(other);
    if (this.overlaps(other, { quiet: true }) === false && other.overlaps(this, { quiet: true }) === false)
      return null;
    if (other.contains(this))
      return this.clone();
    if (other.srs === "EPSG:4326" && (other.xmin < -180 || other.xmax > 180)) {
      const parts = other.unwrap();
      let cropped = parts.map((it) => this.crop(it));
      cropped = cropped.filter(Boolean);
      if (cropped.length === 0)
        return null;
      let combo = cropped[0];
      for (let i = 1; i < cropped.length; i++)
        combo = combo.combine(cropped[i]);
      return combo;
    }
    let another = isDef(this.srs) && isDef(other.srs) ? other.reproj(this.srs, { quiet: true }) : other.clone();
    if (another) {
      if (!this.overlaps(another))
        return null;
      const xmin = Math.max(this.xmin, another.xmin);
      const ymin = Math.max(this.ymin, another.ymin);
      const xmax = Math.min(this.xmax, another.xmax);
      const ymax = Math.min(this.ymax, another.ymax);
      return new this.constructor([xmin, ymin, xmax, ymax], { srs: this.srs });
    }
    const this4326 = isDef(this.srs) ? this.reproj(4326) : this;
    const other4326 = isDef(other.srs) ? other.reproj(4326) : other;
    const [aMinLon, aMinLat, aMaxLon, aMaxLat] = this4326.bbox;
    const [bMinLon, bMinLat, bMaxLon, bMaxLat] = other4326.bbox;
    if (!this4326.overlaps(other4326))
      return null;
    const minLon = Math.max(aMinLon, bMinLon);
    const minLat = Math.max(aMinLat, bMinLat);
    const maxLon = Math.min(aMaxLon, bMaxLon);
    const maxLat = Math.min(aMaxLat, bMaxLat);
    return new this.constructor([minLon, minLat, maxLon, maxLat], { srs: 4326 }).reproj(this.srs);
  }
  combine(other) {
    if (isDef(this.srs) && isDef(other.srs)) {
      other = other.reproj(this.srs);
    }
    const xmin = Math.min(this.xmin, other.xmin);
    const xmax = Math.max(this.xmax, other.xmax);
    const ymin = Math.min(this.ymin, other.ymin);
    const ymax = Math.max(this.ymax, other.ymax);
    return new this.constructor({ xmin, xmax, ymin, ymax, srs: this.srs });
  }
  equals(other, { digits = 13, strict = true } = { digits: 13, strict: true }) {
    other = new this.constructor(other);
    if (isDef(this.srs) && isDef(other.srs)) {
      other = other.reproj(this.srs);
    } else if (strict && isDef(this.srs) !== !isDef(this.srs)) {
      return false;
    }
    const str1 = this.bbox.map((n) => n.toFixed(digits)).join(",");
    const str2 = other.bbox.map((n) => n.toFixed(digits)).join(",");
    return str1 === str2;
  }
  overlaps(other, { quiet = false } = { quite: false }) {
    try {
      const [_this, _other] = this._pre(this, other);
      const yOverlaps = _other.ymin <= _this.ymax && _other.ymax >= _this.ymin;
      const xOverlaps = _other.xmin <= _this.xmax && _other.xmax >= _this.xmin;
      return xOverlaps && yOverlaps;
    } catch (error) {
      if (quiet)
        return;
      else
        throw error;
    }
  }
  reproj(to, { quiet = false } = { quiet: false }) {
    to = normalize(to);
    if (isDef(this.srs) && this.srs === normalize(to))
      return this.clone();
    if (!isDef(this.srs)) {
      if (quiet)
        return;
      throw new Error(`[geo-extent] cannot reproject ${this.bbox} without a projection set`);
    }
    if (this.srs === "EPSG:4326" && (this.xmin < -180 || this.xmax > 180)) {
      try {
        const parts = this.unwrap().map((ext) => ext.reproj(to));
        let combo = parts[0];
        for (let i = 1; i < parts.length; i++)
          combo = combo.combine(parts[i]);
        return combo;
      } catch (error) {
        if (quiet)
          return;
        throw error;
      }
    }
    const reprojected = (0, import_reproject_bbox.default)({
      bbox: this.bbox,
      from: this.srs,
      to
    });
    if (reprojected.some(isNaN)) {
      if (quiet)
        return;
      throw new Error(`[geo-extent] failed to reproject ${this.bbox} from ${this.srs} to ${to}`);
    }
    return new GeoExtent(reprojected, { srs: to });
  }
  unwrap() {
    const { xmin, ymin, xmax, ymax, srs } = this;
    if (srs !== "EPSG:4326")
      return [this.clone()];
    if (xmin > -180 && xmax < 180)
      return [this.clone()];
    if (xmin < -180 && xmax >= xmin + 360)
      return [new this.constructor([-180, ymin, 180, ymax], { srs: 4326 })];
    if (xmax > 180 && xmin <= xmax - 360)
      return [new this.constructor([-180, ymin, 180, ymax], { srs: 4326 })];
    let extents = [];
    if (xmin < -180) {
      extents.push(new this.constructor([xmin + 360, ymin, 180, ymax], { srs }));
    }
    extents.push(new this.constructor([xmin < -180 ? -180 : xmin, ymin, xmax > 180 ? 180 : xmax, ymax], { srs }));
    if (this.xmax > 180) {
      extents.push(new this.constructor([-180, ymin, xmax - 360, ymax], { srs }));
    }
    return extents;
  }
  asEsriJSON() {
    return {
      xmin: this.xmin,
      ymin: this.ymin,
      xmax: this.xmax,
      ymax: this.ymax,
      spatialReference: {
        wkid: this.srs
      }
    };
  }
  asGeoJSON() {
    const { xmin, ymin, xmax, ymax } = this.srs === "EPSG:4326" ? this : this.reproj(4326);
    return {
      type: "Feature",
      geometry: {
        type: "Polygon",
        coordinates: [
          [
            [xmin, ymax],
            [xmax, ymax],
            [xmax, ymin],
            [xmin, ymin],
            [xmin, ymax]
          ]
        ]
      }
    };
  }
  asObj() {
    const res = {};
    for (let k in this) {
      const v = this[k];
      if (!isFunc(v)) {
        res[k] = v;
      }
    }
    return res;
  }
};
if (typeof define === "function" && define.amd)
  define(function() {
    return GeoExtent;
  });
if (typeof self === "object")
  self.GeoExtent = GeoExtent;
if (typeof window === "object")
  window.GeoExtent = GeoExtent;

// node_modules/georaster-layer-for-leaflet/dist/v3/babel/esm/georaster-layer-for-leaflet.js
var import_snap_bbox = __toESM(require_snap_bbox());
var EPSG4326 = 4326;
var PROJ4_SUPPORTED_PROJECTIONS = /* @__PURE__ */ new Set([3785, 3857, 4269, 4326, 900913, 102113]);
var MAX_NORTHING = 1e3;
var MAX_EASTING = 1e3;
var ORIGIN = [0, 0];
var log = (obj2) => console.log("[georaster-layer-for-leaflet] ", obj2);
var isSimpleCRS = (crs) => {
  var _crs$transformation, _crs$transformation2, _crs$transformation3, _crs$transformation4;
  return crs === L2.CRS.Simple || !crs.code && crs.infinite && (crs === null || crs === void 0 ? void 0 : (_crs$transformation = crs.transformation) === null || _crs$transformation === void 0 ? void 0 : _crs$transformation._a) === 1 && (crs === null || crs === void 0 ? void 0 : (_crs$transformation2 = crs.transformation) === null || _crs$transformation2 === void 0 ? void 0 : _crs$transformation2._b) === 0 && (crs === null || crs === void 0 ? void 0 : (_crs$transformation3 = crs.transformation) === null || _crs$transformation3 === void 0 ? void 0 : _crs$transformation3._c) === -1 && (crs === null || crs === void 0 ? void 0 : (_crs$transformation4 = crs.transformation) === null || _crs$transformation4 === void 0 ? void 0 : _crs$transformation4._d) === 0;
};
if (!L2)
  console.warn("[georaster-layer-for-leaflet] can't find Leaflet.  If you are loading via <script>, please add the GeoRasterLayer script after the LeafletJS script.");
var zip = (a, b) => a.map((it, i) => [it, b[i]]);
var GeoRasterLayer = L2.GridLayer.extend({
  options: {
    updateWhenIdle: true,
    updateWhenZooming: false,
    keepBuffer: 25,
    resolution: 2 ** 5,
    debugLevel: 0
  },
  initialize: function(options) {
    try {
      if (options.georasters) {
        this.georasters = options.georasters;
      } else if (options.georaster) {
        this.georasters = [options.georaster];
      } else {
        throw new Error("You initialized a GeoRasterLayer without a georaster or georasters value.");
      }
      if (this.sourceType === "url") {
        options.updateWhenIdle = false;
        options.updateWhenZooming = true;
        options.keepBuffer = 16;
      }
      if (options.resampleMethod) {
        this.resampleMethod = options.resampleMethod;
      }
      const keys = ["height", "width", "noDataValue", "palette", "pixelHeight", "pixelWidth", "projection", "sourceType", "xmin", "xmax", "ymin", "ymax"];
      if (this.georasters.length > 1) {
        keys.forEach((key) => {
          if (this.same(this.georasters, key)) {
            this[key] = this.georasters[0][key];
          } else {
            throw new Error("all GeoRasters must have the same " + key);
          }
        });
      } else if (this.georasters.length === 1) {
        keys.forEach((key) => {
          this[key] = this.georasters[0][key];
        });
      }
      this._cache = {
        innerTile: {},
        tile: {}
      };
      this.extent = new GeoExtent([this.xmin, this.ymin, this.xmax, this.ymax], {
        srs: this.projection
      });
      this.ratio = this.height / this.width;
      this.debugLevel = options.debugLevel;
      if (this.debugLevel >= 1)
        log({
          options
        });
      if (this.georasters.every((georaster) => typeof georaster.values === "object")) {
        this.rasters = this.georasters.reduce((result2, georaster) => {
          if (georaster.values) {
            result2 = result2.concat(georaster.values);
            return result2;
          }
        }, []);
        if (this.debugLevel > 1)
          console.log("this.rasters:", this.rasters);
      }
      if (options.mask) {
        if (typeof options.mask === "string") {
          this.mask = fetch(options.mask).then((r) => r.json());
        } else if (typeof options.mask === "object") {
          this.mask = Promise.resolve(options.mask);
        }
        this.mask_srs = options.mask_srs || "EPSG:4326";
      }
      this.mask_strategy = options.mask_strategy || "outside";
      this.chroma = import_chroma_js.default;
      this.scale = import_chroma_js.default.scale();
      L2.Util.setOptions(this, options);
      const tileSize = this.getTileSize();
      this.tileHeight = tileSize.y;
      this.tileWidth = tileSize.x;
      if (this.georasters.length >= 4 && !options.pixelValuesToColorFn) {
        throw "you must pass in a pixelValuesToColorFn if you are combining rasters";
      }
      this.numBands = this.georasters.reduce((total, g) => total + g.numberOfRasters, 0);
      if (this.debugLevel > 1)
        console.log("this.numBands:", this.numBands);
      this.currentStats = {
        mins: new Array(this.numBands),
        maxs: new Array(this.numBands),
        ranges: new Array(this.numBands)
      };
      if ([1, 2, 3].includes(this.georasters.length) && this.georasters.every((g) => g.sourceType === "url") && this.georasters.every((g) => g.numberOfRasters === 1) && !options.pixelValuesToColorFn) {
        try {
          this.calcStats = true;
          this._dynamic = true;
          this.options.pixelValuesToColorFn = (values) => {
            const haveDataForAllBands = values.every((value) => value !== void 0 && value !== this.noDataValue);
            if (haveDataForAllBands) {
              return this.rawToRgb(values);
            }
          };
        } catch (error) {
          console.error("[georaster-layer-for-leaflet]", error);
        }
      }
      this.checkIfYCbCr = new Promise(async (resolve) => {
        if (this.options.pixelValuesToColorFn)
          return resolve(true);
        if (this.georasters.length === 1 && this.georasters[0].numberOfRasters === 3) {
          var _this$georasters$0$_g, _image$fileDirectory;
          const image = await ((_this$georasters$0$_g = this.georasters[0]._geotiff) === null || _this$georasters$0$_g === void 0 ? void 0 : _this$georasters$0$_g.getImage());
          if ((image === null || image === void 0 ? void 0 : (_image$fileDirectory = image.fileDirectory) === null || _image$fileDirectory === void 0 ? void 0 : _image$fileDirectory.PhotometricInterpretation) === 6) {
            this.options.pixelValuesToColorFn = (values) => {
              const r = Math.round(values[0] + 1.402 * (values[2] - 128));
              const g = Math.round(values[0] - 0.34414 * (values[1] - 128) - 0.71414 * (values[2] - 128));
              const b = Math.round(values[0] + 1.772 * (values[1] - 128));
              return `rgb(${r},${g},${b})`;
            };
          }
        }
        return resolve(true);
      });
    } catch (error) {
      console.error("ERROR initializing GeoTIFFLayer", error);
    }
  },
  getRasters: function(options) {
    const {
      innerTileTopLeftPoint,
      heightOfSampleInScreenPixels,
      widthOfSampleInScreenPixels,
      zoom,
      numberOfSamplesAcross,
      numberOfSamplesDown,
      ymax,
      xmin
    } = options;
    if (this.debugLevel >= 1)
      console.log("starting getRasters with options:", options);
    const rasterCoordsForTileCoords = (h, w) => {
      const xInMapPixels = innerTileTopLeftPoint.x + w * widthOfSampleInScreenPixels;
      const yInMapPixels = innerTileTopLeftPoint.y + h * heightOfSampleInScreenPixels;
      const mapPoint = L2.point(xInMapPixels, yInMapPixels);
      if (this.debugLevel >= 1)
        log({
          mapPoint
        });
      const {
        lat,
        lng
      } = this.getMap().unproject(mapPoint, zoom);
      if (this.projection === EPSG4326) {
        return {
          y: Math.round((ymax - lat) / this.pixelHeight),
          x: Math.round((lng - xmin) / this.pixelWidth)
        };
      } else if (this.getProjector()) {
        const [x, y] = this.getProjector().inverse([lng, lat]);
        if (x === Infinity || y === Infinity) {
          if (this.debugLevel >= 1)
            console.error("projector converted", [lng, lat], "to", [x, y]);
        }
        return {
          y: Math.round((ymax - y) / this.pixelHeight),
          x: Math.round((x - xmin) / this.pixelWidth)
        };
      } else {
        return null;
      }
    };
    const topLeft = rasterCoordsForTileCoords(0, 0);
    const bottomRight = rasterCoordsForTileCoords(numberOfSamplesDown, numberOfSamplesAcross);
    const getValuesOptions = {
      bottom: bottomRight === null || bottomRight === void 0 ? void 0 : bottomRight.y,
      height: numberOfSamplesDown,
      left: topLeft === null || topLeft === void 0 ? void 0 : topLeft.x,
      right: bottomRight === null || bottomRight === void 0 ? void 0 : bottomRight.x,
      top: topLeft === null || topLeft === void 0 ? void 0 : topLeft.y,
      width: numberOfSamplesAcross
    };
    if (!Object.values(getValuesOptions).every((it) => it !== void 0 && isFinite(it))) {
      console.error("getRasters failed because not all values are finite:", getValuesOptions);
    } else {
      return Promise.all(this.georasters.map((georaster) => georaster.getValues({
        ...getValuesOptions,
        resampleMethod: this.resampleMethod || "nearest"
      }))).then((valuesByGeoRaster) => valuesByGeoRaster.reduce((result2, values) => {
        result2 = result2.concat(values);
        return result2;
      }, []));
    }
  },
  createTile: function(coords, done) {
    const tile = L2.DomUtil.create("canvas", "leaflet-tile");
    tile.style.boxSizing = "content-box";
    tile.style.visibility = "hidden";
    const context = tile.getContext("2d");
    this.drawTile({
      tile,
      coords,
      context,
      done
    });
    return tile;
  },
  drawTile: function({
    tile,
    coords,
    context,
    done
  }) {
    try {
      const {
        debugLevel = 0
      } = this;
      if (debugLevel >= 2)
        console.log("starting drawTile with", {
          tile,
          coords,
          context,
          done
        });
      let error;
      const {
        z: zoom
      } = coords;
      const cacheKey = [coords.x, coords.y, coords.z].join(",");
      if (debugLevel >= 2)
        log({
          cacheKey
        });
      const mapCRS = this.getMapCRS();
      if (debugLevel >= 2)
        log({
          mapCRS
        });
      const inSimpleCRS = isSimpleCRS(mapCRS);
      if (debugLevel >= 2)
        log({
          inSimpleCRS
        });
      const {
        rasters,
        xmin,
        xmax,
        ymin,
        ymax
      } = this;
      const rasterHeight = this.height;
      const rasterWidth = this.width;
      const extentOfLayer = new GeoExtent(this.getBounds(), {
        srs: inSimpleCRS ? "simple" : 4326
      });
      if (debugLevel >= 2)
        log({
          extentOfLayer
        });
      const pixelHeight = inSimpleCRS ? extentOfLayer.height / rasterHeight : this.pixelHeight;
      const pixelWidth = inSimpleCRS ? extentOfLayer.width / rasterWidth : this.pixelWidth;
      if (debugLevel >= 2)
        log({
          pixelHeight,
          pixelWidth
        });
      const {
        xMinOfLayer,
        xMaxOfLayer,
        yMinOfLayer,
        yMaxOfLayer
      } = this;
      const boundsOfTile = this._tileCoordsToBounds(coords);
      if (debugLevel >= 2)
        log({
          boundsOfTile
        });
      const {
        code
      } = mapCRS;
      if (debugLevel >= 2)
        log({
          code
        });
      const extentOfTile = new GeoExtent(boundsOfTile, {
        srs: inSimpleCRS ? "simple" : 4326
      });
      if (debugLevel >= 2)
        log({
          extentOfTile
        });
      if (debugLevel >= 4) {
        if (!this._cache.tile[cacheKey]) {
          this._cache.tile[cacheKey] = L2.rectangle(extentOfTile.leafletBounds, {
            fillOpacity: 0
          }).addTo(this.getMap()).bindTooltip(cacheKey, {
            direction: "center",
            permanent: true
          });
        }
      }
      const extentOfTileInMapCRS = inSimpleCRS ? extentOfTile : extentOfTile.reproj(code);
      if (debugLevel >= 2)
        log({
          extentOfTileInMapCRS
        });
      let extentOfInnerTileInMapCRS = extentOfTileInMapCRS.crop(inSimpleCRS ? extentOfLayer : this.extent);
      if (debugLevel >= 2)
        console.log("[georaster-layer-for-leaflet] extentOfInnerTileInMapCRS", extentOfInnerTileInMapCRS.reproj(inSimpleCRS ? "simple" : 4326));
      if (debugLevel >= 2)
        log({
          coords,
          extentOfInnerTileInMapCRS,
          extent: this.extent
        });
      if (debugLevel >= 4) {
        if (!this._cache.innerTile[cacheKey]) {
          const ext = inSimpleCRS ? extentOfInnerTileInMapCRS : extentOfInnerTileInMapCRS.reproj(4326);
          this._cache.innerTile[cacheKey] = L2.rectangle(ext.leafletBounds, {
            color: "#F00",
            dashArray: "5, 10",
            fillOpacity: 0
          }).addTo(this.getMap());
        }
      }
      const widthOfScreenPixelInMapCRS = extentOfTileInMapCRS.width / this.tileWidth;
      const heightOfScreenPixelInMapCRS = extentOfTileInMapCRS.height / this.tileHeight;
      if (debugLevel >= 3)
        log({
          heightOfScreenPixelInMapCRS,
          widthOfScreenPixelInMapCRS
        });
      const oldExtentOfInnerTileInRasterCRS = inSimpleCRS ? extentOfInnerTileInMapCRS : extentOfInnerTileInMapCRS.reproj(this.projection);
      const snapped = (0, import_snap_bbox.default)({
        bbox: oldExtentOfInnerTileInRasterCRS.bbox,
        container: inSimpleCRS ? [extentOfLayer.xmin, extentOfLayer.ymin - 0.25 * pixelHeight, extentOfLayer.xmax + 0.25 * pixelWidth, extentOfLayer.ymax] : [xmin, ymin - 0.25 * pixelHeight, xmax + 0.25 * pixelWidth, ymax],
        debug: debugLevel >= 2,
        origin: inSimpleCRS ? [extentOfLayer.xmin, extentOfLayer.ymax] : [xmin, ymax],
        scale: [pixelWidth, -pixelHeight]
      });
      const extentOfInnerTileInRasterCRS = new GeoExtent(snapped.bbox_in_coordinate_system, {
        srs: inSimpleCRS ? "simple" : this.projection
      });
      const gridbox = snapped.bbox_in_grid_cells;
      const snappedSamplesAcross = Math.abs(gridbox[2] - gridbox[0]);
      const snappedSamplesDown = Math.abs(gridbox[3] - gridbox[1]);
      const rasterPixelsAcross = Math.ceil(oldExtentOfInnerTileInRasterCRS.width / pixelWidth);
      const rasterPixelsDown = Math.ceil(oldExtentOfInnerTileInRasterCRS.height / pixelHeight);
      const {
        resolution
      } = this.options;
      const layerCropExtent = inSimpleCRS ? extentOfLayer : this.extent;
      const recropTileOrig = oldExtentOfInnerTileInRasterCRS.crop(layerCropExtent);
      let maxSamplesAcross = 1;
      let maxSamplesDown = 1;
      if (recropTileOrig !== null) {
        const recropTileProj = inSimpleCRS ? recropTileOrig : recropTileOrig.reproj(code);
        const recropTile = recropTileProj.crop(extentOfTileInMapCRS);
        if (recropTile !== null) {
          maxSamplesAcross = Math.ceil(resolution * (recropTile.width / extentOfTileInMapCRS.width));
          maxSamplesDown = Math.ceil(resolution * (recropTile.height / extentOfTileInMapCRS.height));
        }
      }
      const overdrawTileAcross = rasterPixelsAcross < maxSamplesAcross;
      const overdrawTileDown = rasterPixelsDown < maxSamplesDown;
      const numberOfSamplesAcross = overdrawTileAcross ? snappedSamplesAcross : maxSamplesAcross;
      const numberOfSamplesDown = overdrawTileDown ? snappedSamplesDown : maxSamplesDown;
      if (debugLevel >= 3)
        console.log("[georaster-layer-for-leaflet] extent of inner tile before snapping " + extentOfInnerTileInMapCRS.reproj(inSimpleCRS ? "simple" : 4326).bbox.toString());
      {
        const oldrb = new GeoExtent(oldExtentOfInnerTileInRasterCRS.bbox);
        const newrb = new GeoExtent(extentOfInnerTileInRasterCRS.bbox);
        const oldmb = new GeoExtent(extentOfInnerTileInMapCRS.bbox);
        if (oldrb.width !== 0 && oldrb.height !== 0) {
          let n0 = (newrb.xmin - oldrb.xmin) / oldrb.width * oldmb.width;
          let n1 = (newrb.ymin - oldrb.ymin) / oldrb.height * oldmb.height;
          let n2 = (newrb.xmax - oldrb.xmax) / oldrb.width * oldmb.width;
          let n3 = (newrb.ymax - oldrb.ymax) / oldrb.height * oldmb.height;
          if (!overdrawTileAcross) {
            n0 = Math.max(n0, 0);
            n2 = Math.min(n2, 0);
          }
          if (!overdrawTileDown) {
            n1 = Math.max(n1, 0);
            n3 = Math.min(n3, 0);
          }
          const newbox = [oldmb.xmin + n0, oldmb.ymin + n1, oldmb.xmax + n2, oldmb.ymax + n3];
          extentOfInnerTileInMapCRS = new GeoExtent(newbox, {
            srs: extentOfInnerTileInMapCRS.srs
          });
        }
      }
      if (debugLevel >= 4) {
        if (!this._cache.innerTile[cacheKey]) {
          const ext = inSimpleCRS ? extentOfInnerTileInMapCRS : extentOfInnerTileInMapCRS.reproj(4326);
          this._cache.innerTile[cacheKey] = L2.rectangle(ext.leafletBounds, {
            color: "#F00",
            dashArray: "5, 10",
            fillOpacity: 0
          }).addTo(this.getMap());
        }
      }
      if (debugLevel >= 3)
        console.log("[georaster-layer-for-leaflet] extent of inner tile after snapping " + extentOfInnerTileInMapCRS.reproj(inSimpleCRS ? "simple" : 4326).bbox.toString());
      const padding = {
        left: Math.round((extentOfInnerTileInMapCRS.xmin - extentOfTileInMapCRS.xmin) / widthOfScreenPixelInMapCRS),
        right: Math.round((extentOfTileInMapCRS.xmax - extentOfInnerTileInMapCRS.xmax) / widthOfScreenPixelInMapCRS),
        top: Math.round((extentOfTileInMapCRS.ymax - extentOfInnerTileInMapCRS.ymax) / heightOfScreenPixelInMapCRS),
        bottom: Math.round((extentOfInnerTileInMapCRS.ymin - extentOfTileInMapCRS.ymin) / heightOfScreenPixelInMapCRS)
      };
      if (debugLevel >= 3)
        log({
          padding
        });
      const innerTileHeight = this.tileHeight - padding.top - padding.bottom;
      const innerTileWidth = this.tileWidth - padding.left - padding.right;
      if (debugLevel >= 3)
        log({
          innerTileHeight,
          innerTileWidth
        });
      if (debugLevel >= 4) {
        const xMinOfInnerTileInMapCRS = extentOfTileInMapCRS.xmin + padding.left * widthOfScreenPixelInMapCRS;
        const yMinOfInnerTileInMapCRS = extentOfTileInMapCRS.ymin + padding.bottom * heightOfScreenPixelInMapCRS;
        const xMaxOfInnerTileInMapCRS = extentOfTileInMapCRS.xmax - padding.right * widthOfScreenPixelInMapCRS;
        const yMaxOfInnerTileInMapCRS = extentOfTileInMapCRS.ymax - padding.top * heightOfScreenPixelInMapCRS;
        log({
          xMinOfInnerTileInMapCRS,
          yMinOfInnerTileInMapCRS,
          xMaxOfInnerTileInMapCRS,
          yMaxOfInnerTileInMapCRS
        });
      }
      const canvasPadding = {
        left: Math.max(padding.left, 0),
        right: Math.max(padding.right, 0),
        top: Math.max(padding.top, 0),
        bottom: Math.max(padding.bottom, 0)
      };
      const canvasHeight = this.tileHeight - canvasPadding.top - canvasPadding.bottom;
      const canvasWidth = this.tileWidth - canvasPadding.left - canvasPadding.right;
      tile.style.paddingTop = canvasPadding.top + "px";
      tile.style.paddingRight = canvasPadding.right + "px";
      tile.style.paddingBottom = canvasPadding.bottom + "px";
      tile.style.paddingLeft = canvasPadding.left + "px";
      tile.height = canvasHeight;
      tile.style.height = canvasHeight + "px";
      tile.width = canvasWidth;
      tile.style.width = canvasWidth + "px";
      if (debugLevel >= 3)
        console.log("setting tile height to " + canvasHeight + "px");
      if (debugLevel >= 3)
        console.log("setting tile width to " + canvasWidth + "px");
      const heightOfSampleInScreenPixels = innerTileHeight / numberOfSamplesDown;
      const heightOfSampleInScreenPixelsInt = Math.ceil(heightOfSampleInScreenPixels);
      const widthOfSampleInScreenPixels = innerTileWidth / numberOfSamplesAcross;
      const widthOfSampleInScreenPixelsInt = Math.ceil(widthOfSampleInScreenPixels);
      const map = this.getMap();
      const tileSize = this.getTileSize();
      const tileNwPoint = coords.scaleBy(tileSize);
      if (debugLevel >= 4)
        log({
          tileNwPoint
        });
      const xLeftOfInnerTile = tileNwPoint.x + padding.left;
      const yTopOfInnerTile = tileNwPoint.y + padding.top;
      const innerTileTopLeftPoint = {
        x: xLeftOfInnerTile,
        y: yTopOfInnerTile
      };
      if (debugLevel >= 4)
        log({
          innerTileTopLeftPoint
        });
      setTimeout(async () => {
        try {
          let tileRasters = null;
          if (!rasters) {
            tileRasters = await this.getRasters({
              innerTileTopLeftPoint,
              heightOfSampleInScreenPixels,
              widthOfSampleInScreenPixels,
              zoom,
              pixelHeight,
              pixelWidth,
              numberOfSamplesAcross,
              numberOfSamplesDown,
              ymax,
              xmin
            });
            if (tileRasters && this.calcStats) {
              const {
                noDataValue
              } = this;
              for (let bandIndex = 0; bandIndex < tileRasters.length; bandIndex++) {
                let min = this.currentStats.mins[bandIndex];
                let max = this.currentStats.maxs[bandIndex];
                const band = tileRasters[bandIndex];
                for (let rowIndex = 0; rowIndex < band.length; rowIndex++) {
                  const row = band[rowIndex];
                  for (let columnIndex = 0; columnIndex < row.length; columnIndex++) {
                    const value = row[columnIndex];
                    if (value !== noDataValue) {
                      if (min === void 0 || value < min) {
                        min = value;
                      }
                      if (max === void 0 || value > max) {
                        max = value;
                      }
                    }
                  }
                }
                this.currentStats.mins[bandIndex] = min;
                this.currentStats.maxs[bandIndex] = max;
                this.currentStats.ranges[bandIndex] = max - min;
              }
              if (this._dynamic) {
                try {
                  const rawToRgbFn = rawToRgb.default || rawToRgb;
                  this.rawToRgb = rawToRgbFn({
                    format: "string",
                    flip: this.currentStats.mins.length === 1 ? true : false,
                    ranges: zip(this.currentStats.mins, this.currentStats.maxs),
                    round: true
                  });
                } catch (error2) {
                  console.error(error2);
                }
              }
            }
          }
          await this.checkIfYCbCr;
          for (let h = 0; h < numberOfSamplesDown; h++) {
            const yCenterInMapPixels = yTopOfInnerTile + (h + 0.5) * heightOfSampleInScreenPixels;
            const latWestPoint = L2.point(xLeftOfInnerTile, yCenterInMapPixels);
            const {
              lat
            } = map.unproject(latWestPoint, zoom);
            if (lat > yMinOfLayer && lat < yMaxOfLayer) {
              const yInTilePixels = Math.round(h * heightOfSampleInScreenPixels) + Math.min(padding.top, 0);
              let yInRasterPixels = 0;
              if (inSimpleCRS || this.projection === EPSG4326) {
                yInRasterPixels = Math.floor((yMaxOfLayer - lat) / pixelHeight);
              }
              for (let w = 0; w < numberOfSamplesAcross; w++) {
                const latLngPoint = L2.point(xLeftOfInnerTile + (w + 0.5) * widthOfSampleInScreenPixels, yCenterInMapPixels);
                const {
                  lng: xOfLayer
                } = map.unproject(latLngPoint, zoom);
                if (xOfLayer > xMinOfLayer && xOfLayer < xMaxOfLayer) {
                  let xInRasterPixels = 0;
                  if (inSimpleCRS || this.projection === EPSG4326) {
                    xInRasterPixels = Math.floor((xOfLayer - xMinOfLayer) / pixelWidth);
                  } else if (this.getProjector()) {
                    const inverted = this.getProjector().inverse({
                      x: xOfLayer,
                      y: lat
                    });
                    const yInSrc = inverted.y;
                    yInRasterPixels = Math.floor((ymax - yInSrc) / pixelHeight);
                    if (yInRasterPixels < 0 || yInRasterPixels >= rasterHeight)
                      continue;
                    const xInSrc = inverted.x;
                    xInRasterPixels = Math.floor((xInSrc - xmin) / pixelWidth);
                    if (xInRasterPixels < 0 || xInRasterPixels >= rasterWidth)
                      continue;
                  }
                  let values = null;
                  if (tileRasters) {
                    values = tileRasters.map((band) => band[h][w]);
                  } else if (rasters) {
                    values = rasters.map((band) => {
                      return band[yInRasterPixels][xInRasterPixels];
                    });
                  } else {
                    done && done(Error("no rasters are available for, so skipping value generation"));
                    return;
                  }
                  const x = Math.round(w * widthOfSampleInScreenPixels) + Math.min(padding.left, 0);
                  const y = yInTilePixels;
                  const width = widthOfSampleInScreenPixelsInt;
                  const height = heightOfSampleInScreenPixelsInt;
                  if (this.options.customDrawFunction) {
                    this.options.customDrawFunction({
                      values,
                      context,
                      x,
                      y,
                      width,
                      height,
                      rasterX: xInRasterPixels,
                      rasterY: yInRasterPixels,
                      sampleX: w,
                      sampleY: h,
                      sampledRaster: tileRasters
                    });
                  } else {
                    const color = this.getColor(values);
                    if (color && context) {
                      context.fillStyle = color;
                      context.fillRect(x, y, width, height);
                    }
                  }
                }
              }
            }
          }
          if (this.mask) {
            if (inSimpleCRS) {
              console.warn("[georaster-layer-for-leaflet] mask is not supported when using simple projection");
            } else {
              this.mask.then((mask) => {
                import_geocanvas.default.maskCanvas({
                  canvas: tile,
                  canvas_bbox: extentOfInnerTileInMapCRS.bbox,
                  canvas_srs: 3857,
                  mask,
                  mask_srs: this.mask_srs,
                  strategy: this.mask_strategy
                });
              });
            }
          }
          tile.style.visibility = "visible";
        } catch (e) {
          console.error(e);
          error = e;
        }
        done && done(error, tile);
      }, 0);
      return tile;
    } catch (error) {
      console.error(error);
      done && done(error, tile);
    }
  },
  _initTile: function(tile) {
    L2.DomUtil.addClass(tile, "leaflet-tile");
    tile.onselectstart = L2.Util.falseFn;
    tile.onmousemove = L2.Util.falseFn;
    if (L2.Browser.ielt9 && this.options.opacity < 1) {
      L2.DomUtil.setOpacity(tile, this.options.opacity);
    }
    if (L2.Browser.android && !L2.Browser.android23) {
      tile.style.WebkitBackfaceVisibility = "hidden";
    }
  },
  getBounds: function() {
    this.initBounds();
    return this._bounds;
  },
  getMap: function() {
    return this._map || this._mapToAdd;
  },
  getMapCRS: function() {
    var _this$getMap;
    return ((_this$getMap = this.getMap()) === null || _this$getMap === void 0 ? void 0 : _this$getMap.options.crs) || L2.CRS.EPSG3857;
  },
  _tileCoordsToNwSe: function(coords) {
    const map = this.getMap();
    const tileSize = this.getTileSize();
    const nwPoint = coords.scaleBy(tileSize);
    const sePoint = nwPoint.add(tileSize);
    const nw = map.unproject(nwPoint, coords.z);
    const se = map.unproject(sePoint, coords.z);
    return [nw, se];
  },
  _tileCoordsToBounds: function(coords) {
    const [nw, se] = this._tileCoordsToNwSe(coords);
    let bounds = new L2.LatLngBounds(nw, se);
    if (!this.options.noWrap) {
      const {
        crs
      } = this.getMap().options;
      bounds = crs.wrapLatLngBounds(bounds);
    }
    return bounds;
  },
  _isValidTile: function(coords) {
    const crs = this.getMapCRS();
    if (!crs.infinite) {
      const globalBounds = this._globalTileRange;
      if (!crs.wrapLng && (coords.x < globalBounds.min.x || coords.x > globalBounds.max.x) || !crs.wrapLat && (coords.y < globalBounds.min.y || coords.y > globalBounds.max.y)) {
        return false;
      }
    }
    const bounds = this.getBounds();
    if (!bounds) {
      return true;
    }
    const {
      x,
      y,
      z
    } = coords;
    const layerExtent = new GeoExtent(bounds, {
      srs: 4326
    });
    const boundsOfTile = this._tileCoordsToBounds(coords);
    if (layerExtent.overlaps(boundsOfTile))
      return true;
    if (isSimpleCRS(crs))
      return false;
    const width = Math.pow(2, z);
    const leftCoords = L2.point(x - width, y);
    leftCoords.z = z;
    const leftBounds = this._tileCoordsToBounds(leftCoords);
    if (layerExtent.overlaps(leftBounds))
      return true;
    const rightCoords = L2.point(x + width, y);
    rightCoords.z = z;
    const rightBounds = this._tileCoordsToBounds(rightCoords);
    if (layerExtent.overlaps(rightBounds))
      return true;
    return false;
  },
  getColor: function(values) {
    if (this.options.pixelValuesToColorFn) {
      return this.options.pixelValuesToColorFn(values);
    } else {
      const numberOfValues = values.length;
      const haveDataForAllBands = values.every((value) => value !== void 0 && value !== this.noDataValue);
      if (haveDataForAllBands) {
        if (numberOfValues == 1) {
          const value = values[0];
          if (this.palette) {
            const [r, g, b, a] = this.palette[value];
            return `rgba(${r},${g},${b},${a / 255})`;
          } else if (this.georasters[0].mins) {
            const {
              mins,
              ranges
            } = this.georasters[0];
            return this.scale((values[0] - mins[0]) / ranges[0]).hex();
          } else if (this.currentStats.mins) {
            const min = this.currentStats.mins[0];
            const range2 = this.currentStats.ranges[0];
            return this.scale((values[0] - min) / range2).hex();
          }
        } else if (numberOfValues === 2) {
          return `rgb(${values[0]},${values[1]},0)`;
        } else if (numberOfValues === 3) {
          return `rgb(${values[0]},${values[1]},${values[2]})`;
        } else if (numberOfValues === 4) {
          return `rgba(${values[0]},${values[1]},${values[2]},${values[3] / 255})`;
        }
      }
    }
  },
  updateColors(pixelValuesToColorFn, {
    debugLevel = -1
  } = {
    debugLevel: -1
  }) {
    if (!pixelValuesToColorFn) {
      throw new Error("Missing pixelValuesToColorFn function");
    }
    if (debugLevel === -1)
      debugLevel = this.debugLevel;
    if (debugLevel >= 1)
      console.log("Start updating active tile pixel values");
    this.options.pixelValuesToColorFn = pixelValuesToColorFn;
    const tiles = this.getActiveTiles();
    if (!tiles) {
      console.error("No active tiles available");
      return this;
    }
    if (debugLevel >= 1)
      console.log("Active tiles fetched", tiles);
    tiles.forEach((tile) => {
      const {
        coords,
        el
      } = tile;
      this.drawTile({
        tile: el,
        coords,
        context: el.getContext("2d")
      });
    });
    if (debugLevel >= 1)
      console.log("Finished updating active tile colours");
    return this;
  },
  getTiles() {
    return Object.values(this._tiles);
  },
  getActiveTiles() {
    const tiles = this.getTiles();
    return tiles.filter((tile) => this._isValidTile(tile.coords));
  },
  isSupportedProjection: function() {
    if (this._isSupportedProjection === void 0) {
      const projection = this.projection;
      if ((0, import_isUTM.default)(projection)) {
        this._isSupportedProjection = true;
      } else if (PROJ4_SUPPORTED_PROJECTIONS.has(projection)) {
        this._isSupportedProjection = true;
      } else if (typeof import_proj4_fully_loaded.default === "function" && `EPSG:${projection}` in import_proj4_fully_loaded.default.defs) {
        this._isSupportedProjection = true;
      } else if (typeof proj4 === "function" && typeof proj4.defs !== "undefined" && `EPSG:${projection}` in proj4.defs) {
        this._isSupportedProjection = true;
      } else {
        this._isSupportedProjection = false;
      }
    }
    return this._isSupportedProjection;
  },
  getProjectionString: function(projection) {
    if ((0, import_isUTM.default)(projection)) {
      return (0, import_getProjString.default)(projection);
    }
    return `EPSG:${projection}`;
  },
  initBounds: function(options) {
    if (!options)
      options = this.options;
    if (!this._bounds) {
      const {
        debugLevel,
        height,
        width,
        projection,
        xmin,
        xmax,
        ymin,
        ymax
      } = this;
      if (isSimpleCRS(this.getMapCRS())) {
        if (height === width) {
          this._bounds = L2.latLngBounds([ORIGIN, [MAX_NORTHING, MAX_EASTING]]);
        } else if (height > width) {
          this._bounds = L2.latLngBounds([ORIGIN, [MAX_NORTHING, MAX_EASTING / this.ratio]]);
        } else if (width > height) {
          this._bounds = L2.latLngBounds([ORIGIN, [MAX_NORTHING * this.ratio, MAX_EASTING]]);
        }
      } else if (projection === EPSG4326) {
        if (debugLevel >= 1)
          console.log(`georaster projection is in ${EPSG4326}`);
        const minLatWest = L2.latLng(ymin, xmin);
        const maxLatEast = L2.latLng(ymax, xmax);
        this._bounds = L2.latLngBounds(minLatWest, maxLatEast);
      } else if (this.getProjector()) {
        if (debugLevel >= 1)
          console.log("projection is UTM or supported by proj4");
        const bottomLeft = this.getProjector().forward({
          x: xmin,
          y: ymin
        });
        const minLatWest = L2.latLng(bottomLeft.y, bottomLeft.x);
        const topRight = this.getProjector().forward({
          x: xmax,
          y: ymax
        });
        const maxLatEast = L2.latLng(topRight.y, topRight.x);
        this._bounds = L2.latLngBounds(minLatWest, maxLatEast);
      } else {
        if (typeof import_proj4_fully_loaded.default !== "function") {
          throw `You are using the lite version of georaster-layer-for-leaflet, which does not support rasters with the projection ${projection}.  Please try using the default build or add the projection definition to your global proj4.`;
        } else {
          throw `GeoRasterLayer does not provide built-in support for rasters with the projection ${projection}.  Add the projection definition to your global proj4.`;
        }
      }
      this.xMinOfLayer = this._bounds.getWest();
      this.xMaxOfLayer = this._bounds.getEast();
      this.yMaxOfLayer = this._bounds.getNorth();
      this.yMinOfLayer = this._bounds.getSouth();
      options.bounds = this._bounds;
    }
  },
  getProjector: function() {
    if (this.isSupportedProjection()) {
      if (!import_proj4_fully_loaded.default && !proj4) {
        throw "proj4 must be found in the global scope in order to load a raster that uses this projection";
      }
      if (!this._projector) {
        const projString = this.getProjectionString(this.projection);
        if (this.debugLevel >= 1)
          log({
            projString
          });
        let proj4Lib;
        if (projString.startsWith("EPSG")) {
          if (typeof proj4 === "function" && typeof proj4.defs === "function" && projString in proj4.defs) {
            proj4Lib = proj4;
          } else if (typeof import_proj4_fully_loaded.default === "function" && typeof import_proj4_fully_loaded.default.defs === "function" && projString in import_proj4_fully_loaded.default.defs) {
            proj4Lib = import_proj4_fully_loaded.default;
          } else {
            throw "[georaster-layer-for-leaflet] projection not found in proj4 instance";
          }
        } else {
          if (typeof proj4 === "function") {
            proj4Lib = proj4;
          } else if (typeof import_proj4_fully_loaded.default === "function") {
            proj4Lib = import_proj4_fully_loaded.default;
          } else {
            throw "[georaster-layer-for-leaflet] projection not found in proj4 instance";
          }
        }
        this._projector = proj4Lib(projString, `EPSG:${EPSG4326}`);
        if (this.debugLevel >= 1)
          console.log("projector set");
      }
      return this._projector;
    }
  },
  same(array, key) {
    return new Set(array.map((item) => item[key])).size === 1;
  }
});
if (typeof window === "object") {
  window["GeoRasterLayer"] = GeoRasterLayer;
}
if (typeof self !== "undefined") {
  self["GeoRasterLayer"] = GeoRasterLayer;
}
var georaster_layer_for_leaflet_default = GeoRasterLayer;
export {
  georaster_layer_for_leaflet_default as default
};
/* @preserve
 * Leaflet 1.9.4, a JS library for interactive maps. https://leafletjs.com
 * (c) 2010-2023 Vladimir Agafonkin, (c) 2010-2011 CloudMade
 */
/**
	ColorBrewer colors for chroma.js

	Copyright (c) 2002 Cynthia Brewer, Mark Harrower, and The 
	Pennsylvania State University.

	Licensed under the Apache License, Version 2.0 (the "License"); 
	you may not use this file except in compliance with the License.
	You may obtain a copy of the License at	
	http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software distributed
	under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
	CONDITIONS OF ANY KIND, either express or implied. See the License for the
	specific language governing permissions and limitations under the License.

    @preserve
 */
/**
 * @license
 *
 * chroma.js - JavaScript library for color conversions
 * 
 * Copyright (c) 2011-2017, Gregor Aisch
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * 3. The name Gregor Aisch may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
//# sourceMappingURL=georaster-layer-for-leaflet.js.map
